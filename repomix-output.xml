This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.claude/
  settings.local.json
public/
  file.svg
  globe.svg
  next.svg
  vercel.svg
  window.svg
src/
  ai/
    AIManager.ts
    aiWorker.ts
    cerebrasClient.ts
    index.ts
    README.md
    taskParser.ts
    tester.ts
    toolExecutor.ts
    tools.ts
    types.ts
  app/
    api/
      cerebras-tasks/
        route.ts
    globals.css
    layout.tsx
    page.tsx
  input/
    index.ts
    InputManager.ts
    inputWorker.ts
    speechService.ts
    SpeechTranscriptionProvider.tsx
    useSpeechTranscription.ts
    VoiceTaskListener.tsx
  lib/
    eventBus.ts
  ui/
    components/
      aiWindow/
        AIWindow.tsx
        index.ts
      background/
        AnimatedBackground.tsx
        index.ts
      barGraph/
        BarGraph.tsx
        barGraph.types.ts
        index.ts
      barGraphWindow/
        BarGraphWindow.tsx
        index.ts
      debugSidebar/
        DebugSidebar.tsx
        index.ts
      graphWindow/
        GraphWindow.tsx
        index.ts
      imageDropZone/
        ImageDropZone.tsx
        index.ts
      imageViewer/
        ImageViewer.tsx
        index.ts
      inputWindow/
        index.ts
        InputWindow.tsx
      lineGraph/
        index.ts
        LineGraph.tsx
        lineGraph.types.ts
      pieChart/
        index.ts
        PieChart.tsx
        pieChart.types.ts
        PieChartWindow.tsx
      systemOutput/
        index.ts
        SystemOutput.tsx
        systemOutput.types.ts
      userNotes/
        index.ts
        UserNotes.tsx
        userNotes.types.ts
      window/
        index.ts
        Window.tsx
        window.types.ts
      windowManager/
        index.ts
        WindowManager.tsx
        windowManager.types.ts
      README.md
    index.ts
    MainUI.tsx
.gitignore
debug_commands.js
eslint.config.mjs
next.config.ts
package.json
postcss.config.mjs
README.md
tsconfig.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".claude/settings.local.json">
{
  "permissions": {
    "allow": [
      "Bash(mkdir:*)",
      "Bash(tree:*)",
      "Bash(npm run build:*)"
    ],
    "deny": [],
    "ask": []
  }
}
</file>

<file path="public/file.svg">
<svg fill="none" viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M14.5 13.5V5.41a1 1 0 0 0-.3-.7L9.8.29A1 1 0 0 0 9.08 0H1.5v13.5A2.5 2.5 0 0 0 4 16h8a2.5 2.5 0 0 0 2.5-2.5m-1.5 0v-7H8v-5H3v12a1 1 0 0 0 1 1h8a1 1 0 0 0 1-1M9.5 5V2.12L12.38 5zM5.13 5h-.62v1.25h2.12V5zm-.62 3h7.12v1.25H4.5zm.62 3h-.62v1.25h7.12V11z" clip-rule="evenodd" fill="#666" fill-rule="evenodd"/></svg>
</file>

<file path="public/globe.svg">
<svg fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><g clip-path="url(#a)"><path fill-rule="evenodd" clip-rule="evenodd" d="M10.27 14.1a6.5 6.5 0 0 0 3.67-3.45q-1.24.21-2.7.34-.31 1.83-.97 3.1M8 16A8 8 0 1 0 8 0a8 8 0 0 0 0 16m.48-1.52a7 7 0 0 1-.96 0H7.5a4 4 0 0 1-.84-1.32q-.38-.89-.63-2.08a40 40 0 0 0 3.92 0q-.25 1.2-.63 2.08a4 4 0 0 1-.84 1.31zm2.94-4.76q1.66-.15 2.95-.43a7 7 0 0 0 0-2.58q-1.3-.27-2.95-.43a18 18 0 0 1 0 3.44m-1.27-3.54a17 17 0 0 1 0 3.64 39 39 0 0 1-4.3 0 17 17 0 0 1 0-3.64 39 39 0 0 1 4.3 0m1.1-1.17q1.45.13 2.69.34a6.5 6.5 0 0 0-3.67-3.44q.65 1.26.98 3.1M8.48 1.5l.01.02q.41.37.84 1.31.38.89.63 2.08a40 40 0 0 0-3.92 0q.25-1.2.63-2.08a4 4 0 0 1 .85-1.32 7 7 0 0 1 .96 0m-2.75.4a6.5 6.5 0 0 0-3.67 3.44 29 29 0 0 1 2.7-.34q.31-1.83.97-3.1M4.58 6.28q-1.66.16-2.95.43a7 7 0 0 0 0 2.58q1.3.27 2.95.43a18 18 0 0 1 0-3.44m.17 4.71q-1.45-.12-2.69-.34a6.5 6.5 0 0 0 3.67 3.44q-.65-1.27-.98-3.1" fill="#666"/></g><defs><clipPath id="a"><path fill="#fff" d="M0 0h16v16H0z"/></clipPath></defs></svg>
</file>

<file path="public/next.svg">
<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 394 80"><path fill="#000" d="M262 0h68.5v12.7h-27.2v66.6h-13.6V12.7H262V0ZM149 0v12.7H94v20.4h44.3v12.6H94v21h55v12.6H80.5V0h68.7zm34.3 0h-17.8l63.8 79.4h17.9l-32-39.7 32-39.6h-17.9l-23 28.6-23-28.6zm18.3 56.7-9-11-27.1 33.7h17.8l18.3-22.7z"/><path fill="#000" d="M81 79.3 17 0H0v79.3h13.6V17l50.2 62.3H81Zm252.6-.4c-1 0-1.8-.4-2.5-1s-1.1-1.6-1.1-2.6.3-1.8 1-2.5 1.6-1 2.6-1 1.8.3 2.5 1a3.4 3.4 0 0 1 .6 4.3 3.7 3.7 0 0 1-3 1.8zm23.2-33.5h6v23.3c0 2.1-.4 4-1.3 5.5a9.1 9.1 0 0 1-3.8 3.5c-1.6.8-3.5 1.3-5.7 1.3-2 0-3.7-.4-5.3-1s-2.8-1.8-3.7-3.2c-.9-1.3-1.4-3-1.4-5h6c.1.8.3 1.6.7 2.2s1 1.2 1.6 1.5c.7.4 1.5.5 2.4.5 1 0 1.8-.2 2.4-.6a4 4 0 0 0 1.6-1.8c.3-.8.5-1.8.5-3V45.5zm30.9 9.1a4.4 4.4 0 0 0-2-3.3 7.5 7.5 0 0 0-4.3-1.1c-1.3 0-2.4.2-3.3.5-.9.4-1.6 1-2 1.6a3.5 3.5 0 0 0-.3 4c.3.5.7.9 1.3 1.2l1.8 1 2 .5 3.2.8c1.3.3 2.5.7 3.7 1.2a13 13 0 0 1 3.2 1.8 8.1 8.1 0 0 1 3 6.5c0 2-.5 3.7-1.5 5.1a10 10 0 0 1-4.4 3.5c-1.8.8-4.1 1.2-6.8 1.2-2.6 0-4.9-.4-6.8-1.2-2-.8-3.4-2-4.5-3.5a10 10 0 0 1-1.7-5.6h6a5 5 0 0 0 3.5 4.6c1 .4 2.2.6 3.4.6 1.3 0 2.5-.2 3.5-.6 1-.4 1.8-1 2.4-1.7a4 4 0 0 0 .8-2.4c0-.9-.2-1.6-.7-2.2a11 11 0 0 0-2.1-1.4l-3.2-1-3.8-1c-2.8-.7-5-1.7-6.6-3.2a7.2 7.2 0 0 1-2.4-5.7 8 8 0 0 1 1.7-5 10 10 0 0 1 4.3-3.5c2-.8 4-1.2 6.4-1.2 2.3 0 4.4.4 6.2 1.2 1.8.8 3.2 2 4.3 3.4 1 1.4 1.5 3 1.5 5h-5.8z"/></svg>
</file>

<file path="public/vercel.svg">
<svg fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1155 1000"><path d="m577.3 0 577.4 1000H0z" fill="#fff"/></svg>
</file>

<file path="public/window.svg">
<svg fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><path fill-rule="evenodd" clip-rule="evenodd" d="M1.5 2.5h13v10a1 1 0 0 1-1 1h-11a1 1 0 0 1-1-1zM0 1h16v11.5a2.5 2.5 0 0 1-2.5 2.5h-11A2.5 2.5 0 0 1 0 12.5zm3.75 4.5a.75.75 0 1 0 0-1.5.75.75 0 0 0 0 1.5M7 4.75a.75.75 0 1 1-1.5 0 .75.75 0 0 1 1.5 0m1.75.75a.75.75 0 1 0 0-1.5.75.75 0 0 0 0 1.5" fill="#666"/></svg>
</file>

<file path="src/app/layout.tsx">
import type { Metadata } from "next";
import { Geist, Geist_Mono } from "next/font/google";
import "./globals.css";

const geistSans = Geist({
  variable: "--font-geist-sans",
  subsets: ["latin"],
});

const geistMono = Geist_Mono({
  variable: "--font-geist-mono",
  subsets: ["latin"],
});

export const metadata: Metadata = {
  title: "Jarvis",
  description: "Event-driven application architecture",
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en">
      <body
        className={`${geistSans.variable} ${geistMono.variable} antialiased`}
      >
        {children}
      </body>
    </html>
  );
}
</file>

<file path="src/app/page.tsx">
import { MainUI } from '@/ui/MainUI';

export default function Home() {
  return <MainUI />;
}
</file>

<file path="src/input/InputManager.ts">
/* eslint-disable @typescript-eslint/no-explicit-any */
import { eventBus } from '@/lib/eventBus';

export class InputManager {
  private worker: Worker | null = null;
  private isInitialized = false;

  async initialize(): Promise<void> {
    if (this.isInitialized) return;

    try {
      this.worker = new Worker(new URL('./inputWorker.ts', import.meta.url));
      
      this.worker.onmessage = (event) => {
        const { type, data } = event.data;
        eventBus.emit(`input:${type.toLowerCase()}`, data);
      };

      this.worker.onerror = (error) => {
        console.error('Input worker error:', error);
        eventBus.emit('input:error', error);
      };

      this.isInitialized = true;
      eventBus.emit('input:initialized');
    } catch (error) {
      console.error('Failed to initialize input worker:', error);
      eventBus.emit('input:error', error);
    }
  }

  processInput(input: any): void {
    if (!this.worker) {
      console.warn('Input worker not initialized');
      return;
    }

    this.worker.postMessage({
      type: 'PROCESS_INPUT',
      data: input
    });
  }

  validateInput(input: any): void {
    if (!this.worker) {
      console.warn('Input worker not initialized');
      return;
    }

    this.worker.postMessage({
      type: 'VALIDATE_INPUT',
      data: input
    });
  }

  destroy(): void {
    if (this.worker) {
      this.worker.terminate();
      this.worker = null;
    }
    this.isInitialized = false;
    eventBus.emit('input:destroyed');
  }
}

export const inputManager = new InputManager();
</file>

<file path="src/input/inputWorker.ts">
/* eslint-disable @typescript-eslint/no-explicit-any */
self.addEventListener('message', (event) => {
  const { type, data } = event.data;
  
  switch (type) {
    case 'PROCESS_INPUT':
      const processedData = processInput(data);
      self.postMessage({
        type: 'INPUT_PROCESSED',
        data: processedData
      });
      break;
    
    case 'VALIDATE_INPUT':
      const isValid = validateInput(data);
      self.postMessage({
        type: 'INPUT_VALIDATED',
        data: { isValid, input: data }
      });
      break;
    
    default:
      console.warn(`Unknown input worker message type: ${type}`);
  }
});

function processInput(input: any) {
  return {
    processed: true,
    timestamp: Date.now(),
    input
  };
}

function validateInput(input: any): boolean {
  return input != null && input !== '';
}

export {};
</file>

<file path="src/input/SpeechTranscriptionProvider.tsx">
'use client';

import { createContext, useContext, ReactNode } from 'react';
import { useSpeechTranscription, UseSpeechTranscriptionReturn, UseSpeechTranscriptionOptions } from './useSpeechTranscription';

const SpeechTranscriptionContext = createContext<UseSpeechTranscriptionReturn | null>(null);

export interface SpeechTranscriptionProviderProps {
  children: ReactNode;
  options?: UseSpeechTranscriptionOptions;
}

export function SpeechTranscriptionProvider({
  children,
  options = {}
}: SpeechTranscriptionProviderProps) {
  const speechTranscription = useSpeechTranscription(options);

  return (
    <SpeechTranscriptionContext.Provider value={speechTranscription}>
      {children}
    </SpeechTranscriptionContext.Provider>
  );
}

export function useSpeechTranscriptionContext(): UseSpeechTranscriptionReturn {
  const context = useContext(SpeechTranscriptionContext);

  if (!context) {
    throw new Error('useSpeechTranscriptionContext must be used within a SpeechTranscriptionProvider');
  }

  return context;
}

export function SpeechIndicator() {
  const { isListening, isSupported } = useSpeechTranscriptionContext();

  if (!isSupported) {
    return null;
  }

  return (
    <div className="fixed top-4 right-4 z-50">
      <div className={`flex items-center px-3 py-2 rounded-full text-sm font-medium shadow-lg ${
        isListening
          ? 'bg-red-500 text-white'
          : 'bg-gray-200 text-gray-700'
      }`}>
        <div className={`w-2 h-2 rounded-full mr-2 ${
          isListening ? 'bg-white animate-pulse' : 'bg-gray-400'
        }`}></div>
        {isListening ? 'Listening' : 'Not listening'}
      </div>
    </div>
  );
}
</file>

<file path="src/lib/eventBus.ts">
/* eslint-disable @typescript-eslint/no-explicit-any */
type EventCallback<T = any> = (data: T) => void;

class EventBus {
  private listeners: Map<string, Set<EventCallback>> = new Map();

  on<T = any>(event: string, callback: EventCallback<T>): () => void {
    if (!this.listeners.has(event)) {
      this.listeners.set(event, new Set());
    }
    
    this.listeners.get(event)!.add(callback);
    
    return () => this.off(event, callback);
  }

  off<T = any>(event: string, callback: EventCallback<T>): void {
    const eventListeners = this.listeners.get(event);
    if (eventListeners) {
      eventListeners.delete(callback);
      if (eventListeners.size === 0) {
        this.listeners.delete(event);
      }
    }
  }

  emit<T = any>(event: string, data?: T): void {
    const eventListeners = this.listeners.get(event);
    if (eventListeners) {
      eventListeners.forEach(callback => callback(data));
    }
  }

  once<T = any>(event: string, callback: EventCallback<T>): void {
    const onceCallback = (data: T) => {
      callback(data);
      this.off(event, onceCallback);
    };
    this.on(event, onceCallback);
  }

  clear(): void {
    this.listeners.clear();
  }
}

export const eventBus = new EventBus();
export type { EventCallback };
</file>

<file path="src/ui/components/aiWindow/index.ts">
export { AIWindow } from './AIWindow';
</file>

<file path="src/ui/components/background/index.ts">
export { AnimatedBackground } from './AnimatedBackground';
</file>

<file path="src/ui/components/barGraph/barGraph.types.ts">
export interface DataPoint {
  label: string;
  x: number;
  y: number;
}

export interface BarGraphProps {
  data: DataPoint[];
  width?: number;
  height?: number;
  title?: string;
  xAxisLabel?: string;
  yAxisLabel?: string;
  barColor?: string;
  barHoverColor?: string;
  gridColor?: string;
  backgroundColor?: string;
  showGrid?: boolean;
  showValues?: boolean;
  barSpacing?: number;
  barBorderRadius?: number;
}

export interface GraphBounds {
  minX: number;
  maxX: number;
  minY: number;
  maxY: number;
}
</file>

<file path="src/ui/components/barGraph/index.ts">
export { BarGraph } from './BarGraph';
export type { DataPoint, BarGraphProps, GraphBounds } from './barGraph.types';
</file>

<file path="src/ui/components/barGraphWindow/index.ts">
export { BarGraphWindow } from './BarGraphWindow';
</file>

<file path="src/ui/components/debugSidebar/index.ts">
export * from './DebugSidebar';
</file>

<file path="src/ui/components/graphWindow/index.ts">
export { GraphWindow } from './GraphWindow';
</file>

<file path="src/ui/components/imageDropZone/index.ts">
export { ImageDropZone } from './ImageDropZone';
</file>

<file path="src/ui/components/imageViewer/index.ts">
export { ImageViewer } from './ImageViewer';
</file>

<file path="src/ui/components/inputWindow/index.ts">
export { InputWindow } from './InputWindow';
</file>

<file path="src/ui/components/lineGraph/index.ts">
export { LineGraph } from './LineGraph';
export type { DataPoint, LineGraphProps, GraphBounds } from './lineGraph.types';
</file>

<file path="src/ui/components/lineGraph/lineGraph.types.ts">
export interface DataPoint {
  label: string;
  x: number;
  y: number;
}

export interface LineGraphProps {
  data: DataPoint[];
  width?: number;
  height?: number;
  title?: string;
  xAxisLabel?: string;
  yAxisLabel?: string;
  lineColor?: string;
  pointColor?: string;
  gridColor?: string;
  backgroundColor?: string;
  showGrid?: boolean;
  showPoints?: boolean;
  lineThickness?: number;
  pointRadius?: number;
}

export interface GraphBounds {
  minX: number;
  maxX: number;
  minY: number;
  maxY: number;
}
</file>

<file path="src/ui/components/pieChart/index.ts">
export { PieChart } from './PieChart';
export { PieChartWindow } from './PieChartWindow';
export type { DataPoint, PieChartProps, PieSlice } from './pieChart.types';
</file>

<file path="src/ui/components/pieChart/pieChart.types.ts">
export interface DataPoint {
  label: string;
  x: number; // Not used for pie charts but kept for consistency
  y: number; // This will be the value for the pie slice
}

export interface PieSlice {
  label: string;
  value: number;
  percentage: number;
  startAngle: number;
  endAngle: number;
  color: string;
}

export interface PieChartProps {
  data: DataPoint[];
  width?: number;
  height?: number;
  title?: string;
  radius?: number;
  innerRadius?: number; // For donut charts
  colors?: string[];
  showLabels?: boolean;
  showPercentages?: boolean;
  showLegend?: boolean;
  animationDuration?: number;
}
</file>

<file path="src/ui/components/pieChart/PieChartWindow.tsx">
'use client';

import { useState } from 'react';
import { PieChart } from './PieChart';
import { DataPoint } from './pieChart.types';

export function PieChartWindow() {
  const [data] = useState<DataPoint[]>([
    { label: 'Development', x: 0, y: 40 },
    { label: 'Design', x: 1, y: 25 },
    { label: 'Testing', x: 2, y: 20 },
    { label: 'Documentation', x: 3, y: 10 },
    { label: 'Deployment', x: 4, y: 5 }
  ]);

  const [title] = useState('Project Time Distribution');

  return (
    <div className="h-full w-full p-6">
      <PieChart
        data={data}
        title={title}
        width={600}
        height={450}
        showLabels={true}
        showPercentages={true}
        showLegend={true}
      />
    </div>
  );
}
</file>

<file path="src/ui/components/systemOutput/index.ts">
export { SystemOutput } from './SystemOutput';
export type { SystemOutputState, SystemOutputProps } from './systemOutput.types';
</file>

<file path="src/ui/components/systemOutput/systemOutput.types.ts">
export interface SystemOutputState {
  content: string;
  lastModified: Date;
}

export interface SystemOutputProps {
  placeholder?: string;
}
</file>

<file path="src/ui/components/userNotes/index.ts">
export { UserNotes } from './UserNotes';
export type { UserNotesState, UserNotesProps } from './userNotes.types';
</file>

<file path="src/ui/components/window/index.ts">
export { Window } from './Window';
export type { WindowProps, WindowState } from './window.types';
</file>

<file path="src/ui/components/windowManager/index.ts">
export { WindowManager } from './WindowManager';
export type { WindowManagerRef } from './WindowManager';
export type { WindowData, WindowManagerState } from './windowManager.types';
</file>

<file path="src/ui/components/README.md">
# UI Components

This directory contains UI component submodules. Each submodule should:

1. Communicate only through the global event bus
2. Be independently developable 
3. Follow the established patterns

## Structure

```
components/
├── component1/
│   ├── index.ts
│   ├── Component1.tsx
│   └── component1.types.ts
├── component2/
│   ├── index.ts
│   ├── Component2.tsx
│   └── component2.types.ts
└── ...
```

## Event Bus Usage

Components should:
- Listen to relevant events using `eventBus.on()`
- Emit events using `eventBus.emit()`
- Clean up listeners in useEffect cleanup functions
</file>

<file path="src/ui/index.ts">
export { MainUI } from './MainUI';
</file>

<file path="debug_commands.js">
// Debug commands to test in browser console
// After opening the app, paste these into the browser console:

console.log("=== Testing AI Command Parsing ===");

// Test 1: Simple content
console.log("\n1. Testing: 'open a window saying cheese'");
aiTester.testCommand("open a window saying cheese");

// Test 2: Multiple windows
console.log("\n2. Testing: 'open 7 windows saying hello'");
aiTester.testCommand("open 7 windows saying hello");

// Test 3: Close window
console.log("\n3. Testing: 'close window'");
aiTester.testCommand("close window");

// Test 4: Close all windows
console.log("\n4. Testing: 'close all windows'");
aiTester.testCommand("close all windows");

// Test 5: Check if fallback parsing is being used
console.log("\n5. Manual fallback test:");
// This will test the TaskParser directly
</file>

<file path="eslint.config.mjs">
import { dirname } from "path";
import { fileURLToPath } from "url";
import { FlatCompat } from "@eslint/eslintrc";

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

const compat = new FlatCompat({
  baseDirectory: __dirname,
});

const eslintConfig = [
  ...compat.extends("next/core-web-vitals", "next/typescript"),
  {
    ignores: [
      "node_modules/**",
      ".next/**",
      "out/**",
      "build/**",
      "next-env.d.ts",
    ],
  },
];

export default eslintConfig;
</file>

<file path="next.config.ts">
import type { NextConfig } from "next";

const nextConfig: NextConfig = {
  /* config options here */
};

export default nextConfig;
</file>

<file path="package.json">
{
  "name": "jarvis",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev --turbopack",
    "build": "next build --turbopack",
    "start": "next start",
    "lint": "eslint"
  },
  "dependencies": {
    "react": "19.1.0",
    "react-dom": "19.1.0",
    "next": "15.5.3"
  },
  "devDependencies": {
    "typescript": "^5",
    "@types/node": "^20",
    "@types/react": "^19",
    "@types/react-dom": "^19",
    "@tailwindcss/postcss": "^4",
    "tailwindcss": "^4",
    "eslint": "^9",
    "eslint-config-next": "15.5.3",
    "@eslint/eslintrc": "^3"
  }
}
</file>

<file path="postcss.config.mjs">
const config = {
  plugins: ["@tailwindcss/postcss"],
};

export default config;
</file>

<file path="tsconfig.json">
{
  "compilerOptions": {
    "target": "ES2017",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": ["./src/*"]
    }
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
  "exclude": ["node_modules"]
}
</file>

<file path="src/ai/README.md">
# Jarvis AI System

This is the AI component of the Jarvis project that converts natural language text commands into structured tasks and executes them using available tools.

## Architecture

```
Text Input → TaskParser → ToolExecutor → Event Bus → UI
             (Cerebras)    (Local)       (Events)
```

## Components

### 1. TaskParser (`taskParser.ts`)
- Converts natural language text to structured tasks using Cerebras API
- Includes fallback parsing for simple commands when Cerebras is unavailable
- Handles complex multi-command inputs

### 2. ToolExecutor (`toolExecutor.ts`)
- Executes parsed tasks using available tools
- Emits events to the UI via the event bus
- Manages tool parameter validation and error handling

### 3. CerebrasClient (`cerebrasClient.ts`)
- Handles communication with Cerebras API
- Manages API requests, authentication, and error handling
- Configurable model and parameters

### 4. Tools (`tools.ts`)
- Defines available tools (currently: open_window, close_window)
- Tool schema definitions for Cerebras function calling
- Tool discovery and validation utilities

### 5. AIManager (`AIManager.ts`)
- Main interface for the AI system
- Manages the AI worker thread
- Provides methods for processing text commands

### 6. AI Worker (`aiWorker.ts`)
- Web Worker for non-blocking AI processing
- Coordinates TaskParser and ToolExecutor
- Handles different message types and error scenarios

### 7. Tester (`tester.ts`)
- Comprehensive testing utilities for the AI system
- Predefined test commands and interactive testing
- Event monitoring and debugging tools

## Setup

### Prerequisites
1. Cerebras API key (set as `CEREBRAS_API_KEY` environment variable)
2. Node.js and npm/pnpm installed

### Configuration
Create a `.env.local` file in the project root:
```
CEREBRAS_API_KEY=your_cerebras_api_key_here
```

## Usage

### Basic Text Command Processing
```typescript
import { aiManager } from '@/ai';

// Initialize the AI manager
await aiManager.initialize();

// Process a text command
aiManager.processTextCommand("open a sticky note saying 'Hello World'");

// Listen for results
eventBus.on('ai:text_command_processed', (result) => {
  console.log('Command processed:', result);
});
```

### Using Individual Components
```typescript
import { TaskParser, ToolExecutor } from '@/ai';

const parser = new TaskParser();
const executor = new ToolExecutor();

// Parse text to tasks
const result = await parser.parseTextToTasks("create a notification window");

// Execute tasks
const executionResults = await executor.executeTasks(result.tasks);
```

### Testing
```typescript
import { aiTester } from '@/ai';

// Run all predefined tests
await aiTester.runTests();

// Test a specific command
await aiTester.testCommand("open a settings dialog");

// Interactive testing (also available in browser console as window.aiTester)
aiTester.interactive();
```

## Available Tools

### open_window
Opens a new popup window with specified type and context.

**Parameters:**
- `windowType`: string - Type of window (notification, dialog, settings, sticky-note, general)
- `context`: object - Window context information
  - `title`: string - Window title
  - `content`: string - Window content
  - `type`: string - Window type
  - `position`: {x, y} - Optional position
  - `size`: {width, height} - Optional size
  - `metadata`: object - Optional education-specific metadata (e.g., `lessonId`, `step`, `quizQuestions`)

**Examples:**
```
"open a sticky note saying 'Buy groceries'"
```

```
"start lesson 'Derivatives' step 1"
```

```
"open a quiz titled 'Chapter 3 Review'"
```

```
"give me a hint about 'Pythagorean theorem'"
```

```
"explain 'binary search' step by step"
```

### close_window
Closes an existing window by its ID.

**Parameters:**
- `windowId`: string - Unique identifier of the window to close

**Example:**
```
"close window window_123456"
```

## Event System

The AI system communicates with the UI through the event bus:

### Emitted Events
- `ai:text_command_processed` - When a text command is successfully processed
- `ai:error` - When an error occurs in AI processing
- `ui:open_window` - Instructs UI to open a window
- `ui:close_window` - Instructs UI to close a window
- `window:opened` - General window opened event
- `window:closed` - General window closed event

### Event Data Formats

**text_command_processed:**
```typescript
{
  id: string;
  success: boolean;
  originalText: string;
  tasks: Task[];
  executionResults: ExecutionResult[];
  processingTime: number;
  timestamp: number;
}
```

**ui:open_window:**
```typescript
{
  id: string;
  type: string;
  title: string;
  content: string;
  position: {x: number, y: number};
  size: {width: number, height: number};
  context: WindowContext;
  timestamp: number;
}
```

## Error Handling

The system includes comprehensive error handling:

1. **Cerebras API failures** - Falls back to rule-based parsing
2. **Invalid tool parameters** - Validates parameters before execution
3. **Network errors** - Graceful degradation with fallback parsing
4. **Worker errors** - Error propagation through event system

## Development

### Adding New Tools

1. Define the tool in `tools.ts`:
```typescript
{
  name: 'my_new_tool',
  description: 'Description of what the tool does',
  parameters: {
    type: 'object',
    properties: {
      param1: {
        type: 'string',
        description: 'Parameter description',
        required: true
      }
    },
    required: ['param1']
  }
}
```

2. Add execution logic in `toolExecutor.ts`:
```typescript
case 'my_new_tool':
  return await this.executeMyNewTool(task);
```

3. Update fallback parsing in `taskParser.ts` if needed

### Testing New Features

Use the comprehensive testing utilities:

```typescript
// Test individual commands
await aiTester.testCommand("your new command");

// Add to predefined tests in tester.ts
// Monitor events in real-time
aiTester.listenToEvents();
```

## Notes

- The AI system runs in a Web Worker to avoid blocking the main thread
- Cerebras API integration uses function calling for structured outputs
- Fallback parsing ensures the system works even without API access
- All components are modular and can be used independently
- Event-driven architecture allows for loose coupling with UI components
</file>

<file path="src/input/useSpeechTranscription.ts">
'use client';

import { useEffect, useState, useCallback, useRef } from 'react';
import { speechService } from './speechService';
import { eventBus } from '@/lib/eventBus';

export interface TranscriptData {
  final: string;
  interim: string;
  fullText: string;
  timestamp: number;
}

export interface WordData {
  word: string;
  confidence: number;
  timestamp: number;
}

export interface UseSpeechTranscriptionOptions {
  autoStart?: boolean;
  continuous?: boolean;
  onTranscript?: (data: TranscriptData) => void;
  onWord?: (data: WordData) => void;
  onError?: (error: string) => void;
}

export interface UseSpeechTranscriptionReturn {
  isListening: boolean;
  isSupported: boolean;
  accumulatedTranscript: string;
  interimTranscript: string;
  fullText: string;
  start: () => boolean;
  stop: () => void;
  toggle: () => void;
  clear: () => void;
}

export function useSpeechTranscription(
  options: UseSpeechTranscriptionOptions = {}
): UseSpeechTranscriptionReturn {
  const {
    autoStart = false,
    continuous = true,
    onTranscript,
    onWord,
    onError
  } = options;

  const [isListening, setIsListening] = useState(false);
  const [isSupported, setIsSupported] = useState(true);
  const [accumulatedTranscript, setAccumulatedTranscript] = useState('');
  const [interimTranscript, setInterimTranscript] = useState('');
  const [fullText, setFullText] = useState('');

  const isInitialized = useRef(false);
  const shouldRestart = useRef(continuous);

  // Initialize speech service
  useEffect(() => {
    if (isInitialized.current) return;

    const initialized = speechService.initialize();
    setIsSupported(initialized);
    isInitialized.current = true;

    if (initialized && autoStart) {
      speechService.start();
    }
  }, [autoStart]);

  // Set up event listeners
  useEffect(() => {
    const unsubscribers = [
      eventBus.on('speech:transcript', (data: TranscriptData) => {
        if (data.final && data.final.trim()) {
          setAccumulatedTranscript(prev => {
            const newText = prev ? prev + ' ' + data.final.trim() : data.final.trim();
            const trimmed = newText.length > 10000 ? newText.slice(-10000) : newText;
            setFullText(trimmed + (data.interim ? ' ' + data.interim : ''));
            return trimmed;
          });
        } else {
          setAccumulatedTranscript(prev => {
            setFullText(prev + (data.interim ? ' ' + data.interim : ''));
            return prev;
          });
        }
        setInterimTranscript(data.interim);

        onTranscript?.(data);
      }),

      eventBus.on('speech:word', (data: WordData) => {
        onWord?.(data);
      }),

      eventBus.on('speech:started', () => {
        setIsListening(true);
      }),

      eventBus.on('speech:ended', () => {
        setIsListening(false);

        // Auto-restart if continuous mode is enabled
        if (shouldRestart.current && continuous) {
          setTimeout(() => {
            speechService.start();
          }, 100);
        }
      }),

      eventBus.on('speech:error', (error: string) => {
        console.error('Speech recognition error:', error);

        // Don't change listening state for no-speech errors since we want continuous listening
        if (error !== 'no-speech') {
          onError?.(error);
        }

        // Handle fatal errors by stopping restart
        if (error === 'not-allowed' || error === 'service-not-allowed') {
          shouldRestart.current = false;
          setIsListening(false);
          return;
        }

        // Auto-restart on certain errors if continuous
        if (continuous && shouldRestart.current) {
          if (error === 'no-speech') {
            // Faster restart for silence, don't change UI state
            setTimeout(() => {
              speechService.start();
            }, 100);
          } else if (error === 'audio-capture' || error === 'network') {
            setTimeout(() => {
              speechService.start();
            }, 1000);
          }
        }
      }),

      eventBus.on('speech:unsupported', () => {
        setIsSupported(false);
      })
    ];

    return () => {
      unsubscribers.forEach(unsub => unsub());
    };
  }, [continuous, onTranscript, onWord, onError]);

  // Cleanup on unmount
  useEffect(() => {
    return () => {
      shouldRestart.current = false;
      speechService.stop();
    };
  }, []);

  const start = useCallback((): boolean => {
    if (!isSupported) return false;

    shouldRestart.current = true;
    return speechService.start();
  }, [isSupported]);

  const stop = useCallback((): void => {
    shouldRestart.current = false;
    speechService.stop();
    setInterimTranscript('');
  }, []);

  const clear = useCallback((): void => {
    setAccumulatedTranscript('');
    setInterimTranscript('');
    setFullText('');
  }, []);

  const toggle = useCallback((): void => {
    if (isListening) {
      stop();
    } else {
      start();
    }
  }, [isListening, start, stop]);

  return {
    isListening,
    isSupported,
    accumulatedTranscript,
    interimTranscript,
    fullText,
    start,
    stop,
    toggle,
    clear
  };
}
</file>

<file path="src/ui/components/aiWindow/AIWindow.tsx">
'use client';

import { aiManager } from '@/ai';

export function AIWindow() {
  const handleTestAI = () => {
    aiManager.generateResponse({ prompt: 'Test prompt from AI Window!' });
  };

  return (
    <div className="h-full flex flex-col">
      {/* Header */}
      <div className="flex items-center justify-between p-4 border-b border-gray-600/30 bg-gray-800/50">
        <div className="flex items-center space-x-3">
          <div className="w-10 h-10 bg-gradient-to-br from-emerald-400 to-green-500 rounded-lg flex items-center justify-center shadow-md">
            <span className="text-white text-lg">🤖</span>
          </div>
          <div>
            <h3 className="text-lg font-semibold text-gray-100">AI Manager</h3>
            <p className="text-xs text-gray-300">
              Generate intelligent responses using AI processing capabilities
            </p>
          </div>
        </div>
      </div>

      {/* Content Area */}
      <div className="flex-1 p-4 flex flex-col justify-center">
        <div className="text-center space-y-6">
          <div className="w-16 h-16 bg-gradient-to-br from-emerald-400 to-green-600 rounded-2xl mx-auto mb-4 flex items-center justify-center shadow-lg">
            <div className="w-8 h-8 bg-white rounded-lg opacity-90"></div>
          </div>
          
          <div className="bg-gradient-to-br from-gray-800/50 to-gray-700/50 rounded-2xl p-6 border border-gray-600/30">
            <button
              onClick={handleTestAI}
              className="w-full px-6 py-4 bg-gradient-to-r from-emerald-500 to-green-600 text-white rounded-xl hover:from-emerald-600 hover:to-green-700 transition-all duration-300 font-semibold shadow-lg hover:shadow-xl transform hover:scale-105"
            >
              🤖 Test AI Response
            </button>

            <div className="mt-4 text-center">
              <p className="text-sm text-gray-300">Check console for AI output</p>
            </div>
          </div>
        </div>
      </div>

      {/* Footer */}
      <div className="border-t border-gray-600/30 bg-gray-800/30 px-4 py-2 text-xs text-gray-400 flex justify-between">
        <span>AI System</span>
        <span>Cerebras</span>
      </div>
    </div>
  );
}
</file>

<file path="src/ui/components/barGraph/BarGraph.tsx">
'use client';

import { useMemo, useState } from 'react';
import { DataPoint, BarGraphProps, GraphBounds } from './barGraph.types';

export function BarGraph({
  data,
  width = 600,
  height = 400,
  title = 'Bar Graph',
  xAxisLabel = 'X Axis',
  yAxisLabel = 'Y Axis',
  barColor = '#3b82f6',
  barHoverColor = '#1d4ed8',
  gridColor = '#374151',
  backgroundColor = 'transparent',
  showGrid = true,
  showValues = true,
  barSpacing = 0.2,
  barBorderRadius = 4
}: BarGraphProps) {
  const [hoveredBar, setHoveredBar] = useState<DataPoint | null>(null);
  const [mousePosition, setMousePosition] = useState({ x: 0, y: 0 });

  const margin = { top: 60, right: 40, bottom: 80, left: 80 };
  const chartWidth = width - margin.left - margin.right;
  const chartHeight = height - margin.top - margin.bottom;

  const bounds = useMemo((): GraphBounds => {
    if (data.length === 0) return { minX: 0, maxX: 1, minY: 0, maxY: 1 };

    const yValues = data.map(d => d.y);
    const minY = Math.min(0, Math.min(...yValues)); // Include 0 for bars
    const maxY = Math.max(...yValues);

    return {
      minX: 0,
      maxX: data.length - 1,
      minY,
      maxY: maxY + (maxY - minY) * 0.1 // Add 10% padding at top
    };
  }, [data]);

  const barWidth = useMemo(() => {
    if (data.length === 0) return 0;
    const availableWidth = chartWidth * (1 - barSpacing);
    return availableWidth / data.length;
  }, [data.length, chartWidth, barSpacing]);

  const scaleX = (index: number) => {
    const spacing = chartWidth * barSpacing / (data.length + 1);
    return spacing + (index * (barWidth + spacing));
  };

  const scaleY = (y: number) => {
    const range = bounds.maxY - bounds.minY;
    if (range === 0) return chartHeight / 2;
    return chartHeight - ((y - bounds.minY) / range) * chartHeight;
  };

  const getBarHeight = (y: number) => {
    const baseY = scaleY(Math.max(0, bounds.minY));
    const topY = scaleY(y);
    return Math.abs(baseY - topY);
  };

  const getBarY = (y: number) => {
    if (y >= 0) return scaleY(y);
    return scaleY(0);
  };

  const gridLines = useMemo(() => {
    const lines = [];
    const numGridLines = 5;

    if (showGrid) {
      // Horizontal grid lines
      for (let i = 0; i <= numGridLines; i++) {
        const value = bounds.minY + ((bounds.maxY - bounds.minY) / numGridLines) * i;
        const y = scaleY(value);
        lines.push(
          <line
            key={`h-${i}`}
            x1={0}
            y1={y}
            x2={chartWidth}
            y2={y}
            stroke={gridColor}
            strokeWidth={1}
            opacity={0.5}
          />
        );
      }
    }

    return lines;
  }, [showGrid, chartWidth, chartHeight, gridColor, bounds]);

  const xAxisLabels = useMemo(() => {
    return data.map((point, index) => (
      <text
        key={`x-label-${index}`}
        x={scaleX(index) + barWidth / 2}
        y={chartHeight + 20}
        textAnchor="middle"
        className="text-xs fill-gray-300"
      >
        {point.label}
      </text>
    ));
  }, [data, barWidth, chartHeight]);

  const yAxisLabels = useMemo(() => {
    const labels = [];
    const numLabels = 5;

    for (let i = 0; i <= numLabels; i++) {
      const value = bounds.minY + ((bounds.maxY - bounds.minY) / numLabels) * i;
      const y = scaleY(value);

      labels.push(
        <text
          key={`y-label-${i}`}
          x={-10}
          y={y + 4}
          textAnchor="end"
          className="text-xs fill-gray-300"
        >
          {value.toFixed(1)}
        </text>
      );
    }

    return labels;
  }, [bounds, chartHeight]);

  const handleMouseMove = (event: React.MouseEvent<SVGSVGElement>) => {
    const rect = event.currentTarget.getBoundingClientRect();
    setMousePosition({
      x: event.clientX - rect.left,
      y: event.clientY - rect.top
    });
  };

  return (
    <div className="w-full h-full flex flex-col items-center justify-center p-4">
      <div className="relative">
        <svg
          width={width}
          height={height}
          className="border border-gray-600/30 rounded-lg"
          style={{ backgroundColor }}
          onMouseMove={handleMouseMove}
          onMouseLeave={() => setHoveredBar(null)}
        >
          {/* Chart area */}
          <g transform={`translate(${margin.left}, ${margin.top})`}>
            {/* Grid lines */}
            {gridLines}

            {/* Bars */}
            {data.map((point, index) => {
              const x = scaleX(index);
              const y = getBarY(point.y);
              const barHeight = getBarHeight(point.y);
              const isHovered = hoveredBar === point;

              return (
                <g key={index}>
                  <rect
                    x={x}
                    y={y}
                    width={barWidth}
                    height={barHeight}
                    fill={isHovered ? barHoverColor : barColor}
                    rx={barBorderRadius}
                    ry={barBorderRadius}
                    className="cursor-pointer transition-all duration-200"
                    onMouseEnter={() => setHoveredBar(point)}
                    onMouseLeave={() => setHoveredBar(null)}
                  />

                  {/* Value labels on bars */}
                  {showValues && (
                    <text
                      x={x + barWidth / 2}
                      y={point.y >= 0 ? y - 5 : y + barHeight + 15}
                      textAnchor="middle"
                      className="text-xs fill-gray-100 font-medium"
                    >
                      {point.y.toFixed(1)}
                    </text>
                  )}
                </g>
              );
            })}

            {/* Axis labels */}
            {xAxisLabels}
            {yAxisLabels}
          </g>

          {/* Axis titles */}
          <text
            x={width / 2}
            y={height - 20}
            textAnchor="middle"
            className="text-sm font-medium fill-cyan-200"
          >
            {xAxisLabel}
          </text>

          <text
            x={20}
            y={height / 2}
            textAnchor="middle"
            transform={`rotate(-90, 20, ${height / 2})`}
            className="text-sm font-medium fill-cyan-200"
          >
            {yAxisLabel}
          </text>
        </svg>

        {/* Tooltip */}
        {hoveredBar && (
          <div
            className="absolute bg-gray-800 text-white text-xs rounded px-2 py-1 pointer-events-none z-10"
            style={{
              left: mousePosition.x + 10,
              top: mousePosition.y - 30,
              transform: mousePosition.x > width - 100 ? 'translateX(-100%)' : 'none'
            }}
          >
            <div className="font-semibold">{hoveredBar.label}</div>
            <div>Value: {hoveredBar.y.toFixed(2)}</div>
          </div>
        )}
      </div>
    </div>
  );
}
</file>

<file path="src/ui/components/barGraphWindow/BarGraphWindow.tsx">
'use client';

import { useState } from 'react';
import { BarGraph, DataPoint } from '../barGraph';

export function BarGraphWindow() {
  const [data] = useState<DataPoint[]>([
    { label: 'Jan', x: 0, y: 45 },
    { label: 'Feb', x: 1, y: 52 },
    { label: 'Mar', x: 2, y: 38 },
    { label: 'Apr', x: 3, y: 61 },
    { label: 'May', x: 4, y: 55 },
    { label: 'Jun', x: 5, y: 67 },
    { label: 'Jul', x: 6, y: 43 },
    { label: 'Aug', x: 7, y: 58 },
    { label: 'Sep', x: 8, y: 72 },
    { label: 'Oct', x: 9, y: 65 },
    { label: 'Nov', x: 10, y: 78 },
    { label: 'Dec', x: 11, y: 85 }
  ]);

  const [title] = useState('Monthly Sales Data');

  return (
    <div className="h-full flex flex-col">
      {/* Header */}
      <div className="flex items-center justify-between p-4 border-b border-gray-600/30 bg-gray-800/50">
        <div className="flex items-center space-x-3">
          <div className="w-10 h-10 bg-gradient-to-br from-blue-400 to-indigo-500 rounded-lg flex items-center justify-center shadow-md">
            <span className="text-white text-lg">📊</span>
          </div>
          <div>
            <h3 className="text-lg font-semibold text-gray-100">Bar Graph</h3>
            <p className="text-xs text-gray-300">
              Monthly sales data visualization
            </p>
          </div>
        </div>
      </div>

      {/* Content Area */}
      <div className="flex-1 p-6">
        <BarGraph
          data={data}
          title={title}
          xAxisLabel="Month"
          yAxisLabel="Sales ($K)"
          width={600}
          height={450}
          barColor="#3b82f6"
          barHoverColor="#1d4ed8"
          showGrid={true}
          showValues={true}
        />
      </div>

      {/* Footer */}
      <div className="border-t border-gray-600/30 bg-gray-800/30 px-4 py-2 text-xs text-gray-400 flex justify-between">
        <span>Months: {data.length}</span>
        <span>Total: ${data.reduce((sum, item) => sum + item.y, 0)}K</span>
      </div>
    </div>
  );
}
</file>

<file path="src/ui/components/graphWindow/GraphWindow.tsx">
'use client';

import { useState } from 'react';
import { LineGraph, DataPoint } from '../lineGraph';

export function GraphWindow() {
  const [data] = useState<DataPoint[]>([
    { label: 'Start', x: 0, y: 10 },
    { label: 'Peak', x: 1, y: 25 },
    { label: 'Dip', x: 2, y: 15 },
    { label: 'Rise', x: 3, y: 30 },
    { label: 'Valley', x: 4, y: 8 },
    { label: 'High', x: 5, y: 35 },
    { label: 'End', x: 6, y: 20 }
  ]);

  const [title] = useState('Sample Data Points');

  return (
    <div className="h-full flex flex-col">
      {/* Header */}
      <div className="flex items-center justify-between p-4 border-b border-gray-600/30 bg-gray-800/50">
        <div className="flex items-center space-x-3">
          <div className="w-10 h-10 bg-gradient-to-br from-purple-400 to-violet-500 rounded-lg flex items-center justify-center shadow-md">
            <span className="text-white text-lg">📈</span>
          </div>
          <div>
            <h3 className="text-lg font-semibold text-gray-100">Line Graph</h3>
            <p className="text-xs text-gray-300">
              Interactive data visualization
            </p>
          </div>
        </div>
      </div>

      {/* Content Area */}
      <div className="flex-1 p-6">
        <LineGraph
          data={data}
          title={title}
          xAxisLabel="Time"
          yAxisLabel="Value"
          width={600}
          height={450}
          lineColor="#8b5cf6"
          pointColor="#7c3aed"
          showGrid={true}
          showPoints={true}
        />
      </div>

      {/* Footer */}
      <div className="border-t border-gray-600/30 bg-gray-800/30 px-4 py-2 text-xs text-gray-400 flex justify-between">
        <span>Data Points: {data.length}</span>
        <span>Interactive</span>
      </div>
    </div>
  );
}
</file>

<file path="src/ui/components/imageViewer/ImageViewer.tsx">
'use client';

import { useCallback } from 'react';
import { eventBus } from '@/lib/eventBus';

interface ImageViewerProps {
  imageUrl: string;
  imageName?: string;
  windowId?: string;
}

export function ImageViewer({ imageUrl, imageName, windowId }: ImageViewerProps) {
  const handleClose = useCallback(() => {
    if (windowId) {
      eventBus.emit('ui:close_window', { windowId });
    }
  }, [windowId]);


  return (
    <div className="h-full w-full relative">
      <img
        src={imageUrl}
        alt={imageName || 'Uploaded image'}
        className="w-full h-full object-fill"
        draggable={false}
      />
    </div>
  );
}
</file>

<file path="src/ui/components/inputWindow/InputWindow.tsx">
'use client';

import { inputManager } from '@/input';

export function InputWindow() {
  const handleTestInput = () => {
    inputManager.processInput({ test: 'Hello from Input Window!' });
  };

  return (
    <div className="h-full flex flex-col">
      {/* Header */}
      <div className="flex items-center justify-between p-4 border-b border-gray-600/30 bg-gray-800/50">
        <div className="flex items-center space-x-3">
          <div className="w-10 h-10 bg-gradient-to-br from-blue-400 to-indigo-500 rounded-lg flex items-center justify-center shadow-md">
            <span className="text-white text-lg">📥</span>
          </div>
          <div>
            <h3 className="text-lg font-semibold text-gray-100">Input Manager</h3>
            <p className="text-xs text-gray-300">
              Process and handle input data through the event bus system
            </p>
          </div>
        </div>
      </div>

      {/* Content Area */}
      <div className="flex-1 p-4 flex flex-col justify-center">
        <div className="text-center space-y-6">
          <div className="w-16 h-16 bg-gradient-to-br from-blue-400 to-indigo-600 rounded-2xl mx-auto mb-4 flex items-center justify-center shadow-lg">
            <div className="w-8 h-8 bg-white rounded-lg opacity-90"></div>
          </div>
          
          <div className="bg-gradient-to-br from-gray-800/50 to-gray-700/50 rounded-2xl p-6 border border-gray-600/30">
            <button
              onClick={handleTestInput}
              className="w-full px-6 py-4 bg-gradient-to-r from-blue-500 to-indigo-600 text-white rounded-xl hover:from-blue-600 hover:to-indigo-700 transition-all duration-300 font-semibold shadow-lg hover:shadow-xl transform hover:scale-105"
            >
              🚀 Test Input Processing
            </button>

            <div className="mt-4 text-center">
              <p className="text-sm text-gray-300">Check console for event output</p>
            </div>
          </div>
        </div>
      </div>

      {/* Footer */}
      <div className="border-t border-gray-600/30 bg-gray-800/30 px-4 py-2 text-xs text-gray-400 flex justify-between">
        <span>Input System</span>
        <span>Event Bus</span>
      </div>
    </div>
  );
}
</file>

<file path="src/ui/components/lineGraph/LineGraph.tsx">
'use client';

import { useMemo, useState } from 'react';
import { DataPoint, LineGraphProps, GraphBounds } from './lineGraph.types';

export function LineGraph({
  data,
  width = 600,
  height = 400,
  title = 'Line Graph',
  xAxisLabel = 'X Axis',
  yAxisLabel = 'Y Axis',
  lineColor = '#8b5cf6',
  pointColor = '#7c3aed',
  gridColor = '#374151',
  backgroundColor = 'transparent',
  showGrid = true,
  showPoints = true,
  lineThickness = 2,
  pointRadius = 4
}: LineGraphProps) {
  const [hoveredPoint, setHoveredPoint] = useState<DataPoint | null>(null);
  const [mousePosition, setMousePosition] = useState({ x: 0, y: 0 });

  const margin = { top: 60, right: 40, bottom: 80, left: 80 };
  const chartWidth = width - margin.left - margin.right;
  const chartHeight = height - margin.top - margin.bottom;

  const bounds = useMemo((): GraphBounds => {
    if (data.length === 0) return { minX: 0, maxX: 1, minY: 0, maxY: 1 };

    const xValues = data.map(d => d.x);
    const yValues = data.map(d => d.y);

    return {
      minX: Math.min(...xValues),
      maxX: Math.max(...xValues),
      minY: Math.min(...yValues),
      maxY: Math.max(...yValues)
    };
  }, [data]);

  const scaleX = (x: number) => {
    const range = bounds.maxX - bounds.minX;
    if (range === 0) return chartWidth / 2;
    return ((x - bounds.minX) / range) * chartWidth;
  };

  const scaleY = (y: number) => {
    const range = bounds.maxY - bounds.minY;
    if (range === 0) return chartHeight / 2;
    return chartHeight - ((y - bounds.minY) / range) * chartHeight;
  };

  const pathData = useMemo(() => {
    if (data.length === 0) return '';

    const points = data.map(d => `${scaleX(d.x)},${scaleY(d.y)}`).join(' L ');
    return `M ${points}`;
  }, [data, bounds, chartWidth, chartHeight]);

  const gridLines = useMemo(() => {
    const lines = [];
    const numGridLines = 5;

    if (showGrid) {
      // Vertical grid lines
      for (let i = 0; i <= numGridLines; i++) {
        const x = (chartWidth / numGridLines) * i;
        lines.push(
          <line
            key={`v-${i}`}
            x1={x}
            y1={0}
            x2={x}
            y2={chartHeight}
            stroke={gridColor}
            strokeWidth={1}
            opacity={0.5}
          />
        );
      }

      // Horizontal grid lines
      for (let i = 0; i <= numGridLines; i++) {
        const y = (chartHeight / numGridLines) * i;
        lines.push(
          <line
            key={`h-${i}`}
            x1={0}
            y1={y}
            x2={chartWidth}
            y2={y}
            stroke={gridColor}
            strokeWidth={1}
            opacity={0.5}
          />
        );
      }
    }

    return lines;
  }, [showGrid, chartWidth, chartHeight, gridColor]);

  const xAxisLabels = useMemo(() => {
    const labels = [];
    const numLabels = 5;

    for (let i = 0; i <= numLabels; i++) {
      const value = bounds.minX + ((bounds.maxX - bounds.minX) / numLabels) * i;
      const x = (chartWidth / numLabels) * i;

      labels.push(
        <text
          key={`x-label-${i}`}
          x={x}
          y={chartHeight + 20}
          textAnchor="middle"
          className="text-xs fill-gray-300"
        >
          {value.toFixed(1)}
        </text>
      );
    }

    return labels;
  }, [bounds, chartWidth, chartHeight]);

  const yAxisLabels = useMemo(() => {
    const labels = [];
    const numLabels = 5;

    for (let i = 0; i <= numLabels; i++) {
      const value = bounds.minY + ((bounds.maxY - bounds.minY) / numLabels) * i;
      const y = chartHeight - (chartHeight / numLabels) * i;

      labels.push(
        <text
          key={`y-label-${i}`}
          x={-10}
          y={y + 4}
          textAnchor="end"
          className="text-xs fill-gray-300"
        >
          {value.toFixed(1)}
        </text>
      );
    }

    return labels;
  }, [bounds, chartHeight]);

  const handleMouseMove = (event: React.MouseEvent<SVGSVGElement>) => {
    const rect = event.currentTarget.getBoundingClientRect();
    setMousePosition({
      x: event.clientX - rect.left,
      y: event.clientY - rect.top
    });
  };

  return (
    <div className="w-full h-full flex flex-col items-center justify-center p-4">
      <div className="relative">
        <svg
          width={width}
          height={height}
          className="border border-gray-600/30 rounded-lg"
          style={{ backgroundColor }}
          onMouseMove={handleMouseMove}
          onMouseLeave={() => setHoveredPoint(null)}
        >
          {/* Chart area */}
          <g transform={`translate(${margin.left}, ${margin.top})`}>
            {/* Grid lines */}
            {gridLines}

            {/* Main line */}
            {data.length > 1 && (
              <path
                d={pathData}
                fill="none"
                stroke={lineColor}
                strokeWidth={lineThickness}
                strokeLinecap="round"
                strokeLinejoin="round"
              />
            )}

            {/* Data points */}
            {showPoints && data.map((point, index) => (
              <circle
                key={index}
                cx={scaleX(point.x)}
                cy={scaleY(point.y)}
                r={pointRadius}
                fill={pointColor}
                stroke="#1f2937"
                strokeWidth={2}
                className="cursor-pointer hover:r-6 transition-all"
                onMouseEnter={() => setHoveredPoint(point)}
                onMouseLeave={() => setHoveredPoint(null)}
              />
            ))}

            {/* Axis labels */}
            {xAxisLabels}
            {yAxisLabels}
          </g>

          {/* Axis titles */}
          <text
            x={width / 2}
            y={height - 20}
            textAnchor="middle"
            className="text-sm font-medium fill-cyan-200"
          >
            {xAxisLabel}
          </text>

          <text
            x={20}
            y={height / 2}
            textAnchor="middle"
            transform={`rotate(-90, 20, ${height / 2})`}
            className="text-sm font-medium fill-cyan-200"
          >
            {yAxisLabel}
          </text>
        </svg>

        {/* Tooltip */}
        {hoveredPoint && (
          <div
            className="absolute bg-gray-800 text-white text-xs rounded px-2 py-1 pointer-events-none z-10"
            style={{
              left: mousePosition.x + 10,
              top: mousePosition.y - 30,
              transform: mousePosition.x > width - 100 ? 'translateX(-100%)' : 'none'
            }}
          >
            <div className="font-semibold">{hoveredPoint.label}</div>
            <div>X: {hoveredPoint.x.toFixed(2)}</div>
            <div>Y: {hoveredPoint.y.toFixed(2)}</div>
          </div>
        )}
      </div>
    </div>
  );
}
</file>

<file path="src/ui/components/pieChart/PieChart.tsx">
'use client';

import { useMemo, useState } from 'react';
import { DataPoint, PieChartProps, PieSlice } from './pieChart.types';

export function PieChart({
  data,
  width = 500,
  height = 400,
  title = 'Pie Chart',
  radius = 120,
  innerRadius = 0,
  colors = [
    '#3b82f6', '#ef4444', '#10b981', '#f59e0b', '#8b5cf6',
    '#06b6d4', '#84cc16', '#f97316', '#ec4899', '#6366f1'
  ],
  showLabels = true,
  showPercentages = true,
  showLegend = true,
  animationDuration = 300
}: PieChartProps) {
  const [hoveredSlice, setHoveredSlice] = useState<PieSlice | null>(null);
  const [mousePosition, setMousePosition] = useState({ x: 0, y: 0 });

  const centerX = width / 2;
  const centerY = height / 2 - 10; // Slightly offset for title

  const pieSlices = useMemo((): PieSlice[] => {
    const total = data.reduce((sum, item) => sum + Math.abs(item.y), 0);
    if (total === 0) return [];

    let currentAngle = -Math.PI / 2; // Start at top

    return data.map((item, index) => {
      const value = Math.abs(item.y);
      const percentage = (value / total) * 100;
      const sliceAngle = (value / total) * 2 * Math.PI;

      const slice: PieSlice = {
        label: item.label,
        value,
        percentage,
        startAngle: currentAngle,
        endAngle: currentAngle + sliceAngle,
        color: colors[index % colors.length]
      };

      currentAngle += sliceAngle;
      return slice;
    });
  }, [data, colors]);

  const createArcPath = (slice: PieSlice, outerRadius: number, innerRadius: number = 0) => {
    const { startAngle, endAngle } = slice;

    const x1 = centerX + Math.cos(startAngle) * outerRadius;
    const y1 = centerY + Math.sin(startAngle) * outerRadius;
    const x2 = centerX + Math.cos(endAngle) * outerRadius;
    const y2 = centerY + Math.sin(endAngle) * outerRadius;

    const largeArcFlag = endAngle - startAngle <= Math.PI ? 0 : 1;

    if (innerRadius === 0) {
      // Regular pie slice
      return `M ${centerX},${centerY} L ${x1},${y1} A ${outerRadius},${outerRadius} 0 ${largeArcFlag},1 ${x2},${y2} Z`;
    } else {
      // Donut slice
      const x3 = centerX + Math.cos(startAngle) * innerRadius;
      const y3 = centerY + Math.sin(startAngle) * innerRadius;
      const x4 = centerX + Math.cos(endAngle) * innerRadius;
      const y4 = centerY + Math.sin(endAngle) * innerRadius;

      return `M ${x1},${y1} A ${outerRadius},${outerRadius} 0 ${largeArcFlag},1 ${x2},${y2} L ${x4},${y4} A ${innerRadius},${innerRadius} 0 ${largeArcFlag},0 ${x3},${y3} Z`;
    }
  };

  const getLabelPosition = (slice: PieSlice) => {
    const midAngle = (slice.startAngle + slice.endAngle) / 2;
    const labelRadius = radius * 0.7;

    return {
      x: centerX + Math.cos(midAngle) * labelRadius,
      y: centerY + Math.sin(midAngle) * labelRadius
    };
  };

  const handleMouseMove = (event: React.MouseEvent<SVGSVGElement>) => {
    const rect = event.currentTarget.getBoundingClientRect();
    setMousePosition({
      x: event.clientX - rect.left,
      y: event.clientY - rect.top
    });
  };

  return (
    <div className="w-full h-full flex flex-col items-center justify-center p-4">
      <h3 className="text-xl font-semibold text-cyan-200 mb-4">{title}</h3>

      <div className="flex items-start justify-center space-x-12">
        {/* Pie Chart */}
        <div className="relative flex-shrink-0">
          <svg
            width={width * 0.7}
            height={height}
            className="overflow-visible"
            onMouseMove={handleMouseMove}
            onMouseLeave={() => setHoveredSlice(null)}
          >
            {/* Pie slices */}
            {pieSlices.map((slice, index) => {
              const isHovered = hoveredSlice === slice;
              const sliceRadius = isHovered ? radius + 5 : radius;

              return (
                <g key={index}>
                  <path
                    d={createArcPath(slice, sliceRadius, innerRadius)}
                    fill={slice.color}
                    stroke="#ffffff"
                    strokeWidth={2}
                    className="cursor-pointer transition-all duration-200"
                    style={{
                      filter: isHovered ? 'brightness(1.1)' : 'none'
                    }}
                    onMouseEnter={() => setHoveredSlice(slice)}
                    onMouseLeave={() => setHoveredSlice(null)}
                  />

                  {/* Labels */}
                  {showLabels && slice.percentage > 5 && (
                    <text
                      x={getLabelPosition(slice).x}
                      y={getLabelPosition(slice).y}
                      textAnchor="middle"
                      dominantBaseline="middle"
                      className="text-xs font-medium fill-white"
                      style={{ pointerEvents: 'none' }}
                    >
                      {showPercentages ? `${slice.percentage.toFixed(1)}%` : slice.label}
                    </text>
                  )}
                </g>
              );
            })}

            {/* Center text for donut charts */}
            {innerRadius > 0 && (
              <text
                x={centerX}
                y={centerY}
                textAnchor="middle"
                dominantBaseline="middle"
                className="text-lg font-semibold fill-cyan-200"
              >
                Total
              </text>
            )}
          </svg>

          {/* Tooltip */}
          {hoveredSlice && (
            <div
              className="absolute bg-gray-800 text-white text-xs rounded px-2 py-1 pointer-events-none z-10"
              style={{
                left: mousePosition.x + 10,
                top: mousePosition.y - 30,
                transform: mousePosition.x > width * 0.35 ? 'translateX(-100%)' : 'none'
              }}
            >
              <div className="font-semibold">{hoveredSlice.label}</div>
              <div>Value: {hoveredSlice.value.toFixed(2)}</div>
              <div>Percentage: {hoveredSlice.percentage.toFixed(1)}%</div>
            </div>
          )}
        </div>

        {/* Legend */}
        {showLegend && (
          <div className="flex flex-col space-y-2">
            <h4 className="text-sm font-semibold text-cyan-200 mb-2">Legend</h4>
            {pieSlices.map((slice, index) => (
              <div
                key={index}
                className="flex items-center space-x-2 cursor-pointer hover:bg-gray-700/50 rounded px-2 py-1 transition-colors"
                onMouseEnter={() => setHoveredSlice(slice)}
                onMouseLeave={() => setHoveredSlice(null)}
              >
                <div
                  className="w-3 h-3 rounded-sm"
                  style={{ backgroundColor: slice.color }}
                />
                <div className="text-sm">
                  <div className="font-medium text-gray-100">{slice.label}</div>
                  <div className="text-xs text-gray-300">
                    {slice.value.toFixed(1)} ({slice.percentage.toFixed(1)}%)
                  </div>
                </div>
              </div>
            ))}
          </div>
        )}
      </div>
    </div>
  );
}
</file>

<file path="src/ui/components/systemOutput/SystemOutput.tsx">
'use client';

import { useState, useEffect, useRef } from 'react';
import { eventBus } from '@/lib/eventBus';
import { SystemOutputState, SystemOutputProps } from './systemOutput.types';

export function SystemOutput({
  placeholder = 'System messages will appear here...'
}: SystemOutputProps) {
  const [notes, setNotes] = useState<SystemOutputState>({
    content: '',
    lastModified: new Date()
  });
  const textareaRef = useRef<HTMLTextAreaElement>(null);

  useEffect(() => {
    const unsubscribers = [
      eventBus.on('input:input_processed', (data) => {
        addToNotes(`Input processed: ${JSON.stringify(data)}\n`);
      }),
      eventBus.on('ai:ai_response_generated', (data) => {
        addToNotes(`AI response: ${JSON.stringify(data)}\n`);
      }),
      eventBus.on('input:initialized', () => {
        addToNotes('Input manager initialized successfully\n');
      }),
      eventBus.on('ai:initialized', () => {
        addToNotes('AI manager initialized successfully\n');
      }),
      eventBus.on('ui:log', (data: { message: string }) => {
        addToNotes(`${data.message}\n`);
      }),
      eventBus.on('system:output', (data: { text: string }) => {
        addToNotes(data.text);
      })
    ];

    return () => {
      unsubscribers.forEach(unsub => unsub());
    };
  }, []);

  const addToNotes = (text: string) => {
    setNotes(prev => ({
      content: prev.content + text,
      lastModified: new Date()
    }));
  };

  const clearNotes = () => {
    setNotes({
      content: '',
      lastModified: new Date()
    });
  };

  return (
    <div className="h-full flex flex-col">
      {/* Header - ultra minimal */}
      <div className="flex items-center justify-between px-2 py-1 border-b border-gray-600/30 bg-gray-800/50">
        <div className="flex items-center space-x-1">
          <div className="w-4 h-4 bg-gradient-to-br from-green-400 to-emerald-500 rounded flex items-center justify-center">
            <span className="text-white text-xs">🖥️</span>
          </div>
          <h3 className="text-xs font-semibold text-gray-100">System</h3>
        </div>
      </div>

      {/* Notes Area - absolute maximum space */}
      <div className="flex-1 px-1 py-1">
        <textarea
          ref={textareaRef}
          value={notes.content}
          readOnly
          placeholder={placeholder}
          className="w-full h-full resize-none border-none outline-none bg-transparent text-cyan-200 leading-relaxed text-sm cursor-default placeholder-cyan-400/60"
          style={{
            fontFamily: 'system-ui, -apple-system, sans-serif',
            lineHeight: '1.6'
          }}
        />
      </div>

      {/* Footer - absolute minimal */}
      <div className="border-t border-gray-600/30 bg-gray-800/30 px-2 py-0.5 text-xs text-gray-400 flex justify-between">
        <span>{notes.content.split(/\s+/).filter(word => word.length > 0).length}w</span>
        <span>{notes.content.length}c</span>
      </div>
    </div>
  );
}
</file>

<file path="src/ui/components/userNotes/UserNotes.tsx">
'use client';

import { useState, useRef, useEffect } from 'react';
import { UserNotesState, UserNotesProps } from './userNotes.types';
import { eventBus } from '@/lib/eventBus';

export function UserNotes({
  placeholder = 'Start typing your personal notes here...',
  windowId
}: UserNotesProps) {
  const [notes, setNotes] = useState<UserNotesState>({
    content: '',
    lastModified: new Date()
  });
  const textareaRef = useRef<HTMLTextAreaElement>(null);

  const handleContentChange = (e: React.ChangeEvent<HTMLTextAreaElement>) => {
    const newContent = e.target.value;
    setNotes({
      content: newContent,
      lastModified: new Date()
    });

    // Emit content change for similarity analysis
    if (windowId) {
      eventBus.emit('window:content_changed', {
        windowId,
        content: newContent,
        title: 'New Note'
      });
    }
  };

  // Initial content setup
  useEffect(() => {
    if (windowId && notes.content) {
      eventBus.emit('window:content_changed', {
        windowId,
        content: notes.content,
        title: 'New Note'
      });
    }
  }, [windowId, notes.content]);

  const clearNotes = () => {
    setNotes({
      content: '',
      lastModified: new Date()
    });
  };

  return (
    <div className="h-full flex flex-col">
      {/* Header - ultra minimal */}
      <div className="flex items-center justify-between px-2 py-1 border-b border-gray-600/30 bg-gray-800/50">
        <div className="flex items-center space-x-1">
          <div className="w-4 h-4 bg-gradient-to-br from-blue-400 to-indigo-500 rounded flex items-center justify-center">
            <span className="text-white text-xs">✏️</span>
          </div>
          <h3 className="text-xs font-semibold text-gray-100">Notes</h3>
        </div>
        <button
          onClick={clearNotes}
          className="px-1 py-0.5 text-xs bg-gray-700 hover:bg-gray-600 text-gray-200 rounded"
        >
          Clear
        </button>
      </div>

      {/* Notes Area - absolute maximum space */}
      <div className="flex-1 px-1 py-1">
        <textarea
          ref={textareaRef}
          value={notes.content}
          onChange={handleContentChange}
          placeholder={placeholder}
          className="w-full h-full resize-none border-none outline-none bg-transparent text-cyan-200 leading-relaxed text-sm placeholder-cyan-400/60"
          style={{
            fontFamily: 'system-ui, -apple-system, sans-serif',
            lineHeight: '1.6'
          }}
        />
      </div>

      {/* Footer - absolute minimal */}
      <div className="border-t border-gray-600/30 bg-gray-800/30 px-2 py-0.5 text-xs text-gray-400 flex justify-between">
        <span>{notes.content.split(/\s+/).filter(word => word.length > 0).length}w</span>
        <span>{notes.content.length}c</span>
      </div>
    </div>
  );
}
</file>

<file path="src/ui/components/userNotes/userNotes.types.ts">
export interface UserNotesState {
  content: string;
  lastModified: Date;
}

export interface UserNotesProps {
  placeholder?: string;
  windowId?: string;
}
</file>

<file path=".gitignore">
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.*
.yarn/*
!.yarn/patches
!.yarn/plugins
!.yarn/releases
!.yarn/versions

# testing
/coverage

# next.js
/.next/
/out/

# production
/build

# misc
.DS_Store
*.pem

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*
.pnpm-debug.log*

# env files (can opt-in for committing if needed)
.env*

# vercel
.vercel

# typescript
*.tsbuildinfo
next-env.d.ts

# CLAUDE.md
CLAUDE.md
</file>

<file path="src/ai/tools.ts">
import { Tool } from './types';

export const AVAILABLE_TOOLS: Tool[] = [
  {
    name: 'open_window',
    description: 'Opens a new popup window with specified type and context. Use this for creating, opening, showing, or displaying a window. Education types supported: lesson, quiz, hint, explainer.',
    parameters: {
      type: 'object',
      properties: {
        windowType: {
          type: 'string',
          description: 'The type of window to open (e.g., notification, dialog, settings, sticky-note, general, lesson, quiz, hint, explainer)'
        },
        context: {
          type: 'object',
          description: 'Context information for the window',
          properties: {
            title: {
              type: 'string',
              description: 'Window title to display'
            },
            content: {
              type: 'string',
              description: 'Primary text/content of the window'
            },
            type: {
              type: 'string',
              description: 'Repeat of window type for UI context (notification, dialog, settings, sticky-note, general, lesson, quiz, hint, explainer)'
            },
            position: {
              type: 'object',
              description: 'Optional x/y position of the window',
              properties: {
                x: { type: 'number', description: 'X coordinate in pixels' },
                y: { type: 'number', description: 'Y coordinate in pixels' }
              }
            },
            size: {
              type: 'object',
              description: 'Optional width/height of the window',
              properties: {
                width: { type: 'number', description: 'Window width in pixels' },
                height: { type: 'number', description: 'Window height in pixels' }
              }
            },
            metadata: {
              type: 'object',
              description: 'Optional metadata for education windows (e.g., lessonId, step, quizQuestions)',
              properties: {}
            }
          }
        }
      },
      required: ['windowType', 'context']
    }
  },
  {
    name: 'close_window',
    description: 'Closes an existing window by its ID. Use this when the user wants to close, dismiss, or hide a specific window.',
    parameters: {
      type: 'object',
      properties: {
        windowId: {
          type: 'string',
          description: 'The unique identifier of the window to close'
        },
        selector: {
          type: 'string',
          description: 'Semantic selector when ID is unknown (newest/latest/oldest/active/all)'
        }
      },
      required: []
    }
  }
];

export function getToolByName(name: string): Tool | undefined {
  return AVAILABLE_TOOLS.find(tool => tool.name === name);
}

export function getAllToolNames(): string[] {
  return AVAILABLE_TOOLS.map(tool => tool.name);
}
</file>

<file path="src/input/index.ts">
export { InputManager, inputManager } from './InputManager';
export { SpeechTranscriptionService, speechService } from './speechService';
export { useSpeechTranscription } from './useSpeechTranscription';
export { SpeechTranscriptionProvider, useSpeechTranscriptionContext, SpeechIndicator } from './SpeechTranscriptionProvider';
export type { SpeechRecognition, SpeechRecognitionEvent } from './speechService';
export type { TranscriptData, WordData, UseSpeechTranscriptionOptions, UseSpeechTranscriptionReturn } from './useSpeechTranscription';
export { VoiceTaskListener } from './VoiceTaskListener';
</file>

<file path="src/input/speechService.ts">
/* eslint-disable @typescript-eslint/no-explicit-any */
import { eventBus } from '@/lib/eventBus';

export interface SpeechRecognitionEvent extends Event {
  results: SpeechRecognitionResultList;
  resultIndex: number;
}

interface SpeechRecognitionErrorEvent extends Event {
  error: string;
}

export interface SpeechRecognition extends EventTarget {
  continuous: boolean;
  interimResults: boolean;
  lang: string;
  start(): void;
  stop(): void;
  abort(): void;
  onstart: ((this: SpeechRecognition, ev: Event) => any) | null;
  onend: ((this: SpeechRecognition, ev: Event) => any) | null;
  onresult: ((this: SpeechRecognition, ev: SpeechRecognitionEvent) => any) | null;
  onerror: ((this: SpeechRecognition, ev: SpeechRecognitionErrorEvent) => any) | null;
}

declare global {
  interface Window {
    SpeechRecognition: new () => SpeechRecognition;
    webkitSpeechRecognition: new () => SpeechRecognition;
  }
}

export class SpeechTranscriptionService {
  private recognition: SpeechRecognition | null = null;
  private isListening = false;
  private isSupported = false;
  private isInitialized = false;
  private lastFinalCumulative = '';

  constructor() {
    // Don't check support in constructor - do it during initialization
  }

  private checkSupport(): void {
    if (typeof window === 'undefined') {
      this.isSupported = false;
      return;
    }

    this.isSupported = 'SpeechRecognition' in window || 'webkitSpeechRecognition' in window;

    if (!this.isSupported) {
      console.warn('Speech recognition not supported in this browser');
      eventBus.emit('speech:unsupported');
    }
  }

  initialize(): boolean {
    if (this.isInitialized) {
      return this.isSupported;
    }

    this.checkSupport();
    this.isInitialized = true;

    if (!this.isSupported) {
      return false;
    }

    try {
      const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
      this.recognition = new SpeechRecognition();

      this.recognition.continuous = true;
      this.recognition.interimResults = true;
      this.recognition.lang = 'en-US';

      // Maximize sensitivity and responsiveness
      if ('maxAlternatives' in this.recognition) {
        (this.recognition as any).maxAlternatives = 1;
      }
      if ('serviceURI' in this.recognition) {
        // Some browsers support additional config
      }

      this.setupEventHandlers();

      eventBus.emit('speech:initialized');
      return true;
    } catch (error) {
      console.error('Failed to initialize speech recognition:', error);
      eventBus.emit('speech:error', error);
      return false;
    }
  }

  private setupEventHandlers(): void {
    if (!this.recognition) return;

    this.recognition.onstart = () => {
      this.isListening = true;
      // Reset cumulative tracker at the start of each session
      this.lastFinalCumulative = '';
      eventBus.emit('speech:started');
    };

    this.recognition.onend = () => {
      // Mark as not listening; restart is coordinated by the hook
      this.isListening = false;
      eventBus.emit('speech:ended');
    };

    this.recognition.onresult = (event: SpeechRecognitionEvent) => {
      let fullTranscript = '';
      let lastInterim = '';

      // Get all results for continuous stream
      for (let i = 0; i < event.results.length; i++) {
        const transcript = event.results[i][0].transcript;

        if (event.results[i].isFinal) {
          fullTranscript += transcript;
        } else {
          lastInterim = transcript;
        }
      }

      // Compute delta of newly finalized portion relative to previous cumulative
      let finalDelta = '';
      if (fullTranscript.startsWith(this.lastFinalCumulative)) {
        finalDelta = fullTranscript.slice(this.lastFinalCumulative.length);
      } else {
        // Fallback: find common prefix length and take the suffix as delta
        const commonLength = this.getCommonPrefixLength(this.lastFinalCumulative, fullTranscript);
        finalDelta = fullTranscript.slice(commonLength);
      }

      // Update cumulative tracker
      this.lastFinalCumulative = fullTranscript;

      // Always emit the most recent interim result for continuous stream
      const currentText = (fullTranscript + lastInterim).trim();

      eventBus.emit('speech:transcript', {
        final: finalDelta,
        interim: lastInterim,
        fullText: currentText,
        timestamp: Date.now()
      });

      // Also emit individual words as they're detected
      if (lastInterim) {
        const words = lastInterim.trim().split(/\s+/);
        const lastWord = words[words.length - 1];
        if (lastWord && lastWord.length > 0) {
          eventBus.emit('speech:word', {
            word: lastWord,
            confidence: event.results[event.results.length - 1][0].confidence || 1,
            timestamp: Date.now()
          });
        }
      }
    };

    this.recognition.onerror = (event: SpeechRecognitionErrorEvent) => {
      console.error('Speech recognition error:', event.error);

      // Don't emit error for no-speech since we want continuous listening through silence
      if (event.error !== 'no-speech') {
        eventBus.emit('speech:error', event.error);
      }

      // Handle fatal errors by stopping completely
      if (event.error === 'not-allowed' || event.error === 'service-not-allowed') {
        this.isListening = false;
        return;
      }
    };
  }

  start(): boolean {
    if (!this.recognition || this.isListening) {
      return false;
    }

    try {
      this.recognition.start();
      return true;
    } catch (error) {
      console.error('Failed to start speech recognition:', error);
      eventBus.emit('speech:error', error);
      return false;
    }
  }

  stop(): void {
    if (!this.recognition || !this.isListening) {
      return;
    }

    this.isListening = false;
    this.recognition.stop();
  }

  abort(): void {
    if (!this.recognition) {
      return;
    }

    this.isListening = false;
    this.recognition.abort();
  }

  getIsListening(): boolean {
    return this.isListening;
  }

  getIsSupported(): boolean {
    if (!this.isInitialized && typeof window !== 'undefined') {
      this.checkSupport();
      this.isInitialized = true;
    }
    return this.isSupported;
  }

  private getCommonPrefixLength(a: string, b: string): number {
    const minLen = Math.min(a.length, b.length);
    let i = 0;
    while (i < minLen && a.charCodeAt(i) === b.charCodeAt(i)) {
      i++;
    }
    return i;
  }
}

export const speechService = new SpeechTranscriptionService();
</file>

<file path="src/ui/components/background/AnimatedBackground.tsx">
'use client';

import { useEffect, useRef } from 'react';

interface Particle {
  x: number;
  y: number;
  vx: number;
  vy: number;
  size: number;
  opacity: number;
}

export function AnimatedBackground() {
  const canvasRef = useRef<HTMLCanvasElement>(null);
  const particlesRef = useRef<Particle[]>([]);
  const animationRef = useRef<number | undefined>(undefined);

  useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;

    const ctx = canvas.getContext('2d');
    if (!ctx) return;

    const resizeCanvas = () => {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    };

    const createParticles = () => {
      const particles: Particle[] = [];
      const particleCount = Math.floor((canvas.width * canvas.height) / 20000);

      for (let i = 0; i < particleCount; i++) {
        particles.push({
          x: Math.random() * canvas.width,
          y: Math.random() * canvas.height,
          vx: (Math.random() - 0.5) * 0.5,
          vy: (Math.random() - 0.5) * 0.5,
          size: Math.random() * 2 + 1,
          opacity: Math.random() * 0.5 + 0.1
        });
      }

      particlesRef.current = particles;
    };

    const animate = () => {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      const particles = particlesRef.current;

      particles.forEach((particle, i) => {
        // Update position
        particle.x += particle.vx;
        particle.y += particle.vy;

        // Bounce off edges
        if (particle.x < 0 || particle.x > canvas.width) particle.vx *= -1;
        if (particle.y < 0 || particle.y > canvas.height) particle.vy *= -1;

        // Keep particles in bounds
        particle.x = Math.max(0, Math.min(canvas.width, particle.x));
        particle.y = Math.max(0, Math.min(canvas.height, particle.y));

        // Draw particle
        ctx.beginPath();
        ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
        ctx.fillStyle = `rgba(255, 255, 255, ${particle.opacity})`;
        ctx.fill();

        // Draw connections
        particles.forEach((otherParticle, j) => {
          if (i === j) return;

          const dx = particle.x - otherParticle.x;
          const dy = particle.y - otherParticle.y;
          const distance = Math.sqrt(dx * dx + dy * dy);

          if (distance < 100) {
            ctx.beginPath();
            ctx.moveTo(particle.x, particle.y);
            ctx.lineTo(otherParticle.x, otherParticle.y);
            ctx.strokeStyle = `rgba(255, 255, 255, ${0.1 * (1 - distance / 100)})`;
            ctx.lineWidth = 1;
            ctx.stroke();
          }
        });
      });

      animationRef.current = requestAnimationFrame(animate);
    };

    resizeCanvas();
    createParticles();
    animate();

    const handleResize = () => {
      resizeCanvas();
      createParticles();
    };

    window.addEventListener('resize', handleResize);

    return () => {
      if (animationRef.current) {
        cancelAnimationFrame(animationRef.current);
      }
      window.removeEventListener('resize', handleResize);
    };
  }, []);

  return (
    <canvas
      ref={canvasRef}
      className="absolute inset-0 pointer-events-none"
      style={{ zIndex: 1 }}
    />
  );
}
</file>

<file path="README.md">
# Jarvis
</file>

<file path="src/ai/index.ts">
export { AIManager, aiManager } from './AIManager';
export { TaskParser } from './taskParser';
export { ToolExecutor, toolExecutor } from './toolExecutor';
export { CerebrasClient } from './cerebrasClient';
export { AITester, aiTester } from './tester';
export { AVAILABLE_TOOLS, getToolByName, getAllToolNames } from './tools';
export type { 
  Tool, 
  CerebrasTool,
  Task, 
  WindowContext, 
  OpenWindowParams, 
  CloseWindowParams,
  CerebrasRequest,
  CerebrasResponse,
  AIProcessingResult
} from './types';
</file>

<file path="src/ai/tester.ts">
/* eslint-disable @typescript-eslint/no-explicit-any */
/**
 * AI System Tester
 * 
 * This is a basic testing utility for the Jarvis AI system.
 * It allows you to test text commands and see how they get parsed into tasks
 * and executed by the tool system.
 * 
 * Usage:
 * - Import this file and call runTests() to run predefined tests
 * - Use testCommand(text) to test individual commands
 * - Use listenToEvents() to see real-time AI processing events
 */

import { TaskParser } from './taskParser';
import { ToolExecutor } from './toolExecutor';
import { eventBus } from '@/lib/eventBus';

export class AITester {
  private taskParser: TaskParser;
  private toolExecutor: ToolExecutor;
  private eventListeners: (() => void)[] = [];
  private requestQueue: Promise<void> = Promise.resolve();

  constructor() {
    this.taskParser = new TaskParser();
    this.toolExecutor = new ToolExecutor();
  }

  /**
   * Test a single text command
   */
  async testCommand(text: string): Promise<void> {
    this.requestQueue = this.requestQueue.then(async () => {
      console.log(`\n🧪 Testing command: "${text}"`);
      console.log('─'.repeat(50));

      try {
        // Parse the command (may use Cerebras; fallback handles offline/rate limits)
        console.log('📝 Parsing command...');
        const parseResult = await this.taskParser.parseTextToTasks({ transcript: text, actionHistory: [], uiContext: {} });

        // New parser always returns { new_tool_calls }

        console.log(`✅ Parsed ${parseResult.new_tool_calls.length} tool call(s):`);
        parseResult.new_tool_calls.forEach((call, index) => {
          console.log(`   ${index + 1}. ${call.tool}`);
          console.log(`      Parameters:`, call.parameters);
          console.log(`      Source:`, call.sourceText);
        });

        // Execute the tasks
        console.log('\n⚡ Executing tasks...');
        const executionResults = await this.toolExecutor.executeTasks(parseResult.new_tool_calls.map((c, i) => ({ id: `test_${i}`, tool: c.tool, parameters: c.parameters, description: c.tool })));

        executionResults.forEach((result, index) => {
          if (result.success) {
            console.log(`   ✅ Task ${index + 1} executed successfully`);
            if (result.result) {
              console.log(`      Result:`, result.result);
            }
          } else {
            console.log(`   ❌ Task ${index + 1} failed:`, result.error);
          }
        });

        console.log('─'.repeat(50));
        console.log('✨ Test completed\n');

      } catch (error) {
        console.error('💥 Test failed with error:', error);
      }
    });

    return this.requestQueue;
  }

  /**
   * Run a suite of predefined tests
   */
  async runTests(): Promise<void> {
    console.log('🚀 Starting AI System Tests');
    console.log('═'.repeat(60));

    const testCommands = [
      // Simple window operations
      'open a window',
      'create a sticky note',
      'close window window_123',
      
      // Complex commands
      'open a sticky note that says "Remember to buy groceries"',
      'create a notification window titled "Meeting Alert"',
      'open a settings dialog and close window abc123',
      
      // Edge cases
      'show me a "Project Ideas" sticky note',
      'close all windows', // Should close all open windows
      '', // Empty command
      
      // Natural language variations
      'I need a reminder note about the dentist appointment',
      'please open a window for the user settings',
      'dismiss window xyz789',

      // Education-focused commands
      'start lesson "Derivatives" step 1',
      'open a quiz titled "Chapter 3 Review"',
      'give me a hint about "Pythagorean theorem"',
      'explain "binary search" step by step'
    ];

    for (const command of testCommands) {
      await this.testCommand(command);
      // Small delay between tests for readability
      await new Promise(resolve => setTimeout(resolve, 500));
    }

    console.log('🎉 All tests completed!');
  }

  /**
   * Listen to AI events in real-time
   */
  listenToEvents(): void {
    console.log('👂 Listening to AI events...');
    
    // Clear existing listeners
    this.clearEventListeners();

    const unsubscribers = [
      eventBus.on('ai:text_command_processed', (data: any) => {
        console.log('🤖 Text command processed:', data);
      }),
      
      eventBus.on('ai:error', (error: any) => {
        console.error('🚨 AI Error:', error);
      }),
      
      eventBus.on('ui:open_window', (data: any) => {
        console.log('🪟 Window opened:', data);
      }),
      
      eventBus.on('ui:close_window', (data: any) => {
        console.log('🔲 Window closed:', data);
      }),
      
      eventBus.on('window:opened', (data: any) => {
        console.log('📊 Window event - opened:', data);
      }),
      
      eventBus.on('window:closed', (data: any) => {
        console.log('📊 Window event - closed:', data);
      })
    ];

    this.eventListeners = unsubscribers;
  }

  /**
   * Stop listening to events
   */
  clearEventListeners(): void {
    this.eventListeners.forEach(unsubscribe => unsubscribe());
    this.eventListeners = [];
  }

  /**
   * Test the Cerebras integration specifically
   */
  async testCerebrasIntegration(): Promise<void> {
    console.log('🧠 Testing Cerebras Integration');
    console.log('─'.repeat(40));

    try {
      const testText = 'open a sticky note saying "test cerebras"';
      console.log(`Testing with: "${testText}"`);
      
      const result = await this.taskParser.parseTextToTasks({ transcript: testText, actionHistory: [], uiContext: {} });
      
      if (Array.isArray(result.new_tool_calls)) {
        console.log('✅ Cerebras integration working');
        console.log('Calls created:', result.new_tool_calls.length);
      } else {
        console.log('⚠️ Cerebras integration failed, using fallback parsing');
        console.log('No calls created');
      }
    } catch (error) {
      console.error('❌ Cerebras test failed:', error);
    }
  }

  /**
   * Quick test for model verification
   */
  async testModelOnly(): Promise<void> {
    console.log('🔍 Testing Model Access');
    console.log('─'.repeat(30));
    
    try {
      const simpleText = 'hello';
      await this.taskParser.parseTextToTasks({ transcript: simpleText, actionHistory: [], uiContext: {} });
      console.log('✅ Model accessible.');
    } catch (error) {
      console.error('❌ Model test failed:', error);
    }
  }

  /**
   * Interactive testing - call this to test commands manually
   */
  async interactive(): Promise<void> {
    console.log('🎮 Interactive AI Testing Mode');
    console.log('Use aiTester.testCommand("your command") to test commands');
    console.log('Use aiTester.runTests() to run all predefined tests');
    console.log('Use aiTester.listenToEvents() to monitor events');
    
    // Start listening to events by default
    this.listenToEvents();
  }
}

// Create a global instance for easy testing
export const aiTester = new AITester();

// Auto-start interactive mode when this file is imported
if (typeof window !== 'undefined') {
  (window as any).aiTester = aiTester;
  // Expose the event bus for console-based inspection and custom listeners
  (window as any).eventBus = eventBus;
  console.log('🧪 AI Tester loaded! Use window.aiTester in browser console');
  console.log('🔌 EventBus exposed as window.eventBus');
}
</file>

<file path="src/ai/types.ts">
type JSONSchema = {
  type: string;
  description?: string;
  properties?: Record<string, JSONSchema>;
  items?: JSONSchema;
  enum?: Array<string | number | boolean>;
  required?: string[];
};

export interface Tool {
  name: string;
  description: string;
  parameters: JSONSchema & { type: 'object'; properties: Record<string, JSONSchema>; required: string[] };
}

export interface CerebrasTool {
  type: 'function';
  function: {
    name: string;
    description: string;
    parameters: JSONSchema & { type: 'object'; properties: Record<string, JSONSchema>; required: string[] };
  };
}

export interface Task {
  id: string;
  tool: string;
  parameters: Record<string, unknown>;
  description: string;
}

export interface WindowContext {
  title?: string;
  content?: string;
  type?: 'notification' | 'dialog' | 'settings' | 'sticky-note' | 'general' | 'lesson' | 'quiz' | 'hint' | 'explainer';
  position?: { x: number; y: number };
  size?: { width: number; height: number };
  metadata?: Record<string, unknown>;
}

export interface OpenWindowParams {
  windowType: string;
  context: WindowContext;
}

export interface CloseWindowParams {
  windowId?: string; // direct id when known
  selector?: 'newest' | 'latest' | 'oldest' | 'active' | 'all'; // semantic selector
}

export interface CerebrasRequest {
  model: string;
  messages: Array<{
    role: 'system' | 'user' | 'assistant';
    content: string;
  }>;
  temperature?: number;
  max_tokens?: number;
  tools?: CerebrasTool[];
  tool_choice?: string;
  response_format?: { type: 'text' | 'json_object' | 'json_schema'; json_schema?: unknown };
}

export interface CerebrasResponse {
  id: string;
  object: string;
  created: number;
  model: string;
  choices: Array<{
    index: number;
    message: {
      role: string;
      content: string;
      tool_calls?: Array<{
        id: string;
        type: 'function';
        function: {
          name: string;
          arguments: string;
        };
      }>;
    };
    finish_reason: string;
  }>;
  usage: {
    prompt_tokens: number;
    completion_tokens: number;
    total_tokens: number;
  };
}

export interface AIProcessingResult {
  success: boolean;
  tasks: Task[];
  rawResponse?: CerebrasResponse;
  error?: string;
  timestamp: number;
}
</file>

<file path="src/app/globals.css">
@import "tailwindcss";

:root {
  --background: #0a0a0a;
  --foreground: #ededed;
}

body {
  background: var(--background);
  color: var(--foreground);
  font-family: Arial, Helvetica, sans-serif;
}

/* Window Animation Keyframes */
@keyframes window-open {
  0% {
    opacity: 0;
    transform: scale(0.01);
  }
  100% {
    opacity: 1;
    transform: scale(1);
  }
}

@keyframes window-close {
  from {
    opacity: 1;
    transform: translate3d(var(--window-x, 0px), var(--window-y, 0px), 0) scale(1);
  }
  to {
    opacity: 0;
    transform: translate3d(var(--window-x, 0px), var(--window-y, 0px), 0) scale(0.9);
  }
}

@keyframes window-minimize {
  from {
    opacity: 1;
    transform: scale(1) translateY(0);
  }
  to {
    opacity: 0;
    transform: scale(0.1) translateY(100px);
  }
}

@keyframes window-restore {
  from {
    opacity: 0;
    transform: scale(0.1) translateY(100px);
  }
  to {
    opacity: 1;
    transform: scale(1) translateY(0);
  }
}

/* Animation Classes */
.animate-window-open {
  animation: window-open 0.08s ease-out forwards;
}

.animate-window-close {
  animation: window-close 0.25s ease-in forwards;
}

.animate-window-minimize {
  animation: window-minimize 0.3s ease-in forwards;
}

.animate-window-restore {
  animation: window-restore 0.3s ease-out forwards;
}

/* Smooth transitions for window movement and resizing */
.window-transition {
  transition: left 0.2s ease-out, top 0.2s ease-out, width 0.2s ease-out, height 0.2s ease-out, transform 0.3s ease-out;
}

/* Neon glow effects for window controls */
.neon-glow-purple {
  box-shadow: 0 0 8px rgba(168, 85, 247, 0.4), inset 0 1px 0 rgba(255, 255, 255, 0.2);
}

.neon-glow-purple:hover {
  box-shadow: 0 0 12px rgba(168, 85, 247, 0.6), inset 0 1px 0 rgba(255, 255, 255, 0.3);
}

.neon-glow-cyan {
  box-shadow: 0 0 8px rgba(34, 211, 238, 0.4), inset 0 1px 0 rgba(255, 255, 255, 0.2);
}

.neon-glow-cyan:hover {
  box-shadow: 0 0 12px rgba(34, 211, 238, 0.6), inset 0 1px 0 rgba(255, 255, 255, 0.3);
}

.neon-glow-lime {
  box-shadow: 0 0 8px rgba(163, 230, 53, 0.4), inset 0 1px 0 rgba(255, 255, 255, 0.2);
}

.neon-glow-lime:hover {
  box-shadow: 0 0 12px rgba(163, 230, 53, 0.6), inset 0 1px 0 rgba(255, 255, 255, 0.3);
}
</file>

<file path="src/ui/components/imageDropZone/ImageDropZone.tsx">
'use client';

import { useState, useRef } from 'react';

interface ImageDropZoneProps {
  onImageUpload: (imageUrl: string, imageName: string) => void;
  onMultipleImageUpload?: (images: { url: string; name: string }[]) => void;
}

export function ImageDropZone({ onImageUpload, onMultipleImageUpload }: ImageDropZoneProps) {
  const [isDragOver, setIsDragOver] = useState(false);
  const [isUploading, setIsUploading] = useState(false);
  const fileInputRef = useRef<HTMLInputElement>(null);

  const handleDragOver = (e: React.DragEvent) => {
    e.preventDefault();
    setIsDragOver(true);
  };

  const handleDragLeave = (e: React.DragEvent) => {
    e.preventDefault();
    setIsDragOver(false);
  };

  const handleDrop = (e: React.DragEvent) => {
    e.preventDefault();
    setIsDragOver(false);
    
    const files = Array.from(e.dataTransfer.files);
    const imageFiles = files.filter(file => file.type.startsWith('image/'));
    
    if (imageFiles.length > 0) {
      if (imageFiles.length === 1) {
        handleImageFile(imageFiles[0]);
      } else {
        handleMultipleImageFiles(imageFiles);
      }
    }
  };

  const handleFileSelect = (e: React.ChangeEvent<HTMLInputElement>) => {
    const files = Array.from(e.target.files || []);
    const imageFiles = files.filter(file => file.type.startsWith('image/'));
    
    if (imageFiles.length > 0) {
      if (imageFiles.length === 1) {
        handleImageFile(imageFiles[0]);
      } else {
        handleMultipleImageFiles(imageFiles);
      }
    }
  };

  const handleImageFile = (file: File) => {
    setIsUploading(true);
    
    const reader = new FileReader();
    reader.onload = (event) => {
      const imageUrl = event.target?.result as string;
      onImageUpload(imageUrl, file.name);
      setIsUploading(false);
    };
    reader.onerror = () => {
      setIsUploading(false);
    };
    reader.readAsDataURL(file);
  };

  const handleMultipleImageFiles = (files: File[]) => {
    setIsUploading(true);
    
    const imagePromises = files.map(file => {
      return new Promise<{ url: string; name: string }>((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = (event) => {
          const imageUrl = event.target?.result as string;
          resolve({ url: imageUrl, name: file.name });
        };
        reader.onerror = () => reject(new Error(`Failed to read ${file.name}`));
        reader.readAsDataURL(file);
      });
    });

    Promise.all(imagePromises)
      .then(images => {
        if (onMultipleImageUpload) {
          onMultipleImageUpload(images);
        } else {
          // Fallback to single image upload for each image
          images.forEach(image => onImageUpload(image.url, image.name));
        }
        setIsUploading(false);
      })
      .catch(error => {
        console.error('Error processing multiple images:', error);
        setIsUploading(false);
      });
  };

  const handleClick = () => {
    fileInputRef.current?.click();
  };

  return (
    <div
      className={`
        relative w-24 h-24 border-2 border-dashed rounded-xl transition-all duration-300 cursor-pointer
        flex items-center justify-center
        ${isDragOver 
          ? 'border-blue-400 bg-blue-500/20 scale-105' 
          : 'border-white/30 hover:border-white/50 hover:bg-white/5'
        }
        ${isUploading ? 'opacity-50 pointer-events-none' : ''}
      `}
      onDragOver={handleDragOver}
      onDragLeave={handleDragLeave}
      onDrop={handleDrop}
      onClick={handleClick}
    >
      <input
        ref={fileInputRef}
        type="file"
        accept="image/*"
        multiple
        onChange={handleFileSelect}
        className="hidden"
      />
      
      <div className="absolute inset-0 flex flex-col items-center justify-center p-2">
        {isUploading ? (
          <div className="w-8 h-8 border-4 border-white/30 border-t-white rounded-full animate-spin"></div>
        ) : (
          <div className="flex flex-col items-center space-y-1">
            <svg 
              className="w-8 h-8 text-white/70" 
              fill="none" 
              stroke="currentColor" 
              viewBox="0 0 24 24"
            >
              <path 
                strokeLinecap="round" 
                strokeLinejoin="round" 
                strokeWidth={1.5} 
                d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z" 
              />
            </svg>
            <span className="text-xs text-white/60 font-medium">Drop here</span>
          </div>
        )}
      </div>
    </div>
  );
}
</file>

<file path="src/ai/taskParser.ts">
/* eslint-disable @typescript-eslint/no-explicit-any */
import { CerebrasClient } from './cerebrasClient';
import { AVAILABLE_TOOLS } from './tools';
import { Task } from './types';

export class TaskParser {
  private cerebrasClient: CerebrasClient;

  constructor(apiKey?: string) {
    this.cerebrasClient = new CerebrasClient(apiKey);
  }

  async parseTextToTasks(input: { transcript: string; actionHistory: Array<{ tool: string; parameters: any; sourceText: string }>; uiContext: any }): Promise<{ new_tool_calls: Array<{ tool: string; parameters: any; sourceText: string }> }> {
    const fullTranscript = (input?.transcript || '').toString();
    const uiContext = input?.uiContext || {};
    const actionHistory = Array.isArray(input?.actionHistory) ? input.actionHistory : [];

    console.log('[TaskParser] parseTextToTasks (stateful) called', {
      transcriptPreview: fullTranscript.slice(-120),
      uiWindows: Array.isArray(uiContext?.windows) ? uiContext.windows.length : 0,
      actionCount: actionHistory.length
    });

    const systemPrompt = [
      'You are Jarvis, an AI assistant. Your primary function is to analyze an ongoing speech transcript and identify any NEW user commands that have not yet been executed.',
      '',
      'You will receive a JSON input with the user\'s full transcript, your recent action history, and the current UI state.',
      '',
      'Your task is to:',
      '1. Carefully read the entire `fullTranscript`.',
      '2. Compare the user\'s commands in the transcript against the `actionHistory`.',
      '3. Identify any explicit commands in the transcript that do NOT have a corresponding entry in the `actionHistory`.',
      '4. If you find new, complete commands, respond with a JSON object containing a `new_tool_calls` array.',
      '5. Each tool call in the array MUST include a `sourceText` property, containing the exact phrase from the transcript that justifies the action.',
      '6. If there are no new commands, or if a command is incomplete (e.g., "open a graph showing..."), respond with an empty `new_tool_calls` array.',
      '7. DO NOT re-issue tool calls for commands that are already present in the `actionHistory`.'
    ].join('\n');

    const jsonPayload = {
      fullTranscript: fullTranscript,
      actionHistory: actionHistory,
      uiContext: uiContext,
      availableTools: AVAILABLE_TOOLS
    } as any;

    const response = await this.cerebrasClient.createChatCompletion({
      model: 'qwen-3-235b-a22b-instruct-2507',
      messages: [
        { role: 'system', content: systemPrompt },
        { role: 'user', content: JSON.stringify(jsonPayload) }
      ],
      response_format: { type: 'json_object' },
      max_tokens: 800,
      temperature: 0.1
    });

    const content: unknown = response?.choices?.[0]?.message?.content;

    const coerce = (input: unknown): { new_tool_calls: Array<{ tool: string; parameters: any; sourceText: string }> } => {
      const empty = { new_tool_calls: [] as Array<{ tool: string; parameters: any; sourceText: string }> };
      try {
        const obj = typeof input === 'string' ? JSON.parse(input) : input;
        if (!obj || typeof obj !== 'object' || Array.isArray(obj)) return empty;
        const calls = Array.isArray((obj as any).new_tool_calls) ? (obj as any).new_tool_calls : [];
        const cleaned = calls.map((c: any) => ({
          tool: String(c?.tool || c?.name || ''),
          parameters: (typeof c?.parameters === 'object' && c?.parameters) ? c.parameters : (typeof c?.args === 'object' ? c.args : {}),
          sourceText: String(c?.sourceText || c?.source_text || '')
        })).filter((c: any) => c.tool && typeof c.parameters === 'object');
        return { new_tool_calls: cleaned };
      } catch {
        return empty;
      }
    };

    return coerce(content);
  }

  private generateTaskDescription(toolName: string, parameters: any): string {
    switch (toolName) {
      case 'open_window':
        return `Open ${parameters.windowType || 'window'}: ${parameters.context?.title || 'Untitled'}`;
      case 'close_window':
        return `Close window: ${parameters.windowId}`;
      default:
        return `Execute ${toolName}`;
    }
  }

  private generateTaskId(): string {
    return `task_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }

  private capitalizeFirst(str: string): string {
    return str.charAt(0).toUpperCase() + str.slice(1);
  }
}
</file>

<file path="src/app/api/cerebras-tasks/route.ts">
import { NextRequest } from 'next/server';

export async function POST(request: NextRequest) {
  try {
    console.log('[API] /api/cerebras-tasks POST hit');
    const body = await request.json().catch(() => ({}));
    const { cerebrasRequest } = body;

    if (!process.env.CEREBRAS_API_KEY) {
      return new Response(JSON.stringify({ error: 'Missing CEREBRAS_API_KEY' }), { status: 500 });
    }

    if (!cerebrasRequest) {
      return new Response(JSON.stringify({ error: 'Missing cerebrasRequest in body' }), { status: 400 });
    }

    const response = await fetch('https://api.cerebras.ai/v1/chat/completions', {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${process.env.CEREBRAS_API_KEY}`,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify(cerebrasRequest)
    });

    if (!response.ok) {
      const text = await response.text();
      return new Response(JSON.stringify({ error: `Upstream error ${response.status}`, detail: text }), { status: 502 });
    }

    const data = await response.json();
    console.log('[API] /api/cerebras-tasks success');
    return Response.json(data);
  } catch (error) {
    console.error('[API] /api/cerebras-tasks error', error);
    return new Response(JSON.stringify({ error: (error instanceof Error ? error.message : String(error)) }), { status: 500 });
  }
}
</file>

<file path="src/ui/components/debugSidebar/DebugSidebar.tsx">
'use client';

import { useState, useEffect } from 'react';
import { eventBus } from '@/lib/eventBus';
import type { Task } from '@/ai/types';

type OpenSidebar = 'ui' | 'input' | 'ai' | null;

interface DebugSidebarProps {
  inputStatus: 'idle' | 'listening' | 'processing' | 'error';
  aiStatus: 'idle' | 'processing' | 'ready' | 'error';
  openInputWindow: () => void;
  openAIWindow: () => void;
  openUserNotesWindow: () => void;
  openSystemOutputWindow: () => void;
  openGraphWindow: () => void;
  openBarGraphWindow: () => void;
  openPieChartWindow: () => void;
  openPreloadedImageWindow: () => void;
}

export function DebugSidebar({
  inputStatus,
  aiStatus,
  openInputWindow,
  openAIWindow,
  openUserNotesWindow,
  openSystemOutputWindow,
  openGraphWindow,
  openBarGraphWindow,
  openPieChartWindow,
  openPreloadedImageWindow
}: DebugSidebarProps) {
  const [openSidebar, setOpenSidebar] = useState<OpenSidebar>(null);
  const [taskQueue, setTaskQueue] = useState<Task[]>([]);
  const [currentTask, setCurrentTask] = useState<Task | null>(null);
  const [recentToolCalls, setRecentToolCalls] = useState<Array<{ task: Task; tool: string; params?: unknown; status: string; timestamp: number; result?: unknown }>>([]);
  const [inputBuffer, setInputBuffer] = useState<string>('');
  type SubmittedEntry = { kind: 'submitted'; id: string; text: string; source: string; timestamp: number };
  type RunEntry = { kind: 'run'; id: string; tool: string; description: string; timestamp: number; status: 'started' | 'completed' | 'failed'; result?: unknown; error?: unknown };
  type ActionLogEntry = SubmittedEntry | RunEntry;
  const [aiActionLog, setAiActionLog] = useState<ActionLogEntry[]>([]);

  useEffect(() => {
    const listeners = [
      // Input
      eventBus.on('input:voice_debug', (d: { bufferText?: string }) => {
        if (d && typeof d.bufferText === 'string') {
          setInputBuffer(d.bufferText);
        }
      }),
      eventBus.on('input:transcript_updated', (data: { transcript?: string }) => {
        try {
          const transcript = String(data?.transcript || '').trim();
          if (!transcript) return;
          const entry: SubmittedEntry = { kind: 'submitted', id: Math.random().toString(36).slice(2), text: transcript, source: 'transcript', timestamp: Date.now() };
          setAiActionLog(prev => [entry, ...prev].slice(0, 30));
        } catch {}
      }),

      // AI tasks lifecycle
      eventBus.on('ai:task_queue_updated', (tasks: Task[]) => setTaskQueue(tasks)),
      eventBus.on('ai:task_started', ({ task }: { task: Task }) => {
        setCurrentTask(task);
        setTaskQueue(prev => prev.filter(t => t.id !== task.id));
        const entry: RunEntry = { kind: 'run', id: task.id, tool: task.tool, description: task.description, timestamp: Date.now(), status: 'started' };
        setAiActionLog(prev => [entry, ...prev].slice(0, 30));
      }),
      eventBus.on('ai:task_completed', ({ task, result }: { task: Task; result: unknown }) => {
        setCurrentTask(null);
        setAiActionLog(prev => prev.map(e => (e.kind === 'run' && e.id === task?.id) ? { ...e, status: 'completed', result } as RunEntry : e));
      }),
      eventBus.on('ai:task_failed', ({ task, error }: { task: Task; error: unknown }) => {
        setCurrentTask(null);
        setAiActionLog(prev => prev.map(e => (e.kind === 'run' && e.id === task?.id) ? { ...e, status: 'failed', error } as RunEntry : e));
      }),
      eventBus.on('ai:tool_call_started', (data: { task: Task; tool: string; params?: unknown }) => {
        setRecentToolCalls(prev => [{ ...data, status: 'started', timestamp: Date.now() }, ...prev].slice(0, 5));
      }),
      eventBus.on('ai:tool_call_completed', (data: { task: Task; tool: string; result?: unknown }) => {
        setRecentToolCalls(prev => 
          prev.map(call => call.task.id === data.task.id ? { ...call, status: 'completed', result: data.result } : call)
        );
      }),
    ];

    return () => {
      listeners.forEach(off => off());
    };
  }, []);

  const toggleSidebar = (sidebar: OpenSidebar) => {
    setOpenSidebar(openSidebar === sidebar ? null : sidebar);
  };

  return (
    <div className="fixed right-0 top-0 h-full bg-gray-800/80 backdrop-blur-sm text-white p-4 w-80 z-20 overflow-y-auto">
      <div className="flex flex-col space-y-2">
        <button onClick={() => toggleSidebar('ui')} className="bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded">
          UI
        </button>
        <button onClick={() => toggleSidebar('input')} className="bg-green-500 hover:bg-green-700 text-white font-bold py-2 px-4 rounded">
          Input
        </button>
        <button onClick={() => toggleSidebar('ai')} className="bg-purple-500 hover:bg-purple-700 text-white font-bold py-2 px-4 rounded">
          AI
        </button>
      </div>

      {openSidebar && <div className="mt-4 border-t border-gray-600 pt-4" />}

      {openSidebar === 'ui' && (
        <div>
          <h2 className="text-lg font-bold mb-2">UI Debug</h2>
          <div className="space-y-2">
            <button onClick={openInputWindow} className="w-full bg-gray-700 hover:bg-gray-600 text-white font-bold py-2 px-4 rounded">Open Input Window</button>
            <button onClick={openAIWindow} className="w-full bg-gray-700 hover:bg-gray-600 text-white font-bold py-2 px-4 rounded">Open AI Window</button>
            <button onClick={openUserNotesWindow} className="w-full bg-gray-700 hover:bg-gray-600 text-white font-bold py-2 px-4 rounded">Open Personal Notes</button>
            <button onClick={openSystemOutputWindow} className="w-full bg-gray-700 hover:bg-gray-600 text-white font-bold py-2 px-4 rounded">Open System Output</button>
            <button onClick={openGraphWindow} className="w-full bg-gray-700 hover:bg-gray-600 text-white font-bold py-2 px-4 rounded">Open Line Graph</button>
            <button onClick={openBarGraphWindow} className="w-full bg-gray-700 hover:bg-gray-600 text-white font-bold py-2 px-4 rounded">Open Bar Graph</button>
            <button onClick={openPieChartWindow} className="w-full bg-gray-700 hover:bg-gray-600 text-white font-bold py-2 px-4 rounded">Open Pie Chart</button>
            <button onClick={openPreloadedImageWindow} className="w-full bg-gray-700 hover:bg-gray-600 text-white font-bold py-2 px-4 rounded">Open Sample Image</button>
          </div>
        </div>
      )}

      {openSidebar === 'input' && (
        <div>
          <h2 className="text-lg font-bold">Input State</h2>
          <div className="mt-2 space-y-2 text-sm">
            <div className="flex justify-between"><span>Status:</span> <span className={`px-2 py-0.5 rounded ${inputStatus === 'listening' ? 'bg-red-500' : inputStatus === 'processing' ? 'bg-yellow-500' : inputStatus === 'error' ? 'bg-rose-600' : 'bg-gray-500'}`}>{inputStatus}</span></div>
          </div>

          <div className="mt-4">
            <h3 className="font-bold">Text Buffer</h3>
            <div className="mt-1 text-xs bg-gray-700/50 p-2 rounded max-h-40 overflow-auto whitespace-pre-wrap break-words">
              {inputBuffer ? inputBuffer : <span className="text-gray-400">Empty</span>}
            </div>
          </div>
        </div>
      )}

      {openSidebar === 'ai' && (
        <div>
          <h2 className="text-lg font-bold">AI State</h2>
          <div className="mt-2 space-y-2 text-sm">
            <div className="flex justify-between"><span>Status:</span> <span className={`px-2 py-0.5 rounded ${aiStatus === 'processing' ? 'bg-yellow-500' : aiStatus === 'error' ? 'bg-rose-600' : 'bg-emerald-600'}`}>{aiStatus}</span></div>
          </div>

          <div className="mt-4">
            <h3 className="font-bold">Task Queue ({taskQueue.length})</h3>
            <ul className="mt-1 space-y-1 text-xs bg-gray-700/50 p-2 rounded">
              {taskQueue.map(task => (
                <li key={task.id} className="truncate">{task.tool}: {task.description}</li>
              ))}
              {taskQueue.length === 0 && <li className="text-gray-400">Empty</li>}
            </ul>
          </div>

          <div className="mt-4">
            <h3 className="font-bold">Current Task</h3>
            <div className="mt-1 text-xs bg-gray-700/50 p-2 rounded">
              {currentTask ? (
                <div>
                  <p><strong>ID:</strong> {currentTask.id}</p>
                  <p><strong>Tool:</strong> {currentTask.tool}</p>
                  <p><strong>Desc:</strong> {currentTask.description}</p>
                </div>
              ) : (
                <p className="text-gray-400">None</p>
              )}
            </div>
          </div>

          <div className="mt-4">
            <h3 className="font-bold">Recent Tool Calls</h3>
            <ul className="mt-1 space-y-2 text-xs">
              {recentToolCalls.map((call, i) => (
                <li key={i} className="bg-gray-700/50 p-2 rounded">
                  <p><strong>Tool:</strong> {call.tool} ({call.status})</p>
                  <p className="truncate"><strong>Params:</strong> {JSON.stringify(call.params)}</p>
                  {call.status === 'completed' && <p className="truncate"><strong>Result:</strong> {JSON.stringify(call.result)}</p>}
                </li>
              ))}
              {recentToolCalls.length === 0 && <li className="text-gray-400">None</li>}
            </ul>
          </div>

          <div className="mt-4">
            <h3 className="font-bold">Action Log</h3>
            <ul className="mt-1 space-y-2 text-xs">
              {aiActionLog.map((entry, i) => (
                <li key={i} className="bg-gray-700/50 p-2 rounded">
                  {entry.kind === 'submitted' ? (
                    <div>
                      <p><strong>Submitted</strong> <span className="text-gray-300">({entry.source})</span></p>
                      <p className="truncate">{entry.text}</p>
                    </div>
                  ) : (
                    <div>
                      <p><strong>Run</strong>: {entry.tool} <span className="text-gray-300">({entry.status})</span></p>
                      <p className="truncate">{entry.description}</p>
                      {entry.status === 'completed' && !!entry.result && (
                        <p className="truncate"><strong>Result:</strong> {JSON.stringify(entry.result)}</p>
                      )}
                      {entry.status === 'failed' && !!entry.error && (
                        <p className="truncate text-rose-300"><strong>Error:</strong> {String(entry.error)}</p>
                      )}
                    </div>
                  )}
                </li>
              ))}
              {aiActionLog.length === 0 && <li className="text-gray-400">No actions yet</li>}
            </ul>
          </div>
        </div>
      )}
    </div>
  );
}
</file>

<file path="src/ui/components/window/window.types.ts">
export interface WindowProps {
  id: string;
  title: string;
  children: React.ReactNode;
  initialX?: number;
  initialY?: number;
  width?: number;
  height?: number;
  minWidth?: number;
  minHeight?: number;
  maxWidth?: number;
  maxHeight?: number;
  onClose?: () => void;
  isActive?: boolean;
  isMinimized: boolean;
  isFullscreen?: boolean;
  zIndex?: number;
  onFocus?: () => void;
  onMinimize: () => void;
  onRestore: () => void;
  onFullscreen?: () => void;
  onPositionChange?: (id: string, x: number, y: number) => void;
  onResize?: (width: number, height: number) => void;
  // New props to unify ImageWindow and support animations
  lockAspectRatio?: boolean;
  headerStyle?: 'standard' | 'minimal';
  resizable?: boolean;
  animationState?: 'opening' | 'closing' | 'none';
}

export interface WindowState {
  x: number;
  y: number;
  width: number;
  height: number;
  isMinimized: boolean;
  zIndex: number;
}
</file>

<file path="src/input/VoiceTaskListener.tsx">
'use client';

import { useCallback, useEffect, useMemo, useRef, useState } from 'react';
import { eventBus } from '@/lib/eventBus';
import { useSpeechTranscription } from './useSpeechTranscription';
// Cerebras calls removed; this component now only buffers transcript and emits updates

type Status = 'idle' | 'listening' | 'processing' | 'error';

interface CerebrasResult {
  tasks?: string[];
  remainder?: string;
}

export function VoiceTaskListener() {
  const [buffer, setBuffer] = useState('');
  const [status, setStatus] = useState<Status>('idle');
  const [lastError, setLastError] = useState('');
  const [isOnline, setIsOnline] = useState(
    typeof navigator !== 'undefined' ? navigator.onLine : true
  );

  const bufferRef = useRef(buffer);
  const processingRef = useRef(false);
  const scheduledTimeoutRef = useRef<number | null>(null);
  const scheduledForRef = useRef<number | null>(null);
  const callStartBufferLengthRef = useRef(0);
  const lastBufferAppendAtRef = useRef<number>(0);
  
  const latestFullTextRef = useRef<string>('');
  const streamTimerRef = useRef<number | null>(null);
  const lastStreamCallAtRef = useRef<number>(0);
  const lastStreamProcessedTextRef = useRef<string>('');

  // No AI calls here; VoiceTaskListener is now a pure input buffer

  const MIN_DEBOUNCE_MS = 0; // retained for potential future use
  const STREAM_INTERVAL_MS = 2000; // periodic checks during continuous speech
  const STILL_SPEAKING_WINDOW_MS = 1500; // treat activity within this as still speaking
  const SILENCE_CONFIRM_MS = 1000; // wait after last final segment to coalesce phrases
  const ENABLE_STREAMING = false; // disable streaming task emission to avoid partial-command actions


  useEffect(() => { bufferRef.current = buffer; }, [buffer]);

  const { isListening, isSupported } = useSpeechTranscription({
    autoStart: true,
    continuous: true,
    onTranscript: (data) => {
      if (data?.fullText) {
        latestFullTextRef.current = data.fullText.trim();
      }
      if (data.final && data.final.trim()) {
        // Compute and set new buffer synchronously to ensure attemptProcessing sees it
        const newBuffer = (bufferRef.current ? bufferRef.current + ' ' : '') + data.final.trim();
        bufferRef.current = newBuffer;
        setBuffer(newBuffer);
        lastBufferAppendAtRef.current = Date.now();
        // Coalesce multiple final segments by waiting briefly for silence
        scheduleTimer(SILENCE_CONFIRM_MS);
      } else if (data.interim && data.interim.trim()) {
        // Update activity timestamp to indicate user is still speaking
        lastBufferAppendAtRef.current = Date.now();
        // Periodic streaming calls while speaking
        if (ENABLE_STREAMING) scheduleStreamProcessing();
      }
    },
    onError: (error) => {
      // Treat permission/network errors as errors; no-op for 'no-speech'
      if (error !== 'no-speech') {
        setStatus('error');
        setLastError(String(error));
      }
    }
  });

  // Compute and emit debug info whenever core state changes
  useEffect(() => {
    eventBus.emit('input:voice_debug', {
      status: !isSupported ? 'error' : processingRef.current ? 'processing' : isListening ? 'listening' : 'idle',
      bufferLength: bufferRef.current.length,
      bufferText: bufferRef.current,
      apiCallsUsedLastMinute: 0, // No longer tracking API calls
      nextCallInMs: null, // No longer rate limiting
      lastError: lastError || null,
      isOnline,
      isSupported
    });
  }, [buffer, lastError, isOnline, isListening, isSupported]);

  // Online/offline monitoring
  useEffect(() => {
    const handleOnline = () => {
      setIsOnline(true);
      setLastError('');
      if (bufferRef.current) scheduleProcessing();
    };
    const handleOffline = () => {
      setIsOnline(false);
      setStatus('error');
      setLastError('Network disconnected');
    };
    window.addEventListener('online', handleOnline);
    window.addEventListener('offline', handleOffline);
    return () => {
      window.removeEventListener('online', handleOnline);
      window.removeEventListener('offline', handleOffline);
    };
  }, []);

  // Cleanup timers on unmount
  useEffect(() => {
    return () => {
      if (scheduledTimeoutRef.current !== null) {
        clearTimeout(scheduledTimeoutRef.current);
        scheduledTimeoutRef.current = null;
      }
      if (streamTimerRef.current !== null) {
        clearTimeout(streamTimerRef.current);
        streamTimerRef.current = null;
      }
    };
  }, []);

  // Stop streaming when recognition stops
  useEffect(() => {
    if (!isListening && streamTimerRef.current !== null) {
      clearTimeout(streamTimerRef.current);
      streamTimerRef.current = null;
    }
  }, [isListening]);

  // Track listening status for status display
  useEffect(() => {
    if (!isSupported) {
      setStatus('error');
      setLastError('Speech recognition not supported');
      return;
    }
    if (processingRef.current) return;
    setStatus(isListening ? 'listening' : 'idle');
  }, [isListening, isSupported]);

  const scheduleTimer = useCallback((delayMs: number) => {
    if (scheduledTimeoutRef.current !== null) {
      clearTimeout(scheduledTimeoutRef.current);
      scheduledTimeoutRef.current = null;
    }
    const runAt = Date.now() + delayMs;
    scheduledForRef.current = runAt;
    scheduledTimeoutRef.current = window.setTimeout(() => {
      scheduledTimeoutRef.current = null;
      scheduledForRef.current = null;
      attemptProcessing('final');
    }, delayMs);
  }, []);

  const scheduleProcessing = useCallback(() => {
    if (!isSupported || !isOnline) return;
    if (processingRef.current) return;
    if (!bufferRef.current) return;

    attemptProcessing('final');
  }, [isOnline, isSupported]);

  const scheduleStreamProcessing = useCallback(() => {
    if (!isSupported || !isOnline) return;
    if (processingRef.current) return;

    const now = Date.now();
    // Only if we appear to still be speaking
    if (now - (lastBufferAppendAtRef.current || now) > STILL_SPEAKING_WINDOW_MS) return;

    const sinceLast = now - (lastStreamCallAtRef.current || 0);
    const waitMs = Math.max(0, STREAM_INTERVAL_MS - sinceLast);

    if (streamTimerRef.current !== null) {
      clearTimeout(streamTimerRef.current);
      streamTimerRef.current = null;
    }
    streamTimerRef.current = window.setTimeout(() => {
      streamTimerRef.current = null;
      if (ENABLE_STREAMING) attemptProcessing('stream');
    }, waitMs);
  }, []);

  const attemptProcessing = useCallback((mode: 'final' | 'stream' = 'final') => {
    if (!isSupported || !isOnline) return;
    if (processingRef.current) return;

    // Guard by mode
    if (mode === 'final') {
      if (!bufferRef.current) return;
    } else if (mode === 'stream') {
      const nowCheck = Date.now();
      if (nowCheck - (lastBufferAppendAtRef.current || nowCheck) > STILL_SPEAKING_WINDOW_MS) return;
      const hasText = (latestFullTextRef.current && latestFullTextRef.current.length > 0) || (bufferRef.current && bufferRef.current.length > 0);
      if (!hasText) return;
    }

    processNow(mode);
  }, [isOnline, isSupported]);

  const processNow = useCallback((mode: 'final' | 'stream' = 'final') => {
    const currentBuffer = bufferRef.current;
    if (mode === 'final' && !currentBuffer) return;

    processingRef.current = true;
    setStatus('processing');
    setLastError('');

    // Remember how much text we considered at this processing moment
    callStartBufferLengthRef.current = currentBuffer ? currentBuffer.length : 0;

    const MAX_PROMPT_CHARS = 500;
    const getCommonPrefixLength = (a: string, b: string): number => {
      const minLen = Math.min(a.length, b.length);
      let i = 0;
      while (i < minLen && a.charCodeAt(i) === b.charCodeAt(i)) {
        i++;
      }
      return i;
    };
    let rawBase = '';
    if (mode === 'stream') {
      const full = latestFullTextRef.current || currentBuffer || '';
      // Use only the delta since the last stream call to avoid reprocessing old text
      let delta = '';
      const prev = lastStreamProcessedTextRef.current || '';
      if (prev && full.startsWith(prev)) {
        delta = full.slice(prev.length);
      } else {
        const common = getCommonPrefixLength(prev, full);
        delta = full.slice(common);
      }
      // If delta is tiny, still provide a small tail for context
      const tail = full.length > 400 ? full.slice(-400) : full;
      rawBase = (delta && delta.trim().length > 0) ? delta : tail;
    } else {
      rawBase = currentBuffer.length > MAX_PROMPT_CHARS ? currentBuffer.slice(-MAX_PROMPT_CHARS) : currentBuffer;
    }

    // No silence confirmation follow-up
    if (mode === 'stream') {
      lastStreamCallAtRef.current = Date.now();
      // Advance processed pointer to current full text snapshot
      lastStreamProcessedTextRef.current = latestFullTextRef.current || currentBuffer || '';
    }

    try {
      // Emit the entire current transcript on natural pause
      if (mode === 'final') {
        const transcript = (latestFullTextRef.current || currentBuffer || '').trim();
        if (transcript) {
          eventBus.emit('input:transcript_updated', { transcript, timestamp: Date.now() });
        }
      }
    } finally {
      processingRef.current = false;
      setStatus(isListening ? 'listening' : 'idle');
    }
  }, [isListening]);

  // Render nothing; this component orchestrates voice -> tasks
  return null;
}

export default VoiceTaskListener;
</file>

<file path="src/ai/toolExecutor.ts">
/* eslint-disable @typescript-eslint/no-explicit-any */
import { Task, OpenWindowParams, CloseWindowParams } from './types';
import { eventBus } from '@/lib/eventBus';

export interface ExecutionResult {
  taskId: string;
  success: boolean;
  result?: any;
  error?: string;
  timestamp: number;
}

export class ToolExecutor {
  async executeTasks(tasks: Task[], uiContext?: any): Promise<ExecutionResult[]> {
    eventBus.emit('ai:task_queue_updated', tasks);
    const results: ExecutionResult[] = [];
    
    for (const task of tasks) {
      try {
        const result = await this.executeTask(task, uiContext);
        results.push(result);
      } catch (error) {
        const errorResult = {
          taskId: task.id,
          success: false,
          error: error instanceof Error ? error.message : String(error),
          timestamp: Date.now()
        };
        results.push(errorResult);
        eventBus.emit('ai:task_failed', { task, error: errorResult.error });
      }
    }
    
    return results;
  }

  private async executeTask(task: Task, uiContext?: any): Promise<ExecutionResult> {
    eventBus.emit('ai:task_started', { task });
    const startTime = Date.now();
    
    try {
      let result: ExecutionResult;
      switch (task.tool) {
        case 'open_window':
          result = await this.executeOpenWindow(task);
          break;
        
        case 'close_window':
          result = await this.executeCloseWindow(task, uiContext);
          break;
        
        default:
          throw new Error(`Unknown tool: ${task.tool}`);
      }
      
      eventBus.emit('ai:task_completed', { task, result });
      return result;
    } catch (error) {
      const errorMsg = error instanceof Error ? error.message : String(error);
      eventBus.emit('ai:task_failed', { task, error: errorMsg });
      return {
        taskId: task.id,
        success: false,
        error: errorMsg,
        timestamp: Date.now() - startTime
      };
    }
  }

  private async executeOpenWindow(task: Task): Promise<ExecutionResult> {
    const params = task.parameters as unknown as OpenWindowParams;
    eventBus.emit('ai:tool_call_started', { task, tool: 'open_window', params });
    
    // Validate parameters
    if (!params.windowType || !params.context) {
      throw new Error('Missing required parameters for open_window: windowType and context are required');
    }
    
    // Generate a unique window ID
    const windowId = this.generateWindowId();
    
    // Emit event to UI for window creation
    const windowData = {
      id: windowId,
      type: params.windowType,
      title: params.context.title || 'Untitled Window',
      content: params.context.content || '',
      position: params.context.position || { x: 0, y: 0 },
      size: params.context.size || { width: 300, height: 200 },
      context: params.context,
      timestamp: Date.now()
    };
    
    // Emit to event bus for UI to handle
    eventBus.emit('ui:open_window', windowData);
    
    // Also emit a general window event
    eventBus.emit('window:opened', windowData);

    // If running inside a Web Worker, forward to the main thread
    // so the UI (which listens on the main thread) can react.
    try {
      // In a worker, globalThis/self has postMessage and window is undefined
      if (typeof self !== 'undefined' && typeof (self as any).postMessage === 'function' && typeof (globalThis as any).window === 'undefined') {
        (self as any).postMessage({ type: 'UI_OPEN_WINDOW', data: windowData });
      }
    } catch (_) {
      // no-op if environment detection fails
    }
    
    console.log(`[ToolExecutor] Opening ${params.windowType} window:`, windowData);
    
    const result = {
      taskId: task.id,
      success: true,
      result: {
        windowId: windowId,
        windowType: params.windowType,
        context: params.context
      },
      timestamp: Date.now()
    };
    eventBus.emit('ai:tool_call_completed', { task, tool: 'open_window', result });
    return result;
  }

  private async executeCloseWindow(task: Task, uiContext?: any): Promise<ExecutionResult> {
    const params = task.parameters as unknown as CloseWindowParams;
    eventBus.emit('ai:tool_call_started', { task, tool: 'close_window', params });

    // Resolve selector to actual window ID if needed
    let targetWindowId = params.windowId;
    if (!targetWindowId && params.selector) {
      const windows: Array<{ id: string; createdAt?: number; zIndex?: number; isMinimized?: boolean }>
        = Array.isArray(uiContext?.windows) ? uiContext.windows : [];
      if (params.selector === 'newest' || params.selector === 'latest') {
        targetWindowId = (windows.slice().sort((a, b) => (b.zIndex ?? 0) - (a.zIndex ?? 0))[0] || {}).id;
      } else if (params.selector === 'oldest') {
        targetWindowId = (windows.slice().sort((a, b) => (a.zIndex ?? 0) - (b.zIndex ?? 0))[0] || {}).id;
      } else if (params.selector === 'active') {
        targetWindowId = (windows.slice().sort((a, b) => (b.zIndex ?? 0) - (a.zIndex ?? 0))[0] || {}).id;
      } else if (params.selector === 'all') {
        const ids = windows.map(w => w.id);
        ids.forEach(id => {
          const closeData = { windowId: id, timestamp: Date.now() };
          eventBus.emit('ui:close_window', closeData);
          eventBus.emit('window:closed', closeData);
          try {
            if (typeof self !== 'undefined' && typeof (self as any).postMessage === 'function' && typeof (globalThis as any).window === 'undefined') {
              (self as any).postMessage({ type: 'UI_CLOSE_WINDOW', data: closeData });
            }
          } catch (_) {}
        });
        const result = {
          taskId: task.id,
          success: true,
          result: { closedAll: true, count: ids.length },
          timestamp: Date.now()
        };
        eventBus.emit('ai:tool_call_completed', { task, tool: 'close_window', result });
        return result;
      }
    }

    // Validate parameters
    if (!targetWindowId) {
      throw new Error('No target window found to close');
    }

    // Emit event to UI for window closure
    const closeData = {
      windowId: targetWindowId,
      timestamp: Date.now()
    };

    // Emit to event bus for UI to handle
    eventBus.emit('ui:close_window', closeData);

    // Also emit a general window event
    eventBus.emit('window:closed', closeData);

    // If running inside a Web Worker, forward to the main thread
    try {
      if (typeof self !== 'undefined' && typeof (self as any).postMessage === 'function' && typeof (globalThis as any).window === 'undefined') {
        (self as any).postMessage({ type: 'UI_CLOSE_WINDOW', data: closeData });
      }
    } catch (_) {
      // no-op
    }

    console.log(`[ToolExecutor] Closing window:`, closeData);

    const result = {
      taskId: task.id,
      success: true,
      result: {
        windowId: targetWindowId,
        closed: true
      },
      timestamp: Date.now()
    };
    eventBus.emit('ai:tool_call_completed', { task, tool: 'close_window', result });
    return result;
  }

  private generateWindowId(): string {
    return `window_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }
}

export const toolExecutor = new ToolExecutor();
</file>

<file path="src/ui/components/windowManager/windowManager.types.ts">
export interface WindowData {
  id: string;
  title: string;
  component: React.ComponentType;
  content?: string;
  isOpen: boolean;
  isMinimized: boolean;
  isFullscreen: boolean;
  x: number;
  y: number;
  width: number;
  height: number;
  zIndex: number;
  imageUrl?: string;
  animationState?: 'opening' | 'closing' | 'none';
  keywords?: string[];
  contentHash?: string;
}

export interface WindowManagerState {
  windows: WindowData[];
  activeWindowId: string | null;
  nextZIndex: number;
}
</file>

<file path="src/ai/aiWorker.ts">
/* eslint-disable @typescript-eslint/no-explicit-any */
import { TaskParser } from './taskParser';
import { ToolExecutor } from './toolExecutor';

const taskParser = new TaskParser();
const toolExecutor = new ToolExecutor();

interface ActionRecord {
  actionId: string;
  tool: string;
  parameters: Record<string, any>;
  sourceText: string;
  timestamp: number;
}

interface ConversationState {
  transcriptHistory: string;
  actionHistory: ActionRecord[];
  uiContext: any;
}

const state: ConversationState = {
  transcriptHistory: '',
  actionHistory: [],
  uiContext: {}
};

function updateTranscriptHistory(newTranscript: string) {
  const combined = newTranscript || '';
  state.transcriptHistory = combined.length > 500 ? combined.slice(-500) : combined;
}

function appendActionRecord(record: ActionRecord) {
  state.actionHistory.push(record);
  if (state.actionHistory.length > 10) {
    state.actionHistory = state.actionHistory.slice(-10);
  }
}

// Startup diagnostics
try {
  const isWorkerScope = typeof self !== 'undefined' && (self as unknown as { importScripts?: unknown }).importScripts !== undefined;
  // location is undefined in dedicated workers in some environments; guard accesses
  const href = (typeof location !== 'undefined' && location?.href) ? location.href : 'n/a';
  const origin = (typeof location !== 'undefined' && (location as any)?.origin) ? (location as any).origin : 'n/a';
  console.log('[AI Worker] Startup', { isWorkerScope, href, origin });
} catch {
  // ignore
}

self.addEventListener('message', (event) => {
  const { type, data } = event.data;
  
  switch (type) {
    case 'SET_UI_CONTEXT':
      try { state.uiContext = data || {}; } catch {}
      break;
    
    case 'PROCESS_TEXT_COMMAND':
      processTextCommand(data);
      break;
    
    case 'GENERATE_RESPONSE':
      generateResponse(data);
      break;
    
    
    default:
      console.warn(`Unknown AI worker message type: ${type}`);
  }
});

async function processTextCommand(data: any) {
  try {
    // New payload accepts { transcript, uiContext? } or string
    const transcript = (typeof data?.transcript === 'string') ? data.transcript : (typeof data === 'string' ? data : '');
    if (!transcript) {
      throw new Error('No transcript provided');
    }
    if (data && typeof data === 'object' && data.uiContext) {
      state.uiContext = data.uiContext;
    }

    updateTranscriptHistory(transcript);

    console.log('[AI Worker] Processing transcript', {
      uiContextSummary: {
        windowsCount: Array.isArray(state.uiContext?.windows) ? state.uiContext.windows.length : 0
      }
    });

    // Ask parser for new tool calls based on ConversationState
    const parseResult: any = await taskParser.parseTextToTasks({
      transcript: state.transcriptHistory,
      actionHistory: state.actionHistory,
      uiContext: state.uiContext
    } as any);

    const newCalls: Array<{ tool: string; parameters: any; sourceText: string }> = Array.isArray(parseResult?.new_tool_calls) ? parseResult.new_tool_calls : [];

    const executionResults: any[] = [];
    for (const call of newCalls) {
      const record: ActionRecord = {
        actionId: generateId(),
        tool: call.tool,
        parameters: call.parameters,
        sourceText: call.sourceText,
        timestamp: Date.now()
      };
      try {
        const res = await toolExecutor.executeTasks([
          { id: record.actionId, tool: record.tool, parameters: record.parameters, description: record.tool }
        ], state.uiContext);
        executionResults.push(...res);
      } finally {
        appendActionRecord(record);
      }
    }

    self.postMessage({
      type: 'TEXT_COMMAND_PROCESSED',
      data: {
        id: generateId(),
        success: true,
        originalText: transcript,
        tasks: newCalls,
        executionResults,
        processingTime: 0,
        timestamp: Date.now()
      }
    });
    
  } catch (error) {
    console.error('[AI Worker] Error processing text command:', error);
    
    self.postMessage({
      type: 'AI_ERROR',
      data: { 
        error: error instanceof Error ? error.message : String(error), 
        textInput: (typeof data?.transcript === 'string') ? data.transcript : undefined,
        type: 'text_command_error'
      }
    });
  }
}


async function generateResponse(prompt: any) {
  try {
    // Check if this is a text command that should be processed differently
    const text = prompt.text || prompt.command || prompt.prompt;
    
    if (text && (typeof text === 'string')) {
      // Delegate to text command processor
      await processTextCommand(text);
      return;
    }
    
    // Fallback to simple response generation
    await new Promise(resolve => setTimeout(resolve, 1500));
    
    const response = {
      id: generateId(),
      response: `AI response to: ${JSON.stringify(prompt)}`,
      timestamp: Date.now(),
      prompt
    };
    
    self.postMessage({
      type: 'AI_RESPONSE_GENERATED',
      data: response
    });
  } catch (error) {
    self.postMessage({
      type: 'AI_ERROR',
      data: { error: error instanceof Error ? error.message : String(error), prompt }
    });
  }
}


function generateId(): string {
  return Math.random().toString(36).substr(2, 9);
}

export {};
</file>

<file path="src/ai/cerebrasClient.ts">
/* eslint-disable @typescript-eslint/no-explicit-any */
import { CerebrasRequest, CerebrasResponse, Tool, CerebrasTool } from './types';

export class CerebrasClient {
  // Client no longer holds API key; all calls go through server route
  constructor(_apiKey?: string) {}

  async createChatCompletion(request: CerebrasRequest): Promise<CerebrasResponse> {
    // Always call our internal API route which adds auth server-side
    let targetUrl = '/api/cerebras-tasks';

    try {
      // Debug: log environment context from worker/main thread
      const isWorkerScope = typeof self !== 'undefined' && (self as unknown as { importScripts?: unknown }).importScripts !== undefined;

      // In worker context, construct absolute URL using worker's location
      if (isWorkerScope) {
        let workerOrigin = 'http://localhost:3000'; // fallback

        try {
          // Try to get the actual origin from the worker's location
          if (typeof location !== 'undefined' && (location as any)?.origin) {
            workerOrigin = (location as any).origin;
          } else if (typeof location !== 'undefined' && location?.href) {
            // Fallback: extract origin from href
            const url = new URL(location.href);
            workerOrigin = url.origin;
          }
        } catch (error) {
          console.warn('[CerebrasClient] Failed to determine worker origin:', error);
        }

        targetUrl = `${workerOrigin}/api/cerebras-tasks`;
      }

      // Avoid leaking secrets; only log safe runtime details
      console.log('[CerebrasClient] createChatCompletion', {
        targetUrl,
        isWorkerScope,
        locationHref: (typeof location !== 'undefined' && location?.href) ? location.href : 'n/a',
        baseHref: (typeof document !== 'undefined' && (document as any)?.baseURI) ? (document as any).baseURI : 'n/a'
      });
    } catch {
      // ignore logging errors
    }

    const response = await fetch(targetUrl, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ cerebrasRequest: request })
    });

    if (!response.ok) {
      const errorText = await response.text();
      throw new Error(`Internal API error (${response.status}): ${errorText}`);
    }

    return await response.json() as CerebrasResponse;
  }


}
</file>

<file path="src/ai/AIManager.ts">
import { eventBus } from '@/lib/eventBus';

type SerializableWindow = {
  id: string;
  title?: string;
  isOpen?: boolean;
  isMinimized?: boolean;
  x?: number;
  y?: number;
  width?: number;
  height?: number;
  zIndex?: number;
};

type SerializableUIContext = { windows?: SerializableWindow[] };

export class AIManager {
  private worker: Worker | null = null;
  private isInitialized = false;
  private uiContext: SerializableUIContext = {};

  // Only send data that can be structured-cloned to the worker
  private getSerializableUIContext(): SerializableUIContext {
    try {
      const context = this.uiContext || {};
      const serializable: SerializableUIContext = {};

      if (Array.isArray(context.windows)) {
        const cleaned: SerializableWindow[] = context.windows
          .filter((w: Partial<SerializableWindow>): w is SerializableWindow => typeof w?.id === 'string')
          .map((w) => ({
            id: w.id,
            title: w.title,
            // omit component/functions; include only plain data
            isOpen: Boolean(w.isOpen),
            isMinimized: Boolean(w.isMinimized),
            x: typeof w.x === 'number' ? w.x : undefined,
            y: typeof w.y === 'number' ? w.y : undefined,
            width: typeof w.width === 'number' ? w.width : undefined,
            height: typeof w.height === 'number' ? w.height : undefined,
            zIndex: typeof w.zIndex === 'number' ? w.zIndex : undefined
          }));
        serializable.windows = cleaned;
      }

      return serializable;
    } catch {
      return {} as SerializableUIContext;
    }
  }

  async initialize(): Promise<void> {
    if (this.isInitialized) return;

    try {
      this.worker = new Worker(new URL('./aiWorker.ts', import.meta.url));
      
      this.worker.onmessage = (event) => {
        const { type, data } = event.data;
        // Normalize error channel
        if (type === 'AI_ERROR') {
          eventBus.emit('ai:error', data);
          return;
        }
        // Bridge UI_* messages to UI event bus
        if (type === 'UI_OPEN_WINDOW') {
          eventBus.emit('ui:open_window', data);
          return;
        }
        if (type === 'UI_CLOSE_WINDOW') {
          eventBus.emit('ui:close_window', data);
          return;
        }
        eventBus.emit(`ai:${type.toLowerCase()}`, data);
      };

      this.worker.onerror = (error) => {
        console.error('AI worker error:', error);
        eventBus.emit('ai:error', error);
      };

      this.isInitialized = true;
      eventBus.emit('ai:initialized');

      // Bridge: when input emits transcript updates, forward to worker for stateful processing
      eventBus.on('input:transcript_updated', (data: { transcript: string }) => {
        try {
          const transcript = (data?.transcript || '').trim();
          if (!transcript) return;
          eventBus.emit('ai:processing', { count: 1 });
          this.worker?.postMessage({
            type: 'PROCESS_TEXT_COMMAND',
            data: { transcript, uiContext: this.getSerializableUIContext() }
          });
        } catch (e) {
          eventBus.emit('ai:error', e);
        }
      });
    } catch (error) {
      console.error('Failed to initialize AI worker:', error);
      eventBus.emit('ai:error', error);
    }
  }

  setUIContext(context: SerializableUIContext): void {
    this.uiContext = context;
    try {
      // Forward context to worker so it can be included in ConversationState
      this.worker?.postMessage({ type: 'SET_UI_CONTEXT', data: this.getSerializableUIContext() });
    } catch {}
  }


  processTextCommand(text: string): void {
    if (!this.worker) {
      console.warn('AI worker not initialized');
      return;
    }

    this.worker.postMessage({
      type: 'PROCESS_TEXT_COMMAND',
      data: { text, uiContext: this.getSerializableUIContext() }
    });
  }

  generateResponse(prompt: unknown): void {
    if (!this.worker) {
      console.warn('AI worker not initialized');
      return;
    }

    this.worker.postMessage({
      type: 'GENERATE_RESPONSE',
      data: prompt as object
    });
  }


  destroy(): void {
    if (this.worker) {
      this.worker.terminate();
      this.worker = null;
    }
    this.isInitialized = false;
    eventBus.emit('ai:destroyed');
  }
}

export const aiManager = new AIManager();
</file>

<file path="src/ui/components/window/Window.tsx">
'use client';

import { useEffect, useRef, useState } from 'react';
import { WindowProps } from './window.types';

export function Window({
	children,
	id,
	title,
	initialX = 0,
	initialY = 0,
	width = 500,
	height = 400,
	isActive = false,
	isMinimized,
	isFullscreen = false,
	zIndex = 10,
	onClose = () => {},
	onMinimize,
	onRestore,
	onFullscreen = () => {},
	onFocus = () => {},
	onPositionChange,
	lockAspectRatio = false,
	headerStyle = 'standard',
	resizable = false,
	animationState = 'none'
}: WindowProps) {
	const windowRef = useRef<HTMLDivElement>(null);
	const [position, setPosition] = useState({ x: initialX, y: initialY });
	const [size, setSize] = useState({ width, height });
	const isDraggingRef = useRef(false);
	const isResizingRef = useRef(false);
	const resizeDirectionRef = useRef<string>('');
	const dragOffsetRef = useRef({ x: 0, y: 0 });
	const currentPositionRef = useRef({ x: initialX, y: initialY });
	const resizeStartRef = useRef({ x: 0, y: 0, width: 0, height: 0 });
	const lastUpdateRef = useRef(0);
	const lastPositionChangeRef = useRef(0);

	useEffect(() => {
		setPosition({ x: initialX, y: initialY });
		currentPositionRef.current = { x: initialX, y: initialY };
	}, [initialX, initialY]);

	useEffect(() => {
		setSize({ width, height });
	}, [width, height]);

	// Cleanup animation frames on unmount
	useEffect(() => {
		return () => {
			if (lastUpdateRef.current) {
				cancelAnimationFrame(lastUpdateRef.current);
			}
		};
	}, []);

	const onMouseDown = (e: React.MouseEvent) => {
		if (isResizingRef.current) return;
		onFocus();
		isDraggingRef.current = true;
		dragOffsetRef.current = {
			x: e.clientX - position.x,
			y: e.clientY - position.y
		};
		document.addEventListener('mousemove', onMouseMove);
		document.addEventListener('mouseup', onMouseUp);
	};

// legacy resizer removed in favor of directional resize handles

	const onMouseMove = (e: MouseEvent) => {
		if (isDraggingRef.current) {
			const newPosition = {
				x: e.clientX - dragOffsetRef.current.x,
				y: e.clientY - dragOffsetRef.current.y
			};
			
			// Use requestAnimationFrame for smooth updates
			if (typeof window.requestAnimationFrame === 'function') {
				cancelAnimationFrame(lastUpdateRef.current);
				lastUpdateRef.current = requestAnimationFrame(() => {
					setPosition(newPosition);
					currentPositionRef.current = newPosition;
					
					// Throttle position change callbacks to reduce expensive operations
					const now = Date.now();
					if (now - lastPositionChangeRef.current > 16) { // ~60fps
						lastPositionChangeRef.current = now;
						if (onPositionChange) {
							onPositionChange(id, newPosition.x, newPosition.y);
						}
					}
				});
			} else {
				setPosition(newPosition);
				currentPositionRef.current = newPosition;
				
				// Throttle position change callbacks
				const now = Date.now();
				if (now - lastPositionChangeRef.current > 16) {
					lastPositionChangeRef.current = now;
					if (onPositionChange) {
						onPositionChange(id, newPosition.x, newPosition.y);
					}
				}
			}
		} else if (isResizingRef.current) {
			const direction = resizeDirectionRef.current;
			const deltaX = e.clientX - resizeStartRef.current.x;
			const deltaY = e.clientY - resizeStartRef.current.y;

			let newWidth = resizeStartRef.current.width;
			let newHeight = resizeStartRef.current.height;
			let newX = position.x;
			let newY = position.y;

			if (direction.includes('right')) {
				newWidth = Math.max(200, resizeStartRef.current.width + deltaX);
			}
			if (direction.includes('left')) {
				newWidth = Math.max(200, resizeStartRef.current.width - deltaX);
				newX = resizeStartRef.current.x + (resizeStartRef.current.width - newWidth);
			}
			if (direction.includes('bottom')) {
				newHeight = Math.max(150, resizeStartRef.current.height + deltaY);
			}
			if (direction.includes('top')) {
				newHeight = Math.max(150, resizeStartRef.current.height - deltaY);
				newY = resizeStartRef.current.y + (resizeStartRef.current.height - newHeight);
			}

			setSize({ width: newWidth, height: newHeight });
			if (newX !== position.x || newY !== position.y) {
				setPosition({ x: newX, y: newY });
				currentPositionRef.current = { x: newX, y: newY };
			}
		}
	};

	const onMouseUp = () => {
		isDraggingRef.current = false;
		isResizingRef.current = false;
		resizeDirectionRef.current = '';
		document.removeEventListener('mousemove', onMouseMove);
		document.removeEventListener('mouseup', onMouseUp);

		if (onPositionChange) {
			onPositionChange(id, currentPositionRef.current.x, currentPositionRef.current.y);
		}
	};

	const onResizeStart = (e: React.MouseEvent, direction: string) => {
		e.preventDefault();
		e.stopPropagation();
		onFocus();

		isResizingRef.current = true;
		resizeDirectionRef.current = direction;
		resizeStartRef.current = {
			x: e.clientX,
			y: e.clientY,
			width: size.width,
			height: size.height
		};

		document.addEventListener('mousemove', onMouseMove);
		document.addEventListener('mouseup', onMouseUp);
	};

	const handleMinimizeClick = () => {
		if (isMinimized) {
			onRestore();
		} else {
			onMinimize();
		}
	};

	const getAnimationClasses = () => {
		// Disable transitions during dragging for better performance
		const transitionClasses = isDraggingRef.current || isResizingRef.current 
			? 'will-change-transform' 
			: 'will-change-transform transition-all duration-300';
		
		const baseClasses = `absolute bg-black/40 backdrop-blur-2xl rounded-2xl shadow-2xl border border-cyan-400/30 overflow-hidden hover:shadow-cyan-400/20 hover:shadow-2xl hover:bg-black/50 ${transitionClasses}`;

		if (isFullscreen) {
			return `${baseClasses} fixed inset-0 rounded-none z-50 bg-black/60 border-cyan-400/50`;
		}

		const activeClasses = isActive
			? 'ring-2 ring-cyan-400/50 shadow-cyan-400/30 border-cyan-400/60 shadow-cyan-400/40'
			: 'shadow-black/40';

		switch (animationState) {
			case 'opening':
				return `${baseClasses} ${activeClasses} animate-window-open`;
			case 'closing':
				return `${baseClasses} ${activeClasses} animate-window-close`;
			default:
				return `${baseClasses} ${activeClasses}`;
		}
	};

	return (
		<div
			ref={windowRef}
			data-window-id={id}
			className={getAnimationClasses()}
			style={isFullscreen ? { zIndex } : {
				'--window-x': `${position.x}px`,
				'--window-y': `${position.y}px`,
				transform: `translate3d(${position.x}px, ${position.y}px, 0)`,
				width: size.width,
				height: isMinimized ? 'auto' : size.height,
				zIndex
			} as React.CSSProperties}
			onMouseDown={() => onFocus()}
		>
			{headerStyle === 'standard' ? (
				<div className={`flex items-center px-3 py-2 select-none cursor-move backdrop-blur-sm ${isActive ? 'bg-gradient-to-r from-cyan-900/60 via-blue-900/50 to-purple-900/60 border-b border-cyan-400/40 shadow-inner shadow-cyan-400/20' : 'bg-gradient-to-r from-gray-900/60 via-slate-900/50 to-gray-900/60 border-b border-gray-600/30'}`} onMouseDown={onMouseDown}>
					<div className="flex items-center space-x-1.5">
						<div className="group flex items-center space-x-1">
							<button
								onClick={onClose}
								className="w-3 h-3 rounded-full bg-gradient-to-br from-purple-400 to-violet-600 hover:from-purple-300 hover:to-violet-500 transition-all duration-200 flex-shrink-0 flex items-center justify-center shadow-sm hover:shadow-purple-400/60 hover:shadow-lg transform hover:scale-110 ring-0 hover:ring-1 hover:ring-purple-400/60 neon-glow-purple"
								onMouseDown={(e) => e.stopPropagation()}
								style={{
									boxShadow: '0 0 8px rgba(168, 85, 247, 0.4), inset 0 1px 0 rgba(255, 255, 255, 0.2)'
								}}
							>
								<span className="text-[10px] text-white font-bold leading-none opacity-80 group-hover:opacity-100 transition-opacity duration-200 drop-shadow-sm">
									×
								</span>
							</button>
							<button
								onClick={handleMinimizeClick}
								className="w-3 h-3 rounded-full bg-gradient-to-br from-cyan-400 to-blue-500 hover:from-cyan-300 hover:to-blue-400 transition-all duration-200 flex-shrink-0 flex items-center justify-center shadow-sm hover:shadow-cyan-400/60 hover:shadow-lg transform hover:scale-110 ring-0 hover:ring-1 hover:ring-cyan-400/60 neon-glow-cyan"
								onMouseDown={(e) => e.stopPropagation()}
								title={isMinimized ? 'Restore' : 'Minimize'}
								style={{
									boxShadow: '0 0 8px rgba(34, 211, 238, 0.4), inset 0 1px 0 rgba(255, 255, 255, 0.2)'
								}}
							>
								<span className="text-[10px] text-white font-bold leading-none opacity-80 group-hover:opacity-100 transition-opacity duration-200 drop-shadow-sm">
									{isMinimized ? '+' : '−'}
								</span>
							</button>
							<button
								onClick={onFullscreen}
								className="w-3 h-3 rounded-full bg-gradient-to-br from-lime-400 to-green-500 hover:from-lime-300 hover:to-green-400 transition-all duration-200 flex-shrink-0 flex items-center justify-center shadow-sm hover:shadow-lime-400/60 hover:shadow-lg transform hover:scale-110 ring-0 hover:ring-1 hover:ring-lime-400/60 neon-glow-lime"
								onMouseDown={(e) => e.stopPropagation()}
								title={isFullscreen ? 'Exit Fullscreen' : 'Fullscreen'}
								style={{
									boxShadow: '0 0 8px rgba(163, 230, 53, 0.4), inset 0 1px 0 rgba(255, 255, 255, 0.2)'
								}}
							>
								<span className="text-[10px] text-white font-bold leading-none opacity-80 group-hover:opacity-100 transition-opacity duration-200 drop-shadow-sm">
									{isFullscreen ? '⤈' : '⤢'}
								</span>
							</button>
						</div>
						<span className={`text-xs font-semibold ${isActive ? 'text-cyan-200 drop-shadow-lg shadow-cyan-400/70' : 'text-cyan-300/90'}`}>{title}</span>
					</div>
				</div>
			) : (
				<div className="absolute top-3 right-3 flex space-x-2 z-30">
					<button
						onClick={onClose}
						className="w-6 h-6 rounded-full bg-red-500/40 hover:bg-red-600/60 backdrop-blur-sm flex items-center justify-center transition-all duration-200 hover:scale-110"
						title="Close"
					>
						<svg className="w-3 h-3 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
							<path strokeLinecap="round" strokeLinejoin="round" strokeWidth={3} d="M6 18L18 6M6 6l12 12" />
						</svg>
					</button>
				</div>
			)}
			{!isMinimized && (
				<div className={`w-full bg-black/30 backdrop-blur-sm border-t border-cyan-400/20 ${isFullscreen ? 'h-[calc(100vh-40px)]' : 'h-[calc(100%-40px)]'}`}>
					<div className="p-1">
						{children}
					</div>
				</div>
			)}

			{/* Resize handles - only show when resizable, not minimized and not fullscreen */}
			{resizable && !isMinimized && !isFullscreen && (
				<>
					{/* Corner handles */}
					<div className="absolute top-0 left-0 w-4 h-4 cursor-nw-resize opacity-0 hover:opacity-100 transition-all duration-200 bg-cyan-400/20 hover:bg-cyan-400/40 hover:shadow-cyan-400/50 hover:shadow-md rounded-br-lg" onMouseDown={(e) => onResizeStart(e, 'top-left')} />
					<div className="absolute top-0 right-0 w-4 h-4 cursor-ne-resize opacity-0 hover:opacity-100 transition-all duration-200 bg-cyan-400/20 hover:bg-cyan-400/40 hover:shadow-cyan-400/50 hover:shadow-md rounded-bl-lg" onMouseDown={(e) => onResizeStart(e, 'top-right')} />
					<div className="absolute bottom-0 left-0 w-4 h-4 cursor-sw-resize opacity-0 hover:opacity-100 transition-all duration-200 bg-cyan-400/20 hover:bg-cyan-400/40 hover:shadow-cyan-400/50 hover:shadow-md rounded-tr-lg" onMouseDown={(e) => onResizeStart(e, 'bottom-left')} />
					<div className="absolute bottom-0 right-0 w-4 h-4 cursor-se-resize opacity-0 hover:opacity-100 transition-all duration-200 bg-cyan-400/30 hover:bg-cyan-400/50 hover:shadow-cyan-400/50 hover:shadow-md rounded-tl-lg" onMouseDown={(e) => onResizeStart(e, 'bottom-right')} />

					{/* Edge handles */}
					<div className="absolute top-0 left-4 right-4 h-2 cursor-n-resize opacity-0 hover:opacity-100 transition-all duration-200 bg-cyan-400/10 hover:bg-cyan-400/30 hover:shadow-cyan-400/20 hover:shadow-sm" onMouseDown={(e) => onResizeStart(e, 'top')} />
					<div className="absolute bottom-0 left-4 right-4 h-2 cursor-s-resize opacity-0 hover:opacity-100 transition-all duration-200 bg-cyan-400/10 hover:bg-cyan-400/30 hover:shadow-cyan-400/20 hover:shadow-sm" onMouseDown={(e) => onResizeStart(e, 'bottom')} />
					<div className="absolute top-4 bottom-4 left-0 w-2 cursor-w-resize opacity-0 hover:opacity-100 transition-all duration-200 bg-cyan-400/10 hover:bg-cyan-400/30 hover:shadow-cyan-400/20 hover:shadow-sm" onMouseDown={(e) => onResizeStart(e, 'left')} />
					<div className="absolute top-4 bottom-4 right-0 w-2 cursor-e-resize opacity-0 hover:opacity-100 transition-all duration-200 bg-cyan-400/10 hover:bg-cyan-400/30 hover:shadow-cyan-400/20 hover:shadow-sm" onMouseDown={(e) => onResizeStart(e, 'right')} />
				</>
			)}
		</div>
	);
}

export default Window;
</file>

<file path="src/ui/components/windowManager/WindowManager.tsx">
'use client';

import { useEffect, useState, forwardRef, useImperativeHandle, useRef } from 'react';
import { Window } from '../window';
import { WindowData, WindowManagerState } from './windowManager.types';
import { eventBus } from '@/lib/eventBus';

interface WindowManagerProps {
  children: React.ReactNode;
  onWindowsChange?: (windows: WindowData[]) => void;
}

export interface WindowManagerRef {
  openWindow: (windowData: Omit<WindowData, 'isOpen' | 'zIndex'>) => void;
  closeWindow: (windowId: string) => void;
  minimizeWindow: (windowId: string) => void;
  restoreWindow: (windowId: string) => void;
  toggleFullscreen: (windowId: string) => void;
  getWindows: () => WindowData[];
  organizeWindows: () => void;
}

export const WindowManager = forwardRef<WindowManagerRef, WindowManagerProps>(function WindowManager({ children, onWindowsChange }, ref) {
  const [state, setState] = useState<WindowManagerState>({
    windows: [],
    activeWindowId: null,
    nextZIndex: 10
  });

  // Helper function to create a unique connection ID
  // Connections feature removed per decision

  const getOptimalPosition = (width: number, height: number, currentWindows: WindowData[]): { x: number; y: number } => {
    const viewportWidth = typeof window !== 'undefined' ? window.innerWidth : 1920;
    const viewportHeight = typeof window !== 'undefined' ? window.innerHeight : 1080;

    const margin = 20;
    
    // RESTRICT TO LEFT 95%: right edge cannot exceed 95% (5% reserved for image drop)
    const maxRightEdge = viewportWidth * 0.95;
    const maxAllowedX = maxRightEdge - width;

    // If no windows exist, place at top-left
    if (currentWindows.length === 0) {
      return { x: margin, y: margin };
    }

    const occupiedAreas = currentWindows.map(w => ({
      x1: w.x,
      y1: w.y,
      x2: w.x + w.width,
      y2: w.y + w.height
    }));

    const isPositionFree = (x: number, y: number, testWidth: number, testHeight: number): boolean => {
      const proposedArea = {
        x1: x,
        y1: y,
        x2: x + testWidth,
        y2: y + testHeight
      };

      return !occupiedAreas.some(area =>
        !(proposedArea.x2 <= area.x1 ||
          proposedArea.x1 >= area.x2 ||
          proposedArea.y2 <= area.y1 ||
          proposedArea.y1 >= area.y2)
      );
    };

    // STRICT TOP-LEFT PRIORITY: Scan row by row from top-left
    const stepSize = 15;
    for (let y = margin; y <= viewportHeight - height - margin; y += stepSize) {
      for (let x = margin; x <= maxAllowedX; x += stepSize) {
        if (isPositionFree(x, y, width, height)) {
          return { x, y };
        }
      }
    }

    // If no free space found, use top-left fallback
    return { x: margin, y: margin };
  };

  const organizeWindows = () => {
    const imageWindows = state.windows.filter(window => window.id.startsWith('image-viewer-'));
    if (imageWindows.length === 0) return;

    const viewportWidth = typeof window !== 'undefined' ? window.innerWidth : 1920;
    const viewportHeight = typeof window !== 'undefined' ? window.innerHeight : 1080;
    const screenArea = viewportWidth * viewportHeight;
    const minAreaPerWindow = screenArea * 0.1; // 10% minimum area requirement

    // Screen constraints
    const margin = 5;
    const maxRightEdge = viewportWidth * 0.95;
    const availableWidth = maxRightEdge - margin * 2;
    const availableHeight = viewportHeight - margin * 2;

    // Calculate conservative sizing for multiple windows
    const conservativeMultiplier = Math.max(1.5, 3.0 - (imageWindows.length * 0.2));
    const totalTargetArea = Math.min(availableWidth * availableHeight * 0.80, imageWindows.length * minAreaPerWindow * conservativeMultiplier);
    const baseAreaPerWindow = totalTargetArea / imageWindows.length;

    console.log(`Organizing ${imageWindows.length} windows with minimum area priority`);

    // Sort by current area (largest first)
    const sortedWindows = imageWindows.sort((a, b) => (b.width * b.height) - (a.width * a.height));

    const packedWindows: WindowData[] = [];
    const occupiedRects: Array<{x: number, y: number, width: number, height: number}> = [];

    // Helper to check if position is available
    const canPlaceAt = (x: number, y: number, width: number, height: number): boolean => {
      if (x < 0 || y < 0 || x + width > availableWidth || y + height > availableHeight) return false;

      return !occupiedRects.some(rect =>
        !(x >= rect.x + rect.width + margin ||
          x + width <= rect.x - margin ||
          y >= rect.y + rect.height + margin ||
          y + height <= rect.y - margin)
      );
    };

    // Helper to find best position
    const findBestPosition = (width: number, height: number): {x: number, y: number} | null => {
      for (let y = 0; y <= availableHeight - height; y += 10) {
        for (let x = 0; x <= availableWidth - width; x += 10) {
          if (canPlaceAt(x, y, width, height)) {
            return { x, y };
          }
        }
      }
      return null;
    };

    // Process each window with MINIMUM AREA PRIORITY
    for (const window of sortedWindows) {
      const aspectRatio = window.width / window.height;
      const targetArea = Math.max(minAreaPerWindow, baseAreaPerWindow);

      // Calculate optimal dimensions
      let optimalWidth, optimalHeight;
      if (aspectRatio > 1) {
        optimalWidth = Math.sqrt(targetArea * aspectRatio);
        optimalHeight = Math.sqrt(targetArea / aspectRatio);
      } else {
        optimalHeight = Math.sqrt(targetArea / aspectRatio);
        optimalWidth = Math.sqrt(targetArea * aspectRatio);
      }

      let finalWindow = null;

      // Try 1: Optimal size without overlap
      const optimalPos = findBestPosition(Math.round(optimalWidth), Math.round(optimalHeight));
      if (optimalPos) {
        finalWindow = {
          ...window,
          width: Math.round(optimalWidth),
          height: Math.round(optimalHeight),
          x: optimalPos.x + margin,
          y: optimalPos.y + margin
        };
      } else {
        // Try 2: Scale down but NEVER below minimum area
        const minScale = Math.sqrt(minAreaPerWindow / (optimalWidth * optimalHeight));
        let scaleFactor = 0.9;

        while (scaleFactor >= minScale && !finalWindow) {
          const scaledWidth = Math.round(optimalWidth * scaleFactor);
          const scaledHeight = Math.round(optimalHeight * scaleFactor);

          if (scaledWidth * scaledHeight >= minAreaPerWindow) {
            const scaledPos = findBestPosition(scaledWidth, scaledHeight);
            if (scaledPos) {
              finalWindow = {
                ...window,
                width: scaledWidth,
                height: scaledHeight,
                x: scaledPos.x + margin,
                y: scaledPos.y + margin
              };
            }
          }
          scaleFactor -= 0.05;
        }

        // Try 3: Minimum area size - MUST be placed even with overlap
        if (!finalWindow) {
          const minWidth = Math.round(Math.sqrt(minAreaPerWindow * aspectRatio));
          const minHeight = Math.round(Math.sqrt(minAreaPerWindow / aspectRatio));

          console.warn(`Using minimum area for window ${window.id}: ${minWidth}×${minHeight}`);

          const minPos = findBestPosition(minWidth, minHeight);
          if (minPos) {
            finalWindow = {
              ...window,
              width: minWidth,
              height: minHeight,
              x: minPos.x + margin,
              y: minPos.y + margin
            };
          } else {
            // LAST RESORT: Allow overlap to maintain minimum area
            console.warn(`ALLOWING OVERLAP for window ${window.id} to maintain minimum area requirement`);

            // Find position with minimal overlap
            let bestOverlapPos = { x: margin, y: margin };
            let minOverlap = Infinity;

            for (let y = 0; y <= availableHeight - minHeight; y += 20) {
              for (let x = 0; x <= availableWidth - minWidth; x += 20) {
                if (x >= 0 && y >= 0 && x + minWidth <= availableWidth && y + minHeight <= availableHeight) {
                  let overlapArea = 0;

                  for (const rect of occupiedRects) {
                    const left = Math.max(x, rect.x);
                    const top = Math.max(y, rect.y);
                    const right = Math.min(x + minWidth, rect.x + rect.width);
                    const bottom = Math.min(y + minHeight, rect.y + rect.height);

                    if (left < right && top < bottom) {
                      overlapArea += (right - left) * (bottom - top);
                    }
                  }

                  if (overlapArea < minOverlap) {
                    minOverlap = overlapArea;
                    bestOverlapPos = { x: x + margin, y: y + margin };
                  }
                }
              }
            }

            finalWindow = {
              ...window,
              width: minWidth,
              height: minHeight,
              x: bestOverlapPos.x,
              y: bestOverlapPos.y
            };

            if (minOverlap > 0) {
              console.warn(`Window ${window.id} placed with ${minOverlap}px² overlap (minimum area preserved)`);
            }
          }
        }
      }

      if (finalWindow) {
        packedWindows.push(finalWindow);
        occupiedRects.push({
          x: finalWindow.x - margin,
          y: finalWindow.y - margin,
          width: finalWindow.width,
          height: finalWindow.height
        });
      }
    }

    if (packedWindows.length === 0) return;

    // Update state asynchronously
    setTimeout(() => {
      setState(prev => ({
        ...prev,
        windows: prev.windows.map(window => {
          const optimized = packedWindows.find(pw => pw.id === window.id);
          return optimized ? optimized : window;
        })
      }));
    }, 0);

    // Report results
    const totalArea = packedWindows.reduce((sum, w) => sum + (w.width * w.height), 0);
    const minAreaWindows = packedWindows.filter(w => (w.width * w.height) <= minAreaPerWindow * 1.1);

    // logs muted per decision
  };



  const addNaturalScatter = (position: { x: number; y: number }, width: number, height: number): { x: number; y: number } => {
    const viewportWidth = typeof window !== 'undefined' ? window.innerWidth : 1920;
    const viewportHeight = typeof window !== 'undefined' ? window.innerHeight : 1080;

    const scatterRangeX = Math.min(120, viewportWidth * 0.08);
    const scatterRangeY = Math.min(80, viewportHeight * 0.06);

    const offsetX = (Math.random() - 0.5) * 2 * scatterRangeX;
    const offsetY = (Math.random() - 0.5) * 2 * scatterRangeY;

    const margin = 30;
    const scatteredX = Math.max(margin, Math.min(viewportWidth - width - margin, position.x + offsetX));
    const scatteredY = Math.max(margin, Math.min(viewportHeight - height - margin, position.y + offsetY));

    return { x: scatteredX, y: scatteredY };
  };

  const openWindow = (windowData: Omit<WindowData, 'isOpen' | 'zIndex'>) => {
    // Extract keywords from content if available
    // const windowContent = contentSimilarityAnalyzer.processWindowContent(
    //   windowData.id,
    //   windowData.title,
    //   windowData.content || ''
    // );
    setState(prev => {
      const currentWindows = prev.windows.filter(w => w.id !== windowData.id);

      const optimalPosition = getOptimalPosition(windowData.width, windowData.height, currentWindows);

      const newWindow = {
        ...windowData,
        x: optimalPosition.x,
        y: optimalPosition.y,
        isOpen: true,
        isFullscreen: false,
        zIndex: prev.nextZIndex,
        animationState: 'opening' as const,
        // keywords: windowContent.keywords,
        contentHash: windowData.content?.slice(0, 100)
      };

      const newState = {
        ...prev,
        windows: [
          ...currentWindows,
          newWindow
        ],
        activeWindowId: windowData.id,
        nextZIndex: prev.nextZIndex + 1
      };

      // Emit only lightweight event; logs muted
      setTimeout(() => {
        try {
          eventBus.emit('window:opened', { id: windowData.id, type: 'ui', title: windowData.title });
        } catch {}
      }, 0);

      // Reset animation state after opening animation completes
      setTimeout(() => {
        setState(currentState => ({
          ...currentState,
          windows: currentState.windows.map(w =>
            w.id === windowData.id
              ? { ...w, animationState: 'none' as const }
              : w
          )
        }));
      }, 80);


      return newState;
    });
  };

  const closeWindow = (windowId: string) => {
    // First set the closing animation state
    setState(prev => ({
      ...prev,
      windows: prev.windows.map(w =>
        w.id === windowId
          ? { ...w, animationState: 'closing' as const }
          : w
      )
    }));
    // After animation completes, remove the window
    setTimeout(() => {
      setState(prev => ({
        ...prev,
        windows: prev.windows.filter(w => w.id !== windowId),
        activeWindowId: prev.activeWindowId === windowId ? null : prev.activeWindowId
      }));

      // Emit event after window is removed
      setTimeout(() => {
        try {
          eventBus.emit('window:closed', { windowId });
        } catch {}
      }, 0);
    }, 250); // Match the closing animation duration
  };

  const minimizeWindow = (windowId: string) => {
    setState(prev => ({
      ...prev,
      windows: prev.windows.map(w =>
        w.id === windowId
          ? { ...w, isMinimized: true }
          : w
      ),
      activeWindowId: null
    }));
  };

  const restoreWindow = (windowId: string) => {
    setState(prev => ({
      ...prev,
      windows: prev.windows.map(w =>
        w.id === windowId
          ? { ...w, isMinimized: false }
          : w
      ),
      activeWindowId: windowId
    }));
  };

  const toggleFullscreen = (windowId: string) => {
    setState(prev => ({
      ...prev,
      windows: prev.windows.map(w =>
        w.id === windowId
          ? { ...w, isFullscreen: !w.isFullscreen }
          : w
      ),
      activeWindowId: windowId
    }));
  };

  const focusWindow = (windowId: string) => {
    setState(prev => ({
      ...prev,
      activeWindowId: windowId,
      windows: prev.windows.map(w =>
        w.id === windowId
          ? { ...w, zIndex: prev.nextZIndex }
          : w
      ),
      nextZIndex: prev.nextZIndex + 1
    }));

    // Emit event after state update completes
    setTimeout(() => {
      try {
        eventBus.emit('window:focused', { windowId });
      } catch {}
    }, 0);
  };

  const updateWindowPosition = (windowId: string, x: number, y: number) => {
    // Use requestAnimationFrame to batch position updates
    requestAnimationFrame(() => {
      setState(prev => ({
        ...prev,
        windows: prev.windows.map(w =>
          w.id === windowId
            ? { ...w, x, y }
            : w
        )
      }));

      // Emit event for real-time connection updates (throttled)
      setTimeout(() => {
        try {
          eventBus.emit('window:position_changed', { windowId, x, y });
        } catch {}
      }, 0);
    });
  };

  // Connections feature removed per decision

  useImperativeHandle(ref, () => ({
    openWindow,
    closeWindow,
    minimizeWindow,
    restoreWindow,
    toggleFullscreen,
    getWindows: () => state.windows,
    organizeWindows
  }));

  useEffect(() => {
    if (onWindowsChange) {
      onWindowsChange(state.windows);
    }
  }, [state.windows, onWindowsChange]);

  // Defer window open/close side-effects to after render commit
  // to avoid cross-component state updates during render.
  const prevWindowsRef = useRef<WindowData[] | null>(null);

  useEffect(() => {
    const prevWindows = prevWindowsRef.current || undefined;
    const currWindows = state.windows;

    const prevIds = new Set((prevWindows || []).map(w => w.id));
    const currIds = new Set(currWindows.map(w => w.id));

    // Newly opened windows (logs muted)
    currWindows.forEach(w => {
      if (!prevIds.has(w.id)) {
        try {
          eventBus.emit('window:opened', { id: w.id, type: 'ui', title: w.title });
        } catch {}
      }
    });

    // Closed windows
    if (prevWindows) {
      prevWindows.forEach(w => {
        if (!currIds.has(w.id)) {
          try {
            eventBus.emit('window:closed', { windowId: w.id });
          } catch {}
        }
      });
    }

    prevWindowsRef.current = currWindows;
  }, [state.windows]);

  useEffect(() => {
    const unsubs = [
      eventBus.on('ui:open_window', (data: { id?: string; title?: string; content?: string; position?: { x?: number; y?: number }; size?: { width?: number; height?: number } }) => {
        const id = data?.id || `win_${Date.now()}`;
        const title = data?.title || 'Window';
        openWindow({
          id,
          title,
          content: String(data?.content || ''),
          component: () => (
            <div className="p-4 text-cyan-200 text-sm whitespace-pre-wrap">{String(data?.content || '')}</div>
          ),
          isMinimized: false,
          isFullscreen: false,
          x: 0,
          y: 0,
          width: data?.size?.width ?? 500,
          height: data?.size?.height ?? 400
        });
      }),
      eventBus.on('ui:close_window', (data: { windowId?: string }) => {
        if (data?.windowId) {
          closeWindow(data.windowId);
        }
      }),
      eventBus.on('window:content_changed', (data: { windowId: string; content: string; title?: string }) => {
        setState(prev => ({
          ...prev,
          windows: prev.windows.map(w =>
            w.id === data.windowId
              ? { ...w, content: data.content, title: data.title || w.title }
              : w
          )
        }));

      })
    ];
    return () => { unsubs.forEach((u) => u()); };
  }, []);

  return (
    <div 
      className="relative w-full h-full"
      onClick={() => setState(prev => ({ ...prev, activeWindowId: null }))}
    >
      {/* Desktop Background */}
      <div className="absolute inset-0 bg-gradient-to-br from-indigo-600 via-purple-600 to-pink-600">
        <div className="absolute inset-0 bg-gradient-to-tr from-blue-500/20 via-transparent to-cyan-300/20"></div>
        <div className="absolute inset-0 bg-[radial-gradient(circle_at_30%_20%,rgba(120,119,198,0.3),transparent_50%)]"></div>
        <div className="absolute inset-0 bg-[radial-gradient(circle_at_70%_80%,rgba(255,119,198,0.2),transparent_50%)]"></div>
        {children}
      </div>

      {/* Connections feature removed */}

      {/* Render Windows */}
      {state.windows.map(window => {
        const WindowComponent = window.component;
        return (
          <Window
            key={window.id}
            id={window.id}
            title={window.title}
            initialX={window.x}
            initialY={window.y}
            width={window.width}
            height={window.height}
            headerStyle={window.id.startsWith('image-viewer-') ? 'minimal' : 'standard'}
            lockAspectRatio={window.id.startsWith('image-viewer-')}
            resizable
            isActive={state.activeWindowId === window.id}
            isMinimized={window.isMinimized}
            isFullscreen={window.isFullscreen}
            zIndex={window.zIndex}
            onClose={() => closeWindow(window.id)}
            onMinimize={() => minimizeWindow(window.id)}
            onRestore={() => restoreWindow(window.id)}
            onFullscreen={() => toggleFullscreen(window.id)}
            onFocus={() => focusWindow(window.id)}
            onPositionChange={updateWindowPosition}
            animationState={window.animationState}
          >
            <WindowComponent />
          </Window>
        );
      })}
    </div>
  );
});
</file>

<file path="src/ui/MainUI.tsx">
'use client';

import { useEffect, useRef, useState } from 'react';
import { aiManager } from '@/ai';
import { inputManager, VoiceTaskListener } from '@/input';
import { eventBus } from '@/lib/eventBus';
import { WindowManager, WindowManagerRef } from './components/windowManager';
import { InputWindow } from './components/inputWindow';
import { AIWindow } from './components/aiWindow';
import { UserNotes } from './components/userNotes';
import { SystemOutput } from './components/systemOutput';
import { GraphWindow } from './components/graphWindow';
import { BarGraphWindow } from './components/barGraphWindow';
import { PieChartWindow } from './components/pieChart';
import { AnimatedBackground } from './components/background';
import { ImageDropZone } from './components/imageDropZone';
import { ImageViewer } from './components/imageViewer';
import { DebugSidebar } from './components/debugSidebar';

export function MainUI() {
  const windowManagerRef = useRef<WindowManagerRef>(null);
  const [inputStatus, setInputStatus] = useState<'idle' | 'listening' | 'processing' | 'error'>('idle');
  const [aiStatus, setAiStatus] = useState<'idle' | 'processing' | 'ready' | 'error'>('idle');
  const [openWindows, setOpenWindows] = useState<Set<string>>(new Set());
  const [minimizedWindows, setMinimizedWindows] = useState<Set<string>>(new Set());
  const [isImageDropMinimized, setIsImageDropMinimized] = useState(false);
  const [isDesktopMinimized, setIsDesktopMinimized] = useState(false);
  const [showDebugSidebar, setShowDebugSidebar] = useState(false);

  useEffect(() => {
    aiManager.initialize();
    inputManager.initialize();

    const unsubs = [
      eventBus.on('input:initialized', () => setInputStatus('idle')),
      eventBus.on('speech:started', () => setInputStatus('listening')),
      eventBus.on('speech:ended', () => setInputStatus('idle')),
      eventBus.on('input:voice_debug', (d: { status?: string; apiCallsUsedLastMinute?: number; nextCallInMs?: number }) => {
        setInputStatus((d?.status as 'idle' | 'listening' | 'processing' | 'error') || 'idle');
      }),
      eventBus.on('ai:initialized', () => setAiStatus('ready')),
      eventBus.on('ai:processing', () => setAiStatus('processing')),
      eventBus.on('ai:ai_tasks_executed', () => setAiStatus('ready')),
      eventBus.on('ai:text_command_processed', () => setAiStatus('ready')),
      eventBus.on('ai:ai_response_generated', () => setAiStatus('ready')),
      eventBus.on('ai:error', () => setAiStatus('error')),
      eventBus.on('window:opened', (data: { id?: string }) => {
        if (typeof data?.id === 'string') {
          setOpenWindows(prev => new Set<string>([...prev, data.id as string]));
        }
      }),
      eventBus.on('window:closed', (data: { windowId?: string }) => {
        if (typeof data?.windowId === 'string') {
          const id = data.windowId as string;
          setOpenWindows(prev => {
            const newSet = new Set(prev);
            newSet.delete(id);
            return newSet;
          });
          setMinimizedWindows(prev => {
            const newSet = new Set(prev);
            newSet.delete(id);
            return newSet;
          });
        }
      })
    ];
    return () => { unsubs.forEach(u => u()); };
  }, []);

  const toggleMinimize = (windowId: string) => {
    const isMinimized = minimizedWindows.has(windowId);
    if (isMinimized) {
      windowManagerRef.current?.restoreWindow(windowId);
      setMinimizedWindows(prev => {
        const newSet = new Set(prev);
        newSet.delete(windowId);
        return newSet;
      });
    } else {
      windowManagerRef.current?.minimizeWindow(windowId);
      setMinimizedWindows(prev => new Set([...prev, windowId]));
    }
  };

  const openInputWindow = () => {
    windowManagerRef.current?.openWindow({
      id: 'input-window',
      title: 'Input Manager',
      component: InputWindow,
      isFullscreen: false,
      isMinimized: false,
      x: 0,
      y: 0,
      width: 500,
      height: 400
    });
  };

  const openAIWindow = () => {
    windowManagerRef.current?.openWindow({
      id: 'ai-window',
      title: 'AI Manager',
      component: AIWindow,
      isFullscreen: false,
      isMinimized: false,
      x: 0,
      y: 0,
      width: 500,
      height: 400
    });
  };

  const openUserNotesWindow = () => {
    const windowId = `user-notes-window-${Date.now()}`;
    windowManagerRef.current?.openWindow({
      id: windowId,
      title: 'New Note',
      component: () => <UserNotes windowId={windowId} />,
      content: 'This is a new note',
      isFullscreen: false,
      isMinimized: false,
      x: 0,
      y: 0,
      width: 600,
      height: 320
    });
  };

  const openSystemOutputWindow = () => {
    windowManagerRef.current?.openWindow({
      id: 'system-output-window',
      title: 'System Output',
      component: SystemOutput,
      isFullscreen: false,
      isMinimized: false,
      x: 0,
      y: 0,
      width: 700,
      height: 350
    });
  };

  const findOptimalWindowPosition = (windowWidth: number, windowHeight: number) => {
    const screenWidth = window.innerWidth;
    const screenHeight = window.innerHeight;
    const padding = 20;
    const minGap = 40;
    
    // Simple restriction: right edge cannot exceed 95% to the left (5% reserved for image drop)
    const maxRightEdge = screenWidth * 0.95;
    const maxAllowedX = maxRightEdge - windowWidth;
    
    const existingWindows = windowManagerRef.current?.getWindows?.() || [];
    
    const isPositionAvailable = (x: number, y: number) => {
      // Check if window would go off screen
      if (x + windowWidth > screenWidth - padding || y + windowHeight > screenHeight - padding) {
        return false;
      }
      
      // Check if right edge exceeds 95% restriction
      if (x + windowWidth > maxRightEdge) {
        return false;
      }
      
      // Check for overlaps with existing windows
      return !existingWindows.some(window => {
        const windowX = window.x || 0;
        const windowY = window.y || 0;
        const windowW = window.width || 0;
        const windowH = window.height || 0;
        
        return !(x >= windowX + windowW + minGap || 
                x + windowWidth <= windowX - minGap || 
                y >= windowY + windowH + minGap || 
                y + windowHeight <= windowY - minGap);
      });
    };
    
    // STRICT TOP-LEFT PRIORITY: Scan from top-left, row by row
    for (let y = padding; y + windowHeight <= screenHeight - padding; y += 15) {
      for (let x = padding; x <= maxAllowedX; x += 15) {
        if (isPositionAvailable(x, y)) {
          return { x, y };
        }
      }
    }
    
    // Fallback to top-left if no space found (instead of center)
    return {
      x: padding,
      y: padding
    };
  };

  const openImageViewerWindow = (imageUrl: string, imageName: string) => {
    const windowId = `image-viewer-${Date.now()}`;

    const img = new Image();
    img.onload = () => {
      const screenWidth = window.innerWidth;
      const screenHeight = window.innerHeight;
      const aspectRatio = img.width / img.height;
      
      // Get existing windows to determine if this is the first or subsequent
      const existingWindows = windowManagerRef.current?.getWindows?.() || [];
      const isFirstWindow = existingWindows.length === 0;
      
      let width, height;
      
        // All windows: Use area-based constraints only
        const screenArea = screenWidth * screenHeight;
        const minArea = screenArea * 0.1; // 10% of screen area
        const maxArea = screenArea * 0.25; // 25% of screen area
        
        let targetArea;
        if (isFirstWindow) {
          // First window: Use maximum area (no packing logic needed)
          targetArea = maxArea;
        } else {
          // Subsequent windows: Calculate optimal packing area by analyzing available space
          const padding = 20;
          const minGap = 40;
          const availableWidth = screenWidth * 0.95 - padding * 2; // 95% minus padding
          const availableHeight = screenHeight - padding * 2;
          
          // Find the largest available rectangular area for optimal packing
          let bestFitArea = minArea; // Start with minimum
          let bestWidth = 0;
          let bestHeight = 0;
          
          // Test different sizes within the min/max area constraints, starting from max and working down
          for (let testArea = maxArea; testArea >= minArea; testArea -= (maxArea - minArea) / 20) {
            // Calculate dimensions for this test area maintaining aspect ratio
            let testWidth, testHeight;
            if (aspectRatio > 1) {
              testWidth = Math.sqrt(testArea * aspectRatio);
              testHeight = Math.sqrt(testArea / aspectRatio);
            } else {
              testHeight = Math.sqrt(testArea / aspectRatio);
              testWidth = Math.sqrt(testArea * aspectRatio);
            }
            
            // Check if this size can fit in available space with optimal positioning
            let canFit = false;
            
            // Try positions starting from top-left, scanning systematically (prioritize top-left and tight packing)
            let bestPosition = null;
            let bestScore = Infinity; // Lower score = better position (closer to existing windows)
            
            for (let y = padding; y + testHeight + padding <= screenHeight; y += 15) {
              for (let x = padding; x + testWidth + padding <= availableWidth + padding * 2; x += 15) {
                // Check if this position overlaps with existing windows
                const wouldOverlap = existingWindows.some(win => {
                  const winLeft = win.x || 0;
                  const winTop = win.y || 0;
                  const winRight = winLeft + (win.width || 0);
                  const winBottom = winTop + (win.height || 0);
                  
                  return !(x >= winRight + minGap || 
                          x + testWidth <= winLeft - minGap || 
                          y >= winBottom + minGap || 
                          y + testHeight <= winTop - minGap);
                });
                
                if (!wouldOverlap) {
                  // Calculate a score for this position (prioritize tight packing)
                  let score = 0;
                  
                  // Primary score: distance from top-left (prioritize top-left)
                  score += (x - padding) * 0.1 + (y - padding) * 0.1;
                  
                  // Secondary score: distance to nearest existing window (prioritize tight packing)
                  if (existingWindows.length > 0) {
                    const minDistanceToWindow = Math.min(...existingWindows.map(win => {
                      const winCenterX = (win.x || 0) + (win.width || 0) / 2;
                      const winCenterY = (win.y || 0) + (win.height || 0) / 2;
                      const testCenterX = x + testWidth / 2;
                      const testCenterY = y + testHeight / 2;
                      return Math.sqrt(Math.pow(testCenterX - winCenterX, 2) + Math.pow(testCenterY - winCenterY, 2));
                    }));
                    score += minDistanceToWindow * 0.5; // Penalize positions far from existing windows
                  }
                  
                  // Check for adjacent placement bonus (reward positions next to existing windows)
                  const isAdjacentToWindow = existingWindows.some(win => {
                    const winLeft = win.x || 0;
                    const winTop = win.y || 0;
                    const winRight = winLeft + (win.width || 0);
                    const winBottom = winTop + (win.height || 0);
                    
                    // Check if this position is adjacent (within minGap) to any existing window
                    return (
                      // Adjacent horizontally
                      (Math.abs(x - winRight) <= minGap + 5 && !(y + testHeight <= winTop || y >= winBottom)) ||
                      (Math.abs(x + testWidth - winLeft) <= minGap + 5 && !(y + testHeight <= winTop || y >= winBottom)) ||
                      // Adjacent vertically  
                      (Math.abs(y - winBottom) <= minGap + 5 && !(x + testWidth <= winLeft || x >= winRight)) ||
                      (Math.abs(y + testHeight - winTop) <= minGap + 5 && !(x + testWidth <= winLeft || x >= winRight))
                    );
                  });
                  
                  if (isAdjacentToWindow) {
                    score -= 100; // Big bonus for adjacent placement
                  }
                  
                  if (score < bestScore) {
                    bestScore = score;
                    bestPosition = { x, y };
                  }
                  
                  canFit = true;
                }
              }
            }
            
            // Use the best position found (if any)
            if (bestPosition) {
              canFit = true;
            }
            
            // If this size fits and is larger than our current best, use it
            if (canFit && testArea > bestFitArea) {
              bestFitArea = testArea;
              bestWidth = testWidth;
              bestHeight = testHeight;
              // Since we're testing from largest to smallest, first fit is optimal
              break;
            }
          }
          
          // Use the optimal fit area, or fall back to minimum if nothing fits well
          targetArea = bestFitArea;
        }
        
        // Calculate dimensions from target area while maintaining aspect ratio
        if (aspectRatio > 1) {
          // Landscape: width = sqrt(area * aspectRatio), height = sqrt(area / aspectRatio)
          width = Math.sqrt(targetArea * aspectRatio);
          height = Math.sqrt(targetArea / aspectRatio);
        } else {
          // Portrait: height = sqrt(area / aspectRatio), width = sqrt(area * aspectRatio)
          height = Math.sqrt(targetArea / aspectRatio);
          width = Math.sqrt(targetArea * aspectRatio);
        }
        
        // Ensure the area is within bounds
        const currentArea = width * height;
        if (currentArea < minArea) {
          // Scale up to minimum area
          const scaleFactor = Math.sqrt(minArea / currentArea);
          width *= scaleFactor;
          height *= scaleFactor;
        } else if (currentArea > maxArea) {
          // Scale down to maximum area
          const scaleFactor = Math.sqrt(maxArea / currentArea);
          width *= scaleFactor;
          height *= scaleFactor;
        }
        
        // Ensure we don't exceed screen bounds (fallback protection)
        const maxScreenWidth = screenWidth * 0.95;
        const maxScreenHeight = screenHeight;
        if (width > maxScreenWidth) {
          width = maxScreenWidth;
          height = width / aspectRatio;
          // Recalculate to ensure we stay within area bounds
          const newArea = width * height;
          if (newArea > maxArea) {
            const areaScaleFactor = Math.sqrt(maxArea / newArea);
            width *= areaScaleFactor;
            height *= areaScaleFactor;
          }
        }
        if (height > maxScreenHeight) {
          height = maxScreenHeight;
          width = height * aspectRatio;
          // Recalculate to ensure we stay within area bounds
          const newArea = width * height;
          if (newArea > maxArea) {
            const areaScaleFactor = Math.sqrt(maxArea / newArea);
            width *= areaScaleFactor;
            height *= areaScaleFactor;
          }
        }

      const position = findOptimalWindowPosition(Math.round(width), Math.round(height));

      windowManagerRef.current?.openWindow({
        id: windowId,
        title: `Image: ${imageName}`,
        component: () => <ImageViewer imageUrl={imageUrl} imageName={imageName} windowId={windowId} />,
        isFullscreen: false,
        isMinimized: false,
        x: position.x,
        y: position.y,
        width: Math.round(width),
        height: Math.round(height),
        imageUrl: imageUrl
      });
    };
    img.src = imageUrl;
  };

  const handleImageUpload = (imageUrl: string, imageName: string) => {
    openImageViewerWindow(imageUrl, imageName);
  };

  const handleMultipleImageUpload = (images: { url: string; name: string }[]) => {
    images.forEach((image, index) => {
      setTimeout(() => {
        openImageViewerWindow(image.url, image.name);
      }, index * 150);
    });
  };

  const openGraphWindow = () => {
    windowManagerRef.current?.openWindow({
      id: 'graph-window',
      title: 'Line Graph',
      component: GraphWindow,
      isFullscreen: false,
      isMinimized: false,
      x: 0,
      y: 0,
      width: 850,
      height: 650
    });
  };

  const openBarGraphWindow = () => {
    windowManagerRef.current?.openWindow({
      id: 'bar-graph-window',
      title: 'Bar Graph',
      component: BarGraphWindow,
      isFullscreen: false,
      isMinimized: false,
      x: 0,
      y: 0,
      width: 850,
      height: 650
    });
  };

  const openPieChartWindow = () => {
    windowManagerRef.current?.openWindow({
      id: 'pie-chart-window',
      title: 'Pie Chart',
      component: PieChartWindow,
      isFullscreen: false,
      isMinimized: false,
      x: 0,
      y: 0,
      width: 900,
      height: 700
    });
  };

  const openPreloadedImageWindow = () => {
    const preloadedImageUrl = 'https://picsum.photos/600/400?random=1';
    const imageName = 'Sample Image';
    openImageViewerWindow(preloadedImageUrl, imageName);
  };

  return (
    <div className="min-h-screen">
      {/* Global AI loading indicator */}
      {aiStatus === 'processing' && (
        <div className="fixed top-4 left-1/2 -translate-x-1/2 z-[60]">
          <div className="flex items-center gap-3 px-4 py-2 rounded-full bg-black/60 text-white border border-white/10 shadow-2xl backdrop-blur">
            <svg className="w-4 h-4 animate-spin" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
              <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
              <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8v4a4 4 0 00-4 4H4z"></path>
            </svg>
            <span className="text-sm font-medium">Jarvis is thinking…</span>
          </div>
        </div>
      )}
      <WindowManager
        ref={windowManagerRef}
        onWindowsChange={(windows) => {
          aiManager.setUIContext({ windows });
        }}
      >
        <AnimatedBackground />
        <VoiceTaskListener />

        {showDebugSidebar && (
          <DebugSidebar
            inputStatus={inputStatus}
            aiStatus={aiStatus}
            openInputWindow={openInputWindow}
            openAIWindow={openAIWindow}
            openUserNotesWindow={openUserNotesWindow}
            openSystemOutputWindow={openSystemOutputWindow}
            openGraphWindow={openGraphWindow}
            openBarGraphWindow={openBarGraphWindow}
            openPieChartWindow={openPieChartWindow}
            openPreloadedImageWindow={openPreloadedImageWindow}
          />
         )}
          
         {/* Organize Button - Right Side Middle */}
         <button
           onClick={(e) => {
             e.preventDefault();
             e.stopPropagation();
             // Use setTimeout to ensure we're not in a render cycle
             setTimeout(() => {
               if (windowManagerRef.current?.organizeWindows) {
                 windowManagerRef.current.organizeWindows();
               }
             }, 0);
           }}
           className="fixed right-4 top-1/2 -translate-y-1/2 z-40 w-16 h-16 bg-purple-500/30 backdrop-blur-xl border-2 border-purple-400/50 rounded-2xl text-purple-200 shadow-2xl flex flex-col items-center justify-center transition-all duration-300 hover:scale-110 hover:bg-purple-500/40 group"
           title="Organize Windows - Maximize Area"
         >
           <svg className="w-8 h-8 transition-transform duration-300 group-hover:scale-110" fill="none" stroke="currentColor" viewBox="0 0 24 24">
             <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 6a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2H6a2 2 0 01-2-2V6zM14 6a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2h-2a2 2 0 01-2-2V6zM4 16a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2H6a2 2 0 01-2-2v-2zM14 16a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2h-2a2 2 0 01-2-2v-2z" />
           </svg>
           <span className="text-xs font-medium mt-1 opacity-80 group-hover:opacity-100 transition-opacity">Organize</span>
         </button>

         {/* Image Drop Zone - Fixed Position */}
         <div className="fixed top-4 right-4 z-50">
          {isImageDropMinimized ? (
            /* Collapsed - Circular Icon */
            <button
              onClick={() => setIsImageDropMinimized(false)}
              className="w-16 h-16 bg-white/10 backdrop-blur-xl border border-white/20 rounded-2xl text-white shadow-2xl flex items-center justify-center transition-all duration-300 hover:scale-110 hover:bg-white/20 group"
              title="Open Image Upload"
            >
              <svg className="w-8 h-8 transition-transform duration-300 group-hover:scale-110" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z" />
              </svg>
            </button>
          ) : (
            /* Expanded - Full Drop Zone */
            <div className="bg-white/10 backdrop-blur-xl border border-white/20 rounded-2xl text-white shadow-2xl w-36 h-36 transition-all duration-300">
              <div className="flex items-center justify-between p-3 pb-1">
                <h2 className="text-sm font-semibold break-words">Upload</h2>
                <button
                  onClick={() => setIsImageDropMinimized(true)}
                  className="text-white/70 hover:text-white transition-colors p-1 hover:bg-white/10 rounded-full"
                  title="Collapse"
                >
                  <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M5 15l7-7 7 7" />
                  </svg>
                </button>
              </div>
                <div className="px-6 pb-3">
                  <ImageDropZone 
                    onImageUpload={handleImageUpload} 
                    onMultipleImageUpload={handleMultipleImageUpload}
                  />
                </div>
            </div>
          )}
        </div>

        {/* Debug toggle button - Bottom right */}
        <div className="fixed bottom-4 right-4 z-50">
          <button
            onClick={() => setShowDebugSidebar(v => !v)}
            className="w-12 h-12 bg-black/40 hover:bg-black/60 text-white rounded-full border border-white/20 shadow-xl flex items-center justify-center transition-all duration-200"
            title={showDebugSidebar ? 'Hide Debug Sidebar' : 'Show Debug Sidebar'}
          >
            {/* Bug icon */}
            <svg className="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M8 7V3m8 4V3M3 13h4m10 0h4M5 17l2-2m10 2l-2-2M5 9l2 2m10-2l-2 2M12 6a5 5 0 00-5 5v4a5 5 0 0010 0v-4a5 5 0 00-5-5z" />
            </svg>
          </button>
        </div>

        {/* Desktop Content */}
        <div className="absolute top-6 left-6 z-10">
          {isDesktopMinimized ? (
            /* Minimized - Circular Icon */
            <button
              onClick={() => setIsDesktopMinimized(false)}
              className="w-16 h-16 bg-white/10 backdrop-blur-xl border border-white/20 rounded-full text-white shadow-2xl flex items-center justify-center transition-all duration-300 hover:scale-110 hover:bg-white/20 group"
              title="Open Jarvis Desktop"
            >
              <div className="w-6 h-6 bg-gradient-to-br from-blue-400 to-purple-500 rounded-lg flex items-center justify-center transition-transform duration-300 group-hover:scale-110">
                <div className="w-3 h-3 bg-white rounded-full opacity-80"></div>
              </div>
            </button>
          ) : (
            /* Expanded - Full Desktop */
            <div className="bg-white/10 backdrop-blur-xl border border-white/20 rounded-3xl p-8 text-white shadow-2xl transition-all duration-300">
              <div className="flex items-center justify-between mb-6">
                <div className="flex items-center">
                  <div className="w-8 h-8 bg-gradient-to-br from-blue-400 to-purple-500 rounded-xl mr-3 flex items-center justify-center">
                    <div className="w-4 h-4 bg-white rounded-full opacity-80"></div>
                  </div>
                  <h1 className="text-3xl font-bold bg-gradient-to-r from-white to-blue-200 bg-clip-text text-transparent">
                    Jarvis Desktop
                  </h1>
                </div>
                <button
                  onClick={() => setIsDesktopMinimized(true)}
                  className="text-white/70 hover:text-white transition-colors p-1 hover:bg-white/10 rounded-full"
                  title="Minimize"
                >
                  <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M5 15l7-7 7 7" />
                  </svg>
                </button>
              </div>
            <div className="space-y-3">
              <div className="flex items-center gap-2">
                <button
                  onClick={openInputWindow}
                  className="group flex-1 px-6 py-4 bg-gradient-to-r from-blue-500/60 to-indigo-600/60 hover:from-blue-500/80 hover:to-indigo-600/80 rounded-2xl transition-all duration-300 transform hover:scale-105 hover:shadow-xl backdrop-blur-sm border border-white/10"
                >
                  <div className="flex items-center">
                    <div className="w-3 h-3 bg-blue-400 rounded-full mr-3 group-hover:animate-pulse"></div>
                    <span className="font-semibold">Open Input Window</span>
                  </div>
                </button>
                {openWindows.has('input-window') && (
                  <button
                    onClick={() => toggleMinimize('input-window')}
                    className="px-3 py-4 bg-blue-500/40 hover:bg-blue-500/60 rounded-xl transition-all duration-200 border border-white/10"
                    title={minimizedWindows.has('input-window') ? 'Restore' : 'Minimize'}
                  >
                    <span className="text-sm font-bold">{minimizedWindows.has('input-window') ? '+' : '−'}</span>
                  </button>
                )}
              </div>
              <div className="flex items-center gap-2">
                <button
                  onClick={openAIWindow}
                  className="group flex-1 px-6 py-4 bg-gradient-to-r from-emerald-500/60 to-green-600/60 hover:from-emerald-500/80 hover:to-green-600/80 rounded-2xl transition-all duration-300 transform hover:scale-105 hover:shadow-xl backdrop-blur-sm border border-white/10"
                >
                  <div className="flex items-center">
                    <div className="w-3 h-3 bg-emerald-400 rounded-full mr-3 group-hover:animate-pulse"></div>
                    <span className="font-semibold">Open AI Window</span>
                  </div>
                </button>
                {openWindows.has('ai-window') && (
                  <button
                    onClick={() => toggleMinimize('ai-window')}
                    className="px-3 py-4 bg-emerald-500/40 hover:bg-emerald-500/60 rounded-xl transition-all duration-200 border border-white/10"
                    title={minimizedWindows.has('ai-window') ? 'Restore' : 'Minimize'}
                  >
                    <span className="text-sm font-bold">{minimizedWindows.has('ai-window') ? '+' : '−'}</span>
                  </button>
                )}
              </div>
              <div className="flex items-center gap-2">
                <button
                  onClick={openUserNotesWindow}
                  className="group flex-1 px-6 py-4 bg-gradient-to-r from-blue-500/60 to-indigo-600/60 hover:from-blue-500/80 hover:to-indigo-600/80 rounded-2xl transition-all duration-300 transform hover:scale-105 hover:shadow-xl backdrop-blur-sm border border-white/10"
                >
                  <div className="flex items-center">
                    <div className="w-3 h-3 bg-blue-400 rounded-full mr-3 group-hover:animate-pulse"></div>
                    <span className="font-semibold">Open Personal Notes</span>
                  </div>
                </button>
                {openWindows.has('user-notes-window') && (
                  <button
                    onClick={() => toggleMinimize('user-notes-window')}
                    className="px-3 py-4 bg-blue-500/40 hover:bg-blue-500/60 rounded-xl transition-all duration-200 border border-white/10"
                    title={minimizedWindows.has('user-notes-window') ? 'Restore' : 'Minimize'}
                  >
                    <span className="text-sm font-bold">{minimizedWindows.has('user-notes-window') ? '+' : '−'}</span>
                  </button>
                )}
              </div>
              <div className="flex items-center gap-2">
                <button
                  onClick={openSystemOutputWindow}
                  className="group flex-1 px-6 py-4 bg-gradient-to-r from-green-500/60 to-emerald-600/60 hover:from-green-500/80 hover:to-emerald-600/80 rounded-2xl transition-all duration-300 transform hover:scale-105 hover:shadow-xl backdrop-blur-sm border border-white/10"
                >
                  <div className="flex items-center">
                    <div className="w-3 h-3 bg-green-400 rounded-full mr-3 group-hover:animate-pulse"></div>
                    <span className="font-semibold">Open System Output</span>
                  </div>
                </button>
                {openWindows.has('system-output-window') && (
                  <button
                    onClick={() => toggleMinimize('system-output-window')}
                    className="px-3 py-4 bg-green-500/40 hover:bg-green-500/60 rounded-xl transition-all duration-200 border border-white/10"
                    title={minimizedWindows.has('system-output-window') ? 'Restore' : 'Minimize'}
                  >
                    <span className="text-sm font-bold">{minimizedWindows.has('system-output-window') ? '+' : '−'}</span>
                  </button>
                )}
              </div>
              <div className="flex items-center gap-2">
                <button
                  onClick={openGraphWindow}
                  className="group flex-1 px-6 py-4 bg-gradient-to-r from-purple-500/60 to-pink-600/60 hover:from-purple-500/80 hover:to-pink-600/80 rounded-2xl transition-all duration-300 transform hover:scale-105 hover:shadow-xl backdrop-blur-sm border border-white/10"
                >
                  <div className="flex items-center">
                    <div className="w-3 h-3 bg-purple-400 rounded-full mr-3 group-hover:animate-pulse"></div>
                    <span className="font-semibold">Open Line Graph</span>
                  </div>
                </button>
                {openWindows.has('graph-window') && (
                  <button
                    onClick={() => toggleMinimize('graph-window')}
                    className="px-3 py-4 bg-purple-500/40 hover:bg-purple-500/60 rounded-xl transition-all duration-200 border border-white/10"
                    title={minimizedWindows.has('graph-window') ? 'Restore' : 'Minimize'}
                  >
                    <span className="text-sm font-bold">{minimizedWindows.has('graph-window') ? '+' : '−'}</span>
                  </button>
                )}
              </div>
              <div className="flex items-center gap-2">
                <button
                  onClick={openBarGraphWindow}
                  className="group flex-1 px-6 py-4 bg-gradient-to-r from-orange-500/60 to-red-600/60 hover:from-orange-500/80 hover:to-red-600/80 rounded-2xl transition-all duration-300 transform hover:scale-105 hover:shadow-xl backdrop-blur-sm border border-white/10"
                >
                  <div className="flex items-center">
                    <div className="w-3 h-3 bg-orange-400 rounded-full mr-3 group-hover:animate-pulse"></div>
                    <span className="font-semibold">Open Bar Graph</span>
                  </div>
                </button>
                {openWindows.has('bar-graph-window') && (
                  <button
                    onClick={() => toggleMinimize('bar-graph-window')}
                    className="px-3 py-4 bg-orange-500/40 hover:bg-orange-500/60 rounded-xl transition-all duration-200 border border-white/10"
                    title={minimizedWindows.has('bar-graph-window') ? 'Restore' : 'Minimize'}
                  >
                    <span className="text-sm font-bold">{minimizedWindows.has('bar-graph-window') ? '+' : '−'}</span>
                  </button>
                )}
              </div>
              <div className="flex items-center gap-2">
                <button
                  onClick={openPieChartWindow}
                  className="group flex-1 px-6 py-4 bg-gradient-to-r from-pink-500/60 to-purple-600/60 hover:from-pink-500/80 hover:to-purple-600/80 rounded-2xl transition-all duration-300 transform hover:scale-105 hover:shadow-xl backdrop-blur-sm border border-white/10"
                >
                  <div className="flex items-center">
                    <div className="w-3 h-3 bg-pink-400 rounded-full mr-3 group-hover:animate-pulse"></div>
                    <span className="font-semibold">Open Pie Chart</span>
                  </div>
                </button>
                {openWindows.has('pie-chart-window') && (
                  <button
                    onClick={() => toggleMinimize('pie-chart-window')}
                    className="px-3 py-4 bg-pink-500/40 hover:bg-pink-500/60 rounded-xl transition-all duration-200 border border-white/10"
                    title={minimizedWindows.has('pie-chart-window') ? 'Restore' : 'Minimize'}
                  >
                    <span className="text-sm font-bold">{minimizedWindows.has('pie-chart-window') ? '+' : '−'}</span>
                  </button>
                )}
              </div>
              <button
                onClick={openPreloadedImageWindow}
                className="group block w-full px-6 py-4 bg-gradient-to-r from-teal-500/60 to-cyan-600/60 hover:from-teal-500/80 hover:to-cyan-600/80 rounded-2xl transition-all duration-300 transform hover:scale-105 hover:shadow-xl backdrop-blur-sm border border-white/10"
              >
                <div className="flex items-center">
                  <div className="w-3 h-3 bg-teal-400 rounded-full mr-3 group-hover:animate-pulse"></div>
                  <span className="font-semibold">Open Sample Image</span>
                </div>
              </button>
            </div>
            </div>
          )}
        </div>
      </WindowManager>
    </div>
  );
}
</file>

</files>
