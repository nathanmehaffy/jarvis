This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
public/
  file.svg
  globe.svg
  next.svg
  vercel.svg
  window.svg
src/
  ai/
    AIManager.ts
    aiWorker.ts
    cerebrasClient.ts
    geminiSearchClient.ts
    index.ts
    README.md
    taskParser.ts
    taskParser.ts.backup
    tester.ts
    toolExecutor.ts
    tools.ts
    types.ts
    windowRegistry.ts
  app/
    api/
      cerebras-tasks/
        route.ts
      fetch-article/
        route.ts
      proxy-page/
        route.ts
      web-search/
        route.ts
    globals.css
    layout.tsx
    page.tsx
  input/
    index.ts
    InputManager.ts
    inputWorker.ts
    speechService.ts
    SpeechTranscriptionProvider.tsx
    useSpeechTranscription.ts
    VoiceTaskListener.tsx
  lib/
    eventBus.ts
  ui/
    components/
      aiWindow/
        AIWindow.tsx
        index.ts
      background/
        AnimatedBackground.tsx
        index.ts
      barGraph/
        BarGraph.tsx
        barGraph.types.ts
        index.ts
      barGraphWindow/
        BarGraphWindow.tsx
        index.ts
      debugSidebar/
        DebugSidebar.tsx
        index.ts
      graphWindow/
        GraphWindow.tsx
        index.ts
      imageDropZone/
        ImageDropZone.tsx
        index.ts
      imageViewer/
        ImageViewer.tsx
        index.ts
      inputWindow/
        index.ts
        InputWindow.tsx
      lineGraph/
        index.ts
        LineGraph.tsx
        lineGraph.types.ts
      pieChart/
        index.ts
        PieChart.tsx
        pieChart.types.ts
        PieChartWindow.tsx
      systemOutput/
        index.ts
        SystemOutput.tsx
        systemOutput.types.ts
      textOutput/
        index.ts
        TextOutput.tsx
        textOutput.types.ts
      userNotes/
        index.ts
        UserNotes.tsx
        userNotes.types.ts
      window/
        index.ts
        Window.tsx
        window.types.ts
      windowManager/
        index.ts
        WindowManager.tsx
        windowManager.types.ts
      README.md
    index.ts
    MainUI.tsx
.gitignore
add_gemini_search.js
debug_commands.js
eslint.config.mjs
GEMINI_SETUP.md
implement_web_search.js
install_gemini_package.js
next.config.ts
package.json
postcss.config.mjs
PROJECT_STRUCTURE.md
README.md
test_debug.js
tsconfig.json
update_cerebras_prompt.js
update_task_parser.js
update_tool_executor.js
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="src/app/api/fetch-article/route.ts">
import { NextRequest } from 'next/server';

export const dynamic = 'force-dynamic';

export async function POST(request: NextRequest) {
  try {
    const body = await request.json().catch(() => ({}));
    const url: string | undefined = body?.url;
    const mode: 'full' | 'head' = body?.mode === 'head' ? 'head' : 'full';
    if (!url || !/^https?:\/\//i.test(url)) {
      return new Response(JSON.stringify({ error: 'Valid url is required' }), { status: 400, headers: { 'Content-Type': 'application/json' } });
    }

    let html: string;
    let finalUrl = url;
    let xfo: string | null = null;
    let csp: string | null = null;
    try {
      const resp = await fetch(url, {
        headers: {
          'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/124.0.0.0 Safari/537.36',
          'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8',
          'Accept-Language': 'en-US,en;q=0.9'
        },
        // Avoid following too many redirects which can lead to blockers
        redirect: 'follow' as RequestRedirect
      });
      if (!resp.ok) throw new Error(`Fetch HTTP ${resp.status}`);
      finalUrl = (resp as any).url || url;
      xfo = resp.headers.get('x-frame-options');
      csp = resp.headers.get('content-security-policy');
      html = await resp.text();
    } catch (e) {
      const msg = e instanceof Error ? e.message : String(e);
      return new Response(JSON.stringify({ error: `Failed to fetch url: ${msg}` }), { status: 502, headers: { 'Content-Type': 'application/json' } });
    }

    // Detect likely iframe blocking
    const embeddingBlocked = (() => {
      try {
        if (xfo && /deny|sameorigin/i.test(xfo)) return true;
        if (csp && /frame-ancestors/i.test(csp)) {
          // If frame-ancestors is present but does not include * or http(s), assume blocked
          const fa = /frame-ancestors\s+([^;]+)/i.exec(csp)?.[1] || '';
          if (fa && !/\*|https?:/i.test(fa)) return true;
        }
      } catch {}
      return false;
    })();

    if (mode === 'head') {
      return new Response(JSON.stringify({ url: finalUrl, embeddingBlocked, xFrameOptions: xfo, csp }), { status: 200, headers: { 'Content-Type': 'application/json' } });
    }

    // Lazy import to keep cold start small
    const { JSDOM } = await import('jsdom');
    const { Readability } = await import('@mozilla/readability');

    try {
      const dom = new JSDOM(html, { url });
      const doc = dom.window.document;

      // Remove script/style to reduce noise
      doc.querySelectorAll('script, style, noscript').forEach(el => el.remove());

      const reader = new Readability(doc);
      const article = reader.parse();

      if (!article) {
        return new Response(JSON.stringify({ error: 'Could not extract article content' }), { status: 422, headers: { 'Content-Type': 'application/json' } });
      }

      // Return both text and html; clients can choose safe rendering
      return new Response(JSON.stringify({
        url: finalUrl,
        title: article.title || '',
        byline: article.byline || '',
        textContent: article.textContent || '',
        content: article.content || '',
        embeddingBlocked,
        xFrameOptions: xfo,
        csp
      }), { status: 200, headers: { 'Content-Type': 'application/json' } });
    } catch (e) {
      const msg = e instanceof Error ? e.message : String(e);
      return new Response(JSON.stringify({ error: `Failed to parse article: ${msg}` }), { status: 500, headers: { 'Content-Type': 'application/json' } });
    }
  } catch (e) {
    const msg = e instanceof Error ? e.message : String(e);
    return new Response(JSON.stringify({ error: msg }), { status: 500, headers: { 'Content-Type': 'application/json' } });
  }
}
</file>

<file path="src/app/api/proxy-page/route.ts">
import { NextRequest } from 'next/server';

export const runtime = 'nodejs';
export const dynamic = 'force-dynamic';

// Very simple proxy-render: fetches the target URL server-side and returns a sanitized HTML
// snapshot that we can iframe from our own origin. Scripts and inline event handlers are removed
// for safety. We add a <base> tag so relative links resolve correctly.
export async function GET(request: NextRequest) {
  try {
    const urlObj = new URL(request.url);
    const target = urlObj.searchParams.get('url');
    if (!target || !/^https?:\/\//i.test(target)) {
      return new Response('Missing or invalid url', { status: 400 });
    }

    const enableScripts = urlObj.searchParams.get('scripts') === '1';

    let html: string;
    try {
      const resp = await fetch(target, {
        headers: {
          'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/124.0.0.0 Safari/537.36',
          'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8',
          'Accept-Language': 'en-US,en;q=0.9'
        },
        redirect: 'follow' as RequestRedirect
      });
      if (!resp.ok) {
        return new Response(`Upstream HTTP ${resp.status}`, { status: 502 });
      }
      html = await resp.text();
    } catch (e) {
      const msg = e instanceof Error ? e.message : String(e);
      return new Response(`Failed to fetch url: ${msg}`, { status: 502 });
    }

    // Lazy import to keep cold starts smaller
    const { JSDOM } = await import('jsdom');

    try {
      const dom = new JSDOM(html);
      const doc = dom.window.document;

      // Ensure a base tag so relative URLs resolve against the original site
      const head = doc.querySelector('head') || doc.createElement('head');
      if (!doc.querySelector('head')) doc.documentElement.insertBefore(head, doc.body || null);
      let base = head.querySelector('base');
      if (!base) {
        base = doc.createElement('base');
        base.setAttribute('href', target);
        head.insertBefore(base, head.firstChild);
      } else if (!base.getAttribute('href')) {
        base.setAttribute('href', target);
      }

      // Remove CSP meta tags that might block rendering inside our iframe snapshot
      head.querySelectorAll('meta[http-equiv="Content-Security-Policy"]').forEach(el => el.remove());

      // Optionally remove scripts; default is safe (no scripts)
      if (!enableScripts) {
        doc.querySelectorAll('script').forEach(el => el.remove());
        // Remove inline event handlers
        doc.querySelectorAll('*').forEach((el: any) => {
          for (const attr of Array.from(el.attributes || [])) {
            if (/^on/i.test(attr.name)) {
              el.removeAttribute(attr.name);
            }
          }
        });
      }

      // Basic CSS to make the page fill the iframe area
      const style = doc.createElement('style');
      style.textContent = 'html,body{height:100%;margin:0;padding:0;}';
      head.appendChild(style);

      const out = '<!doctype html>' + doc.documentElement.outerHTML;
      return new Response(out, { status: 200, headers: { 'Content-Type': 'text/html; charset=utf-8' } });
    } catch (e) {
      const msg = e instanceof Error ? e.message : String(e);
      return new Response(`Failed to sanitize page: ${msg}`, { status: 500 });
    }
  } catch (e) {
    const msg = e instanceof Error ? e.message : String(e);
    return new Response(`Proxy error: ${msg}`, { status: 500 });
  }
}
</file>

<file path="public/file.svg">
<svg fill="none" viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M14.5 13.5V5.41a1 1 0 0 0-.3-.7L9.8.29A1 1 0 0 0 9.08 0H1.5v13.5A2.5 2.5 0 0 0 4 16h8a2.5 2.5 0 0 0 2.5-2.5m-1.5 0v-7H8v-5H3v12a1 1 0 0 0 1 1h8a1 1 0 0 0 1-1M9.5 5V2.12L12.38 5zM5.13 5h-.62v1.25h2.12V5zm-.62 3h7.12v1.25H4.5zm.62 3h-.62v1.25h7.12V11z" clip-rule="evenodd" fill="#666" fill-rule="evenodd"/></svg>
</file>

<file path="public/globe.svg">
<svg fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><g clip-path="url(#a)"><path fill-rule="evenodd" clip-rule="evenodd" d="M10.27 14.1a6.5 6.5 0 0 0 3.67-3.45q-1.24.21-2.7.34-.31 1.83-.97 3.1M8 16A8 8 0 1 0 8 0a8 8 0 0 0 0 16m.48-1.52a7 7 0 0 1-.96 0H7.5a4 4 0 0 1-.84-1.32q-.38-.89-.63-2.08a40 40 0 0 0 3.92 0q-.25 1.2-.63 2.08a4 4 0 0 1-.84 1.31zm2.94-4.76q1.66-.15 2.95-.43a7 7 0 0 0 0-2.58q-1.3-.27-2.95-.43a18 18 0 0 1 0 3.44m-1.27-3.54a17 17 0 0 1 0 3.64 39 39 0 0 1-4.3 0 17 17 0 0 1 0-3.64 39 39 0 0 1 4.3 0m1.1-1.17q1.45.13 2.69.34a6.5 6.5 0 0 0-3.67-3.44q.65 1.26.98 3.1M8.48 1.5l.01.02q.41.37.84 1.31.38.89.63 2.08a40 40 0 0 0-3.92 0q.25-1.2.63-2.08a4 4 0 0 1 .85-1.32 7 7 0 0 1 .96 0m-2.75.4a6.5 6.5 0 0 0-3.67 3.44 29 29 0 0 1 2.7-.34q.31-1.83.97-3.1M4.58 6.28q-1.66.16-2.95.43a7 7 0 0 0 0 2.58q1.3.27 2.95.43a18 18 0 0 1 0-3.44m.17 4.71q-1.45-.12-2.69-.34a6.5 6.5 0 0 0 3.67 3.44q-.65-1.27-.98-3.1" fill="#666"/></g><defs><clipPath id="a"><path fill="#fff" d="M0 0h16v16H0z"/></clipPath></defs></svg>
</file>

<file path="public/next.svg">
<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 394 80"><path fill="#000" d="M262 0h68.5v12.7h-27.2v66.6h-13.6V12.7H262V0ZM149 0v12.7H94v20.4h44.3v12.6H94v21h55v12.6H80.5V0h68.7zm34.3 0h-17.8l63.8 79.4h17.9l-32-39.7 32-39.6h-17.9l-23 28.6-23-28.6zm18.3 56.7-9-11-27.1 33.7h17.8l18.3-22.7z"/><path fill="#000" d="M81 79.3 17 0H0v79.3h13.6V17l50.2 62.3H81Zm252.6-.4c-1 0-1.8-.4-2.5-1s-1.1-1.6-1.1-2.6.3-1.8 1-2.5 1.6-1 2.6-1 1.8.3 2.5 1a3.4 3.4 0 0 1 .6 4.3 3.7 3.7 0 0 1-3 1.8zm23.2-33.5h6v23.3c0 2.1-.4 4-1.3 5.5a9.1 9.1 0 0 1-3.8 3.5c-1.6.8-3.5 1.3-5.7 1.3-2 0-3.7-.4-5.3-1s-2.8-1.8-3.7-3.2c-.9-1.3-1.4-3-1.4-5h6c.1.8.3 1.6.7 2.2s1 1.2 1.6 1.5c.7.4 1.5.5 2.4.5 1 0 1.8-.2 2.4-.6a4 4 0 0 0 1.6-1.8c.3-.8.5-1.8.5-3V45.5zm30.9 9.1a4.4 4.4 0 0 0-2-3.3 7.5 7.5 0 0 0-4.3-1.1c-1.3 0-2.4.2-3.3.5-.9.4-1.6 1-2 1.6a3.5 3.5 0 0 0-.3 4c.3.5.7.9 1.3 1.2l1.8 1 2 .5 3.2.8c1.3.3 2.5.7 3.7 1.2a13 13 0 0 1 3.2 1.8 8.1 8.1 0 0 1 3 6.5c0 2-.5 3.7-1.5 5.1a10 10 0 0 1-4.4 3.5c-1.8.8-4.1 1.2-6.8 1.2-2.6 0-4.9-.4-6.8-1.2-2-.8-3.4-2-4.5-3.5a10 10 0 0 1-1.7-5.6h6a5 5 0 0 0 3.5 4.6c1 .4 2.2.6 3.4.6 1.3 0 2.5-.2 3.5-.6 1-.4 1.8-1 2.4-1.7a4 4 0 0 0 .8-2.4c0-.9-.2-1.6-.7-2.2a11 11 0 0 0-2.1-1.4l-3.2-1-3.8-1c-2.8-.7-5-1.7-6.6-3.2a7.2 7.2 0 0 1-2.4-5.7 8 8 0 0 1 1.7-5 10 10 0 0 1 4.3-3.5c2-.8 4-1.2 6.4-1.2 2.3 0 4.4.4 6.2 1.2 1.8.8 3.2 2 4.3 3.4 1 1.4 1.5 3 1.5 5h-5.8z"/></svg>
</file>

<file path="public/vercel.svg">
<svg fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1155 1000"><path d="m577.3 0 577.4 1000H0z" fill="#fff"/></svg>
</file>

<file path="public/window.svg">
<svg fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><path fill-rule="evenodd" clip-rule="evenodd" d="M1.5 2.5h13v10a1 1 0 0 1-1 1h-11a1 1 0 0 1-1-1zM0 1h16v11.5a2.5 2.5 0 0 1-2.5 2.5h-11A2.5 2.5 0 0 1 0 12.5zm3.75 4.5a.75.75 0 1 0 0-1.5.75.75 0 0 0 0 1.5M7 4.75a.75.75 0 1 1-1.5 0 .75.75 0 0 1 1.5 0m1.75.75a.75.75 0 1 0 0-1.5.75.75 0 0 0 0 1.5" fill="#666"/></svg>
</file>

<file path="src/ai/geminiSearchClient.ts">
import { GoogleGenerativeAI } from '@google/generative-ai';

export interface SearchResult {
  title: string;
  url: string;
  snippet: string;
  content?: string;
}

export class GeminiSearchClient {
  private genAI: GoogleGenerativeAI;

  constructor(apiKey?: string) {
    const key = apiKey || process.env.GEMINI_API_KEY;
    if (!key) {
      throw new Error('Gemini API key is required');
    }
    this.genAI = new GoogleGenerativeAI(key);
  }

  async searchWithGrounding(query: string, resultCount: number = 5): Promise<SearchResult[]> {
    try {
      const model = this.genAI.getGenerativeModel({ 
        model: 'gemini-2.0-flash-exp',
        tools: [{
          googleSearchRetrieval: {
            dynamicRetrievalConfig: {
              mode: 'MODE_DYNAMIC',
              dynamicThreshold: 0.3
            }
          }
        }]
      });

      const prompt = `Search for: "${query}"
      
Please provide ${resultCount} relevant search results. For each result, include:
1. Title
2. URL/Source
3. Brief snippet/summary
4. If there's only 1 result, also include more detailed content

Format your response as JSON with this structure:
{
  "results": [
    {
      "title": "Result Title",
      "url": "https://example.com",
      "snippet": "Brief description...",
      "content": "Detailed content (only for single results)"
    }
  ],
  "totalResults": number,
  "searchQuery": "${query}"
}`;

      const result = await model.generateContent(prompt);
      const response = await result.response;
      const text = response.text();
      
      // Parse JSON response
      try {
        const data = JSON.parse(text);
        return data.results || [];
      } catch (parseError) {
        // Fallback: create a single result with the full text
        return [{
          title: `Search Results for "${query}"`,
          url: 'https://google.com/search?q=' + encodeURIComponent(query),
          snippet: text.substring(0, 200) + '...',
          content: text
        }];
      }
    } catch (error) {
      console.error('Gemini search error:', error);
      throw new Error(`Search failed: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
}
</file>

<file path="src/ai/taskParser.ts.backup">
/* eslint-disable @typescript-eslint/no-explicit-any */
import { CerebrasClient } from './cerebrasClient';
import { AVAILABLE_TOOLS } from './tools';
import { Task, AIProcessingResult } from './types';

export class TaskParser {
  private cerebrasClient: CerebrasClient;

  constructor(apiKey?: string) {
    this.cerebrasClient = new CerebrasClient(apiKey);
  }

  async parseTextToTasks(text: string, uiContext: any = {}): Promise<AIProcessingResult> {
    try {
      const startTime = Date.now();
      console.log('[TaskParser] parseTextToTasks called', {
        textPreview: typeof text === 'string' ? text.slice(0, 80) : typeof text,
        uiWindows: Array.isArray(uiContext?.windows) ? uiContext.windows.length : 0
      });
      
      // Early handling: if the command is clearly a close/dismiss intent,
      // short-circuit Cerebras and return a direct close task to avoid
      // the model turning it into a note.
      const earlyClose = this.detectCloseCommand(text);
      if (earlyClose.length > 0) {
        return {
          success: true,
          tasks: earlyClose,
          timestamp: Date.now() - startTime
        };
      }

      // Use Cerebras to process the natural language input
      const response = await this.cerebrasClient.processTextToTasks(text, AVAILABLE_TOOLS, uiContext);
      console.log('[TaskParser] Cerebras response received', {
        hasChoices: Boolean((response as any)?.choices?.length),
        toolCalls: ((response as any)?.choices?.[0]?.message?.tool_calls || []).length
      });
      
      let tasks: Task[] = [];
      
      // Extract tool calls from the response
      if (response.choices && response.choices.length > 0) {
        const choice = response.choices[0];
        
        if (choice.message.tool_calls) {
          for (const toolCall of choice.message.tool_calls) {
            if (toolCall.type === 'function') {
              try {
                const parameters = JSON.parse(toolCall.function.arguments);
                
                let task: Task = {
                  id: this.generateTaskId(),
                  tool: toolCall.function.name,
                  parameters: parameters,
                  description: this.generateTaskDescription(toolCall.function.name, parameters)
                };
                // Normalize education intents for consistency (e.g., explain -> explainer)
                task = this.normalizeEducationIntent(text, task);
                tasks.push(task);
              } catch (parseError) {
                console.error('Failed to parse tool call arguments:', parseError);
              }
            }
          }
        }
      }
      // Final normalization pass
      tasks = tasks.map(t => this.normalizeEducationIntent(text, t));

      // If no tool calls were generated, try to handle simple cases with fallback parsing
      if (tasks.length === 0) {
        const fallbackTasks = this.fallbackParsing(text);
        tasks.push(...fallbackTasks);
      }
      
      return {
        success: true,
        tasks: tasks,
        rawResponse: response,
        timestamp: Date.now() - startTime
      };
      
    } catch (error) {
      console.error('Error parsing text to tasks:', error);
      try {
        console.log('[TaskParser] Falling back to local parsing for input');
      } catch {}
      
      // Fallback to simple parsing if Cerebras fails
      const fallbackTasks = this.fallbackParsing(text);
      
      return {
        success: fallbackTasks.length > 0,
        tasks: fallbackTasks,
        error: error instanceof Error ? error.message : String(error),
        timestamp: Date.now()
      };
    }
  }

  private detectCloseCommand(text: string): Task[] {
    try {
      const lower = text.toLowerCase();
      const hasCloseVerb = /(close|dismiss|hide|remove|exit|quit|shut|shutdown|shut\s*down)/i.test(lower);
      const mentionsWindow = /(window|popup|dialog|note|all\s+windows|windows)/i.test(lower);
      const pronounTarget = /(\bthis\b|\bcurrent\b|\bfocused\b|\bit\b|\bthat\b)/i.test(lower);
      if (!hasCloseVerb) return [];
      
      // Must have close verb AND (window mention OR pronoun target)
      if (!mentionsWindow && !pronounTarget) return [];

      // Selector-based phrases
      let selector: 'newest' | 'latest' | 'oldest' | 'active' | 'all' | undefined;
      if (/\b(newest|latest)\b/i.test(text)) selector = 'newest';
      else if (/\boldest\b/i.test(text)) selector = 'oldest';
      else if (pronounTarget || /\bcurrent\b|\bfocused\b/i.test(text)) selector = 'active';
      else if (/\b(all\s+windows|close\s+all|close\s+everything|dismiss\s+all)\b/i.test(lower)) selector = 'all';

      // Direct ID patterns (e.g., "close window abc123")
      // Capture an identifier following the window keyword or at the end
      let windowId: string | undefined;
      const idPatterns: RegExp[] = [
        /(?:close|dismiss|hide|shut(?:\s*down)?)\s+(?:the\s+)?(?:window|popup|dialog|note)\s+([A-Za-z0-9_-]+)/i,
        /(?:window|popup|dialog|note)\s+([A-Za-z0-9_-]+)\s*(?:please)?\s*(?:close|dismiss|hide|shut(?:\s*down)?)?/i,
      ];
      for (const p of idPatterns) {
        const m = text.match(p);
        if (m && m[1]) {
          windowId = m[1].trim();
          break;
        }
      }

      // If we only have a close intent with no id/selector, default to newest
      if (!windowId && !selector && hasCloseVerb) selector = 'newest';

      if (!windowId && !selector) return [];

      const params: any = {};
      if (windowId) params.windowId = windowId;
      if (selector) params.selector = selector;

      return [
        {
          id: this.generateTaskId(),
          tool: 'close_window',
          parameters: params,
          description: this.generateTaskDescription('close_window', params)
        }
      ];
    } catch {
      return [];
    }
  }

  private fallbackParsing(text: string): Task[] {
    const tasks: Task[] = [];
    const lowerText = text.toLowerCase();
    
    // Open/create commands
    if (lowerText.includes('open') || lowerText.includes('create') || lowerText.includes('show') || lowerText.includes('start')) {
      let windowType = 'general';
      let content = '';
      let metadata: Record<string, any> | undefined = undefined;
      let count = 1;
      
      if (lowerText.includes('sticky note') || lowerText.includes('note')) {
        windowType = 'sticky-note';
        // Extract content after "note" or similar keywords
        const noteMatch = text.match(/(?:sticky note|note|reminder)(?:\s+(?:saying|with|that says|about))?\s*["']?([^"']+)["']?/i);
        content = noteMatch ? noteMatch[1].trim() : 'New sticky note';
      } else if (lowerText.includes('lesson')) {
        windowType = 'lesson';
        const title = this.extractTitle(text) || 'New Lesson';
        const stepMatch = text.match(/step\s*(\d+)/i);
        const lessonIdMatch = text.match(/lesson\s*(id\s*)?(\w+)/i);
        metadata = {
          lessonId: lessonIdMatch ? lessonIdMatch[2] : undefined,
          step: stepMatch ? Number(stepMatch[1]) : undefined
        };
        content = content || 'Lesson content';
      } else if (lowerText.includes('quiz')) {
        windowType = 'quiz';
        const title = this.extractTitle(text) || 'Quiz';
        metadata = { title };
        content = content || 'Quiz content';
      } else if (lowerText.includes('hint')) {
        windowType = 'hint';
        const hintMatch = text.match(/hint(?:\s+(?:about|for))?\s*["']?([^"']+)["']?/i);
        content = hintMatch ? hintMatch[1].trim() : 'Hint';
      } else if (lowerText.includes('explain') || lowerText.includes('explainer')) {
        windowType = 'explainer';
        const topicMatch = text.match(/explain(?:\s+(?:about|the|how to))?\s*["']?([^"']+)["']?/i);
        content = topicMatch ? topicMatch[1].trim() : 'Explanation';
      } else if (lowerText.includes('notification')) {
        windowType = 'notification';
        content = 'Notification';
      } else if (lowerText.includes('dialog')) {
        windowType = 'dialog';
        content = 'Dialog window';
      } else if (lowerText.includes('settings')) {
        windowType = 'settings';
        content = 'Settings';
      }

      // Parse counts: e.g., "open 7 windows saying cheese", "open seven windows" (basic digits only here)
      const countMatch = text.match(/open\s+(\d{1,2})\s+(?:window|windows)/i);
      if (countMatch) {
        const n = parseInt(countMatch[1], 10);
        if (!Number.isNaN(n) && n > 1 && n <= 20) count = n;
      }
      
      // Generic content extraction for phrases like: say "...", with content "...", display "..."
      if (!content) {
        const sayPattern = /(?:say|that\s+says|saying|with\s+(?:content|text)|message|display|show\s+text)\s*["']([^"']+)["']/i;
        const sayMatch = text.match(sayPattern);
        if (sayMatch) {
          content = sayMatch[1].trim();
        }
      }

      // Unquoted say/saying patterns: capture text after say/saying until end
      if (!content) {
        const sayPlainPattern = /(?:say|saying|that\s+says)\s+(.+?)$/i;
        const sayPlainMatch = text.match(sayPlainPattern);
        if (sayPlainMatch) {
          content = sayPlainMatch[1].trim();
        }
      }

      // Fallback: if still no content, use first quoted string in the command as content
      if (!content) {
        const anyQuoteMatch = text.match(/"([^\"]+)"|'([^']+)'/);
        if (anyQuoteMatch) {
          content = (anyQuoteMatch[1] || anyQuoteMatch[2] || '').trim();
        }
      }

      for (let i = 0; i < count; i++) {
        tasks.push({
          id: this.generateTaskId(),
          tool: 'open_window',
          parameters: {
            windowType: windowType,
            context: {
              title: this.extractTitle(text) || this.capitalizeFirst(windowType),
              content: content || 'Window content',
              type: windowType,
              metadata
            }
          },
          description: `Open ${windowType} window`
        });
      }
    }
    
    return tasks;
  }

  private extractTitle(text: string): string | null {
    // Extract title from patterns like 'open a "Title" window' or 'create window titled "Title"'
    const titlePatterns = [
      /"([^"]+)"/,
      /'([^']+)'/,
      /titled\s+(.+?)(?:\s+window|$)/i,
      /called\s+(.+?)(?:\s+window|$)/i,
      /named\s+(.+?)(?:\s+window|$)/i
    ];
    
    for (const pattern of titlePatterns) {
      const match = text.match(pattern);
      if (match) {
        return match[1].trim();
      }
    }
    
    return null;
  }

  private normalizeEducationIntent(text: string, task: Task): Task {
    try {
      const lowerText = text.toLowerCase();
      if (task.tool !== 'open_window') return task;
      const params = task.parameters as any;
      if (!params || !params.context) return task;
      const currentType = (params.windowType || params.context.type || '').toLowerCase();

      // Map explain intents to explainer type if model returned general
      if ((lowerText.includes('explain') || lowerText.includes('explainer') || lowerText.includes('step by step')) && (currentType === 'general' || currentType === '')) {
        params.windowType = 'explainer';
        params.context.type = 'explainer';
        if (!params.context.title) {
          const topicMatch = text.match(/explain(?:\s+(?:about|the|how to))?\s*["']?([^"']+)["']?/i);
          params.context.title = topicMatch ? this.capitalizeFirst(topicMatch[1].trim()) : 'Explainer';
        }
        if (!params.context.content) {
          params.context.content = 'Explanation';
        }
        task.description = this.generateTaskDescription('open_window', params);
      }

      // Map lesson intent
      if (lowerText.includes('lesson') && (currentType === 'general' || currentType === '')) {
        params.windowType = params.windowType || 'lesson';
        params.context.type = params.context.type || 'lesson';
      }

      // Map quiz intent
      if (lowerText.includes('quiz') && (currentType === 'general' || currentType === '')) {
        params.windowType = params.windowType || 'quiz';
        params.context.type = params.context.type || 'quiz';
      }

      // Map hint intent
      if (lowerText.includes('hint') && (currentType === 'general' || currentType === '')) {
        params.windowType = params.windowType || 'hint';
        params.context.type = params.context.type || 'hint';
      }

      return task;
    } catch {
      return task;
    }
  }

  private generateTaskDescription(toolName: string, parameters: any): string {
    switch (toolName) {
      case 'open_window':
        return `Open ${parameters.windowType || 'window'}: ${parameters.context?.title || 'Untitled'}`;
      case 'close_window':
        return `Close window: ${parameters.windowId}`;
      default:
        return `Execute ${toolName}`;
    }
  }

  private generateTaskId(): string {
    return `task_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }

  private capitalizeFirst(str: string): string {
    return str.charAt(0).toUpperCase() + str.slice(1);
  }
}
</file>

<file path="src/ai/windowRegistry.ts">
/* eslint-disable @typescript-eslint/no-explicit-any */
import { eventBus } from '@/lib/eventBus';

export interface RegisteredWindow {
  id: string;
  type: string;
  title?: string;
  createdAt: number;
  meta?: any;
}

export interface WindowRegistryAPI {
  add(entry: RegisteredWindow): void;
  remove(windowId: string): void;
  getNewest(): RegisteredWindow | undefined;
  getOldest(): RegisteredWindow | undefined;
  getAll(): RegisteredWindow[];
  getActive(): RegisteredWindow | undefined;
}

class WindowRegistry implements WindowRegistryAPI {
  private windows: RegisteredWindow[] = [];
  private activeWindowId: string | null = null;

  constructor() {
    // Listen to open/close events to keep registry updated
    eventBus.on('window:opened', (data: any) => {
      if (!data?.id) return;
      this.add({
        id: data.id,
        type: data.type,
        title: data.title,
        createdAt: Date.now(),
        meta: data
      });
      this.activeWindowId = data.id;
    });

    eventBus.on('window:closed', (data: any) => {
      if (!data?.windowId) return;
      this.remove(data.windowId);
      if (this.activeWindowId === data.windowId) {
        this.activeWindowId = null;
      }
    });

    // Optional: track focus changes from UI
    eventBus.on('window:focused', (data: any) => {
      if (data?.windowId) this.activeWindowId = data.windowId;
    });
  }

  add(entry: RegisteredWindow): void {
    // Avoid duplicates
    this.windows = this.windows.filter(w => w.id !== entry.id);
    this.windows.push(entry);
  }

  remove(windowId: string): void {
    this.windows = this.windows.filter(w => w.id !== windowId);
  }

  getNewest(): RegisteredWindow | undefined {
    if (this.windows.length === 0) return undefined;
    return this.windows.reduce((a, b) => (a.createdAt > b.createdAt ? a : b));
  }

  getOldest(): RegisteredWindow | undefined {
    if (this.windows.length === 0) return undefined;
    return this.windows.reduce((a, b) => (a.createdAt < b.createdAt ? a : b));
  }

  getAll(): RegisteredWindow[] {
    return [...this.windows];
  }

  getActive(): RegisteredWindow | undefined {
    if (!this.activeWindowId) return undefined;
    return this.windows.find(w => w.id === this.activeWindowId);
  }
}

export const windowRegistry: WindowRegistryAPI = new WindowRegistry();
</file>

<file path="src/app/api/web-search/route.ts">
import { NextRequest } from 'next/server';

// Ensure Node runtime so env vars (GEMINI_API_KEY) are available
export const runtime = 'nodejs';
export const dynamic = 'force-dynamic';
import { GoogleGenerativeAI } from '@google/generative-ai';

type SearchResult = {
  title: string;
  url: string;
  snippet: string;
  content?: string;
};

export async function POST(request: NextRequest) {
  try {
    const body = await request.json().catch(() => ({}));
    const query: string | undefined = body?.query;
    const resultCount: number = Math.min(Math.max(Number(body?.resultCount) || 5, 1), 10);
    const mode: 'links' | 'article' = (body?.mode === 'article') ? 'article' : 'links';

    if (!query || typeof query !== 'string' || query.trim().length === 0) {
      return new Response(JSON.stringify({ error: 'Missing query' }), { status: 400 });
    }

    const useGemini = Boolean(process.env.GEMINI_API_KEY);
    console.log('[API/web-search] useGemini?', useGemini);

    if (useGemini) {
      try {
        const genAI = new GoogleGenerativeAI(process.env.GEMINI_API_KEY as string);
        const model = genAI.getGenerativeModel({ model: 'gemini-1.5-flash' });

        const prompt = `You are a web research assistant. Use Google Search grounding to retrieve results.
Query: "${query}"

Return JSON with this shape exactly:
{
  "results": [
    { "title": string, "url": string, "snippet": string, "content"?: string }
  ]
}
Make sure to include ${resultCount} highly relevant results. If only one truly authoritative result exists, include detailed content in the 'content' field.`;

        // API versions differ; try via responses.generate first with tools
        let text: string | null = null;
        try {
          const res: any = await (model as any).generateContent({
            contents: [{ role: 'user', parts: [{ text: prompt }]}],
            tools: [{ googleSearchRetrieval: {} }]
          });
          text = await res.response.text();
        } catch (e) {
          console.warn('[API/web-search] Gemini tool-call failed, retrying without tools:', e instanceof Error ? e.message : String(e));
          const res: any = await (model as any).generateContent(prompt);
          text = await res.response.text();
        }
        // Try to parse JSON, being tolerant of fenced code blocks
        const tryParse = (raw: string | null) => {
          if (!raw) return null as any;
          let s = raw.trim();
          // strip markdown fences if present
          if (s.startsWith('```')) {
            const idx = s.indexOf('\n');
            if (idx !== -1) s = s.slice(idx + 1);
            if (s.endsWith('```')) s = s.slice(0, -3);
          }
          // extract first JSON object if extra text around
          const m = s.match(/\{[\s\S]*\}/);
          if (m) s = m[0];
          return JSON.parse(s);
        };
        try {
          const data = tryParse(text);
          const results: SearchResult[] = Array.isArray(data?.results) ? data.results : [];
          console.log('[API/web-search] Gemini returned results:', results.length);
          return Response.json({ results: results.slice(0, resultCount) });
        } catch (e) {
          console.warn('[API/web-search] Gemini JSON parse failed; returning blob:', (text || '').slice(0, 160));
          // Fallback to single blob result
          const single: SearchResult = {
            title: `Search Results for "${query}"`,
            url: 'https://www.google.com/search?q=' + encodeURIComponent(query),
            snippet: text.substring(0, 200) + (text.length > 200 ? '...' : ''),
            content: text
          };
          return Response.json({ results: [single] });
        }
      } catch (e) {
        console.error('[API/web-search] Gemini call failed, falling back to DDG:', e instanceof Error ? e.message : String(e));
        // Fall through to non-Gemini fallback
      }
    }

    // Fallback: DuckDuckGo HTML (direct article URLs via uddg)
    try {
      const endpoint = 'https://html.duckduckgo.com/html/?q=' + encodeURIComponent(query);
      const htmlResp = await fetch(endpoint, {
        headers: {
          'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/124 Safari/537.36'
        }
      });
      if (!htmlResp.ok) throw new Error(`DDG HTML HTTP ${htmlResp.status}`);
      const html = await htmlResp.text();
      const { JSDOM } = await import('jsdom');
      const dom = new JSDOM(html);
      const doc = dom.window.document;
      const anchors = Array.from(doc.querySelectorAll('a.result__a')) as HTMLAnchorElement[];
      const results: SearchResult[] = [];
      for (const a of anchors) {
        const href = a.getAttribute('href') || '';
        const title = a.textContent?.trim() || '';
        if (!href) continue;
        const m = href.match(/uddg=([^&]+)/);
        const direct = m ? decodeURIComponent(m[1]) : href.startsWith('http') ? href : `https://duckduckgo.com${href}`;
        // Grab snippet from sibling element if present
        const resultNode = a.closest('.result');
        const snippetNode = resultNode?.querySelector('.result__snippet') || resultNode?.querySelector('.result__extras__url');
        const snippet = snippetNode?.textContent?.trim() || '';
        results.push({ title: title || direct, url: direct, snippet });
        if (results.length >= resultCount) break;
      }

      if (results.length === 0) {
        results.push({ title: `Search for "${query}"`, url: endpoint, snippet: 'No parsed results. Open in browser.' });
      }
      console.log('[API/web-search] Using DuckDuckGo HTML results:', results.length);
      return Response.json({ results });
    } catch (e) {
      // Final fallback: instruct user to configure key
      return Response.json({
        results: [{
          title: `Search for "${query}"`,
          url: 'https://www.google.com/search?q=' + encodeURIComponent(query),
          snippet: 'Search service unavailable. Configure GEMINI_API_KEY in .env.local.'
        }]
      });
    }
  } catch (error) {
    return new Response(JSON.stringify({ error: (error instanceof Error ? error.message : String(error)) }), { status: 500 });
  }
}
</file>

<file path="src/app/layout.tsx">
import type { Metadata } from "next";
import { Geist, Geist_Mono } from "next/font/google";
import "./globals.css";

const geistSans = Geist({
  variable: "--font-geist-sans",
  subsets: ["latin"],
});

const geistMono = Geist_Mono({
  variable: "--font-geist-mono",
  subsets: ["latin"],
});

export const metadata: Metadata = {
  title: "Jarvis",
  description: "Event-driven application architecture",
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en">
      <body
        className={`${geistSans.variable} ${geistMono.variable} antialiased`}
      >
        {children}
      </body>
    </html>
  );
}
</file>

<file path="src/app/page.tsx">
import { MainUI } from '@/ui/MainUI';

export default function Home() {
  return <MainUI />;
}
</file>

<file path="src/input/InputManager.ts">
/* eslint-disable @typescript-eslint/no-explicit-any */
import { eventBus } from '@/lib/eventBus';

export class InputManager {
  private worker: Worker | null = null;
  private isInitialized = false;

  async initialize(): Promise<void> {
    if (this.isInitialized) return;

    try {
      this.worker = new Worker(new URL('./inputWorker.ts', import.meta.url));
      
      this.worker.onmessage = (event) => {
        const { type, data } = event.data;
        eventBus.emit(`input:${type.toLowerCase()}`, data);
      };

      this.worker.onerror = (error) => {
        console.error('Input worker error:', error);
        eventBus.emit('input:error', error);
      };

      this.isInitialized = true;
      eventBus.emit('input:initialized');
    } catch (error) {
      console.error('Failed to initialize input worker:', error);
      eventBus.emit('input:error', error);
    }
  }

  processInput(input: any): void {
    if (!this.worker) {
      console.warn('Input worker not initialized');
      return;
    }

    this.worker.postMessage({
      type: 'PROCESS_INPUT',
      data: input
    });
  }

  validateInput(input: any): void {
    if (!this.worker) {
      console.warn('Input worker not initialized');
      return;
    }

    this.worker.postMessage({
      type: 'VALIDATE_INPUT',
      data: input
    });
  }

  destroy(): void {
    if (this.worker) {
      this.worker.terminate();
      this.worker = null;
    }
    this.isInitialized = false;
    eventBus.emit('input:destroyed');
  }
}

export const inputManager = new InputManager();
</file>

<file path="src/input/inputWorker.ts">
/* eslint-disable @typescript-eslint/no-explicit-any */
self.addEventListener('message', (event) => {
  const { type, data } = event.data;
  
  switch (type) {
    case 'PROCESS_INPUT':
      const processedData = processInput(data);
      self.postMessage({
        type: 'INPUT_PROCESSED',
        data: processedData
      });
      break;
    
    case 'VALIDATE_INPUT':
      const isValid = validateInput(data);
      self.postMessage({
        type: 'INPUT_VALIDATED',
        data: { isValid, input: data }
      });
      break;
    
    default:
      console.warn(`Unknown input worker message type: ${type}`);
  }
});

function processInput(input: any) {
  return {
    processed: true,
    timestamp: Date.now(),
    input
  };
}

function validateInput(input: any): boolean {
  return input != null && input !== '';
}

export {};
</file>

<file path="src/input/SpeechTranscriptionProvider.tsx">
'use client';

import { createContext, useContext, ReactNode } from 'react';
import { useSpeechTranscription, UseSpeechTranscriptionReturn, UseSpeechTranscriptionOptions } from './useSpeechTranscription';

const SpeechTranscriptionContext = createContext<UseSpeechTranscriptionReturn | null>(null);

export interface SpeechTranscriptionProviderProps {
  children: ReactNode;
  options?: UseSpeechTranscriptionOptions;
}

export function SpeechTranscriptionProvider({
  children,
  options = {}
}: SpeechTranscriptionProviderProps) {
  const speechTranscription = useSpeechTranscription(options);

  return (
    <SpeechTranscriptionContext.Provider value={speechTranscription}>
      {children}
    </SpeechTranscriptionContext.Provider>
  );
}

export function useSpeechTranscriptionContext(): UseSpeechTranscriptionReturn {
  const context = useContext(SpeechTranscriptionContext);

  if (!context) {
    throw new Error('useSpeechTranscriptionContext must be used within a SpeechTranscriptionProvider');
  }

  return context;
}

export function SpeechIndicator() {
  const { isListening, isSupported } = useSpeechTranscriptionContext();

  if (!isSupported) {
    return null;
  }

  return (
    <div className="fixed top-4 right-4 z-50">
      <div className={`flex items-center px-3 py-2 rounded-full text-sm font-medium shadow-lg ${
        isListening
          ? 'bg-red-500 text-white'
          : 'bg-gray-200 text-gray-700'
      }`}>
        <div className={`w-2 h-2 rounded-full mr-2 ${
          isListening ? 'bg-white animate-pulse' : 'bg-gray-400'
        }`}></div>
        {isListening ? 'Listening' : 'Not listening'}
      </div>
    </div>
  );
}
</file>

<file path="src/lib/eventBus.ts">
/* eslint-disable @typescript-eslint/no-explicit-any */
type EventCallback<T = any> = (data: T) => void;

class EventBus {
  private listeners: Map<string, Set<EventCallback>> = new Map();

  on<T = any>(event: string, callback: EventCallback<T>): () => void {
    if (!this.listeners.has(event)) {
      this.listeners.set(event, new Set());
    }
    
    this.listeners.get(event)!.add(callback);
    
    return () => this.off(event, callback);
  }

  off<T = any>(event: string, callback: EventCallback<T>): void {
    const eventListeners = this.listeners.get(event);
    if (eventListeners) {
      eventListeners.delete(callback);
      if (eventListeners.size === 0) {
        this.listeners.delete(event);
      }
    }
  }

  emit<T = any>(event: string, data?: T): void {
    const eventListeners = this.listeners.get(event);
    if (eventListeners) {
      eventListeners.forEach(callback => callback(data));
    }
  }

  once<T = any>(event: string, callback: EventCallback<T>): void {
    const onceCallback = (data: T) => {
      callback(data);
      this.off(event, onceCallback);
    };
    this.on(event, onceCallback);
  }

  clear(): void {
    this.listeners.clear();
  }
}

export const eventBus = new EventBus();
export type { EventCallback };
</file>

<file path="src/ui/components/aiWindow/AIWindow.tsx">
'use client';

import { aiManager } from '@/ai';

export function AIWindow() {
  const handleTestAI = () => {
    aiManager.generateResponse({ prompt: 'Test prompt from AI Window!' });
  };

  return (
    <div className="space-y-6">
      <div className="text-center">
        <div className="w-16 h-16 bg-gradient-to-br from-emerald-400 to-green-600 rounded-2xl mx-auto mb-4 flex items-center justify-center shadow-lg">
          <div className="w-8 h-8 bg-white rounded-lg opacity-90"></div>
        </div>
        <h3 className="text-2xl font-bold text-gray-800 mb-2">AI Manager</h3>
        <p className="text-gray-600 leading-relaxed">Generate intelligent responses using AI processing capabilities</p>
      </div>

      <div className="bg-gradient-to-br from-emerald-50 to-green-100 rounded-2xl p-6 border border-emerald-200/50">
        <button
          onClick={handleTestAI}
          className="w-full px-6 py-4 bg-gradient-to-r from-emerald-500 to-green-600 text-white rounded-xl hover:from-emerald-600 hover:to-green-700 transition-all duration-300 font-semibold shadow-lg hover:shadow-xl transform hover:scale-105"
        >
          ðŸ¤– Test AI Response
        </button>

        <div className="mt-4 text-center">
          <p className="text-sm text-gray-600">Check console for AI output</p>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="src/ui/components/aiWindow/index.ts">
export { AIWindow } from './AIWindow';
</file>

<file path="src/ui/components/background/index.ts">
export { AnimatedBackground } from './AnimatedBackground';
</file>

<file path="src/ui/components/barGraph/BarGraph.tsx">
'use client';

import { useMemo, useState } from 'react';
import { DataPoint, BarGraphProps, GraphBounds } from './barGraph.types';

export function BarGraph({
  data,
  width = 600,
  height = 400,
  title = 'Bar Graph',
  xAxisLabel = 'X Axis',
  yAxisLabel = 'Y Axis',
  barColor = '#3b82f6',
  barHoverColor = '#1d4ed8',
  gridColor = '#e5e7eb',
  backgroundColor = '#ffffff',
  showGrid = true,
  showValues = true,
  barSpacing = 0.2,
  barBorderRadius = 4
}: BarGraphProps) {
  const [hoveredBar, setHoveredBar] = useState<DataPoint | null>(null);
  const [mousePosition, setMousePosition] = useState({ x: 0, y: 0 });

  const margin = { top: 60, right: 40, bottom: 80, left: 80 };
  const chartWidth = width - margin.left - margin.right;
  const chartHeight = height - margin.top - margin.bottom;

  const bounds = useMemo((): GraphBounds => {
    if (data.length === 0) return { minX: 0, maxX: 1, minY: 0, maxY: 1 };

    const yValues = data.map(d => d.y);
    const minY = Math.min(0, Math.min(...yValues)); // Include 0 for bars
    const maxY = Math.max(...yValues);

    return {
      minX: 0,
      maxX: data.length - 1,
      minY,
      maxY: maxY + (maxY - minY) * 0.1 // Add 10% padding at top
    };
  }, [data]);

  const barWidth = useMemo(() => {
    if (data.length === 0) return 0;
    const availableWidth = chartWidth * (1 - barSpacing);
    return availableWidth / data.length;
  }, [data.length, chartWidth, barSpacing]);

  const scaleX = (index: number) => {
    const spacing = chartWidth * barSpacing / (data.length + 1);
    return spacing + (index * (barWidth + spacing));
  };

  const scaleY = (y: number) => {
    const range = bounds.maxY - bounds.minY;
    if (range === 0) return chartHeight / 2;
    return chartHeight - ((y - bounds.minY) / range) * chartHeight;
  };

  const getBarHeight = (y: number) => {
    const baseY = scaleY(Math.max(0, bounds.minY));
    const topY = scaleY(y);
    return Math.abs(baseY - topY);
  };

  const getBarY = (y: number) => {
    if (y >= 0) return scaleY(y);
    return scaleY(0);
  };

  const gridLines = useMemo(() => {
    const lines = [];
    const numGridLines = 5;

    if (showGrid) {
      // Horizontal grid lines
      for (let i = 0; i <= numGridLines; i++) {
        const value = bounds.minY + ((bounds.maxY - bounds.minY) / numGridLines) * i;
        const y = scaleY(value);
        lines.push(
          <line
            key={`h-${i}`}
            x1={0}
            y1={y}
            x2={chartWidth}
            y2={y}
            stroke={gridColor}
            strokeWidth={1}
            opacity={0.5}
          />
        );
      }
    }

    return lines;
  }, [showGrid, chartWidth, chartHeight, gridColor, bounds]);

  const xAxisLabels = useMemo(() => {
    return data.map((point, index) => (
      <text
        key={`x-label-${index}`}
        x={scaleX(index) + barWidth / 2}
        y={chartHeight + 20}
        textAnchor="middle"
        className="text-xs fill-gray-600"
      >
        {point.label}
      </text>
    ));
  }, [data, barWidth, chartHeight]);

  const yAxisLabels = useMemo(() => {
    const labels = [];
    const numLabels = 5;

    for (let i = 0; i <= numLabels; i++) {
      const value = bounds.minY + ((bounds.maxY - bounds.minY) / numLabels) * i;
      const y = scaleY(value);

      labels.push(
        <text
          key={`y-label-${i}`}
          x={-10}
          y={y + 4}
          textAnchor="end"
          className="text-xs fill-gray-600"
        >
          {value.toFixed(1)}
        </text>
      );
    }

    return labels;
  }, [bounds, chartHeight]);

  const handleMouseMove = (event: React.MouseEvent<SVGSVGElement>) => {
    const rect = event.currentTarget.getBoundingClientRect();
    setMousePosition({
      x: event.clientX - rect.left,
      y: event.clientY - rect.top
    });
  };

  return (
    <div className="w-full h-full flex flex-col items-center justify-center p-4">
      <h3 className="text-xl font-semibold text-gray-800 mb-4">{title}</h3>

      <div className="relative">
        <svg
          width={width}
          height={height}
          className="border border-gray-200 rounded-lg"
          style={{ backgroundColor }}
          onMouseMove={handleMouseMove}
          onMouseLeave={() => setHoveredBar(null)}
        >
          {/* Chart area */}
          <g transform={`translate(${margin.left}, ${margin.top})`}>
            {/* Grid lines */}
            {gridLines}

            {/* Bars */}
            {data.map((point, index) => {
              const x = scaleX(index);
              const y = getBarY(point.y);
              const barHeight = getBarHeight(point.y);
              const isHovered = hoveredBar === point;

              return (
                <g key={index}>
                  <rect
                    x={x}
                    y={y}
                    width={barWidth}
                    height={barHeight}
                    fill={isHovered ? barHoverColor : barColor}
                    rx={barBorderRadius}
                    ry={barBorderRadius}
                    className="cursor-pointer transition-all duration-200"
                    onMouseEnter={() => setHoveredBar(point)}
                    onMouseLeave={() => setHoveredBar(null)}
                  />

                  {/* Value labels on bars */}
                  {showValues && (
                    <text
                      x={x + barWidth / 2}
                      y={point.y >= 0 ? y - 5 : y + barHeight + 15}
                      textAnchor="middle"
                      className="text-xs fill-gray-700 font-medium"
                    >
                      {point.y.toFixed(1)}
                    </text>
                  )}
                </g>
              );
            })}

            {/* Axis labels */}
            {xAxisLabels}
            {yAxisLabels}
          </g>

          {/* Axis titles */}
          <text
            x={width / 2}
            y={height - 20}
            textAnchor="middle"
            className="text-sm font-medium fill-gray-700"
          >
            {xAxisLabel}
          </text>

          <text
            x={20}
            y={height / 2}
            textAnchor="middle"
            transform={`rotate(-90, 20, ${height / 2})`}
            className="text-sm font-medium fill-gray-700"
          >
            {yAxisLabel}
          </text>
        </svg>

        {/* Tooltip */}
        {hoveredBar && (
          <div
            className="absolute bg-gray-800 text-white text-xs rounded px-2 py-1 pointer-events-none z-10"
            style={{
              left: mousePosition.x + 10,
              top: mousePosition.y - 30,
              transform: mousePosition.x > width - 100 ? 'translateX(-100%)' : 'none'
            }}
          >
            <div className="font-semibold">{hoveredBar.label}</div>
            <div>Value: {hoveredBar.y.toFixed(2)}</div>
          </div>
        )}
      </div>
    </div>
  );
}
</file>

<file path="src/ui/components/barGraph/barGraph.types.ts">
export interface DataPoint {
  label: string;
  x: number;
  y: number;
}

export interface BarGraphProps {
  data: DataPoint[];
  width?: number;
  height?: number;
  title?: string;
  xAxisLabel?: string;
  yAxisLabel?: string;
  barColor?: string;
  barHoverColor?: string;
  gridColor?: string;
  backgroundColor?: string;
  showGrid?: boolean;
  showValues?: boolean;
  barSpacing?: number;
  barBorderRadius?: number;
}

export interface GraphBounds {
  minX: number;
  maxX: number;
  minY: number;
  maxY: number;
}
</file>

<file path="src/ui/components/barGraph/index.ts">
export { BarGraph } from './BarGraph';
export type { DataPoint, BarGraphProps, GraphBounds } from './barGraph.types';
</file>

<file path="src/ui/components/barGraphWindow/BarGraphWindow.tsx">
'use client';

import { useState } from 'react';
import { BarGraph, DataPoint } from '../barGraph';

export function BarGraphWindow() {
  const [data] = useState<DataPoint[]>([
    { label: 'Jan', x: 0, y: 45 },
    { label: 'Feb', x: 1, y: 52 },
    { label: 'Mar', x: 2, y: 38 },
    { label: 'Apr', x: 3, y: 61 },
    { label: 'May', x: 4, y: 55 },
    { label: 'Jun', x: 5, y: 67 },
    { label: 'Jul', x: 6, y: 43 },
    { label: 'Aug', x: 7, y: 58 },
    { label: 'Sep', x: 8, y: 72 },
    { label: 'Oct', x: 9, y: 65 },
    { label: 'Nov', x: 10, y: 78 },
    { label: 'Dec', x: 11, y: 85 }
  ]);

  const [title] = useState('Monthly Sales Data');

  return (
    <div className="h-full w-full p-6">
      <BarGraph
        data={data}
        title={title}
        xAxisLabel="Month"
        yAxisLabel="Sales ($K)"
        width={600}
        height={450}
        barColor="#3b82f6"
        barHoverColor="#1d4ed8"
        showGrid={true}
        showValues={true}
      />
    </div>
  );
}
</file>

<file path="src/ui/components/barGraphWindow/index.ts">
export { BarGraphWindow } from './BarGraphWindow';
</file>

<file path="src/ui/components/debugSidebar/index.ts">
export * from './DebugSidebar';
</file>

<file path="src/ui/components/graphWindow/GraphWindow.tsx">
'use client';

import { useState } from 'react';
import { LineGraph, DataPoint } from '../lineGraph';

export function GraphWindow() {
  const [data] = useState<DataPoint[]>([
    { label: 'Start', x: 0, y: 10 },
    { label: 'Peak', x: 1, y: 25 },
    { label: 'Dip', x: 2, y: 15 },
    { label: 'Rise', x: 3, y: 30 },
    { label: 'Valley', x: 4, y: 8 },
    { label: 'High', x: 5, y: 35 },
    { label: 'End', x: 6, y: 20 }
  ]);

  const [title] = useState('Sample Data Points');

  return (
    <div className="h-full w-full p-6">
      <LineGraph
        data={data}
        title={title}
        xAxisLabel="Time"
        yAxisLabel="Value"
        width={600}
        height={450}
        lineColor="#8b5cf6"
        pointColor="#7c3aed"
        showGrid={true}
        showPoints={true}
      />
    </div>
  );
}
</file>

<file path="src/ui/components/graphWindow/index.ts">
export { GraphWindow } from './GraphWindow';
</file>

<file path="src/ui/components/imageDropZone/index.ts">
export { ImageDropZone } from './ImageDropZone';
</file>

<file path="src/ui/components/imageViewer/ImageViewer.tsx">
'use client';

import { useState } from 'react';

interface ImageViewerProps {
  imageUrl: string;
  imageName?: string;
}

export function ImageViewer({ imageUrl, imageName }: ImageViewerProps) {
  const [isFullscreen, setIsFullscreen] = useState(false);

  const handleDownload = () => {
    const link = document.createElement('a');
    link.href = imageUrl;
    link.download = imageName || 'image';
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
  };

  return (
    <div className="h-full w-full bg-black relative">
      <img
        src={imageUrl}
        alt={imageName || 'Uploaded image'}
        className="w-full h-full object-contain"
      />
      
      {/* Floating controls */}
      <div className="absolute top-4 right-4 flex space-x-2 z-10">
        <button
          onClick={() => setIsFullscreen(!isFullscreen)}
          className="px-3 py-1 bg-blue-600/80 hover:bg-blue-700/80 backdrop-blur-sm rounded text-sm transition-colors text-white"
        >
          {isFullscreen ? 'Exit Fullscreen' : 'Fullscreen'}
        </button>
        <button
          onClick={handleDownload}
          className="px-3 py-1 bg-green-600/80 hover:bg-green-700/80 backdrop-blur-sm rounded text-sm transition-colors text-white"
        >
          Download
        </button>
      </div>
      
      {/* Fullscreen overlay */}
      {isFullscreen && (
        <div className="fixed inset-0 z-50 bg-black flex items-center justify-center">
          <img
            src={imageUrl}
            alt={imageName || 'Uploaded image'}
            className="max-w-full max-h-full object-contain"
          />
          <button
            onClick={() => setIsFullscreen(false)}
            className="absolute top-4 right-4 bg-red-600 hover:bg-red-700 text-white px-4 py-2 rounded transition-colors"
          >
            Close
          </button>
        </div>
      )}
    </div>
  );
}
</file>

<file path="src/ui/components/imageViewer/index.ts">
export { ImageViewer } from './ImageViewer';
</file>

<file path="src/ui/components/inputWindow/index.ts">
export { InputWindow } from './InputWindow';
</file>

<file path="src/ui/components/inputWindow/InputWindow.tsx">
'use client';

import { inputManager } from '@/input';

export function InputWindow() {
  const handleTestInput = () => {
    inputManager.processInput({ test: 'Hello from Input Window!' });
  };

  return (
    <div className="space-y-6">
      <div className="text-center">
        <div className="w-16 h-16 bg-gradient-to-br from-blue-400 to-indigo-600 rounded-2xl mx-auto mb-4 flex items-center justify-center shadow-lg">
          <div className="w-8 h-8 bg-white rounded-lg opacity-90"></div>
        </div>
        <h3 className="text-2xl font-bold text-gray-800 mb-2">Input Manager</h3>
        <p className="text-gray-600 leading-relaxed">Process and handle input data through the event bus system</p>
      </div>

      <div className="bg-gradient-to-br from-blue-50 to-indigo-100 rounded-2xl p-6 border border-blue-200/50">
        <button
          onClick={handleTestInput}
          className="w-full px-6 py-4 bg-gradient-to-r from-blue-500 to-indigo-600 text-white rounded-xl hover:from-blue-600 hover:to-indigo-700 transition-all duration-300 font-semibold shadow-lg hover:shadow-xl transform hover:scale-105"
        >
          ðŸš€ Test Input Processing
        </button>

        <div className="mt-4 text-center">
          <p className="text-sm text-gray-600">Check console for event output</p>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="src/ui/components/lineGraph/index.ts">
export { LineGraph } from './LineGraph';
export type { DataPoint, LineGraphProps, GraphBounds } from './lineGraph.types';
</file>

<file path="src/ui/components/lineGraph/LineGraph.tsx">
'use client';

import { useMemo, useState } from 'react';
import { DataPoint, LineGraphProps, GraphBounds } from './lineGraph.types';

export function LineGraph({
  data,
  width = 600,
  height = 400,
  title = 'Line Graph',
  xAxisLabel = 'X Axis',
  yAxisLabel = 'Y Axis',
  lineColor = '#3b82f6',
  pointColor = '#1d4ed8',
  gridColor = '#e5e7eb',
  backgroundColor = '#ffffff',
  showGrid = true,
  showPoints = true,
  lineThickness = 2,
  pointRadius = 4
}: LineGraphProps) {
  const [hoveredPoint, setHoveredPoint] = useState<DataPoint | null>(null);
  const [mousePosition, setMousePosition] = useState({ x: 0, y: 0 });

  const margin = { top: 60, right: 40, bottom: 80, left: 80 };
  const chartWidth = width - margin.left - margin.right;
  const chartHeight = height - margin.top - margin.bottom;

  const bounds = useMemo((): GraphBounds => {
    if (data.length === 0) return { minX: 0, maxX: 1, minY: 0, maxY: 1 };

    const xValues = data.map(d => d.x);
    const yValues = data.map(d => d.y);

    return {
      minX: Math.min(...xValues),
      maxX: Math.max(...xValues),
      minY: Math.min(...yValues),
      maxY: Math.max(...yValues)
    };
  }, [data]);

  const scaleX = (x: number) => {
    const range = bounds.maxX - bounds.minX;
    if (range === 0) return chartWidth / 2;
    return ((x - bounds.minX) / range) * chartWidth;
  };

  const scaleY = (y: number) => {
    const range = bounds.maxY - bounds.minY;
    if (range === 0) return chartHeight / 2;
    return chartHeight - ((y - bounds.minY) / range) * chartHeight;
  };

  const pathData = useMemo(() => {
    if (data.length === 0) return '';

    const points = data.map(d => `${scaleX(d.x)},${scaleY(d.y)}`).join(' L ');
    return `M ${points}`;
  }, [data, bounds, chartWidth, chartHeight]);

  const gridLines = useMemo(() => {
    const lines = [];
    const numGridLines = 5;

    if (showGrid) {
      // Vertical grid lines
      for (let i = 0; i <= numGridLines; i++) {
        const x = (chartWidth / numGridLines) * i;
        lines.push(
          <line
            key={`v-${i}`}
            x1={x}
            y1={0}
            x2={x}
            y2={chartHeight}
            stroke={gridColor}
            strokeWidth={1}
            opacity={0.5}
          />
        );
      }

      // Horizontal grid lines
      for (let i = 0; i <= numGridLines; i++) {
        const y = (chartHeight / numGridLines) * i;
        lines.push(
          <line
            key={`h-${i}`}
            x1={0}
            y1={y}
            x2={chartWidth}
            y2={y}
            stroke={gridColor}
            strokeWidth={1}
            opacity={0.5}
          />
        );
      }
    }

    return lines;
  }, [showGrid, chartWidth, chartHeight, gridColor]);

  const xAxisLabels = useMemo(() => {
    const labels = [];
    const numLabels = 5;

    for (let i = 0; i <= numLabels; i++) {
      const value = bounds.minX + ((bounds.maxX - bounds.minX) / numLabels) * i;
      const x = (chartWidth / numLabels) * i;

      labels.push(
        <text
          key={`x-label-${i}`}
          x={x}
          y={chartHeight + 20}
          textAnchor="middle"
          className="text-xs fill-gray-600"
        >
          {value.toFixed(1)}
        </text>
      );
    }

    return labels;
  }, [bounds, chartWidth, chartHeight]);

  const yAxisLabels = useMemo(() => {
    const labels = [];
    const numLabels = 5;

    for (let i = 0; i <= numLabels; i++) {
      const value = bounds.minY + ((bounds.maxY - bounds.minY) / numLabels) * i;
      const y = chartHeight - (chartHeight / numLabels) * i;

      labels.push(
        <text
          key={`y-label-${i}`}
          x={-10}
          y={y + 4}
          textAnchor="end"
          className="text-xs fill-gray-600"
        >
          {value.toFixed(1)}
        </text>
      );
    }

    return labels;
  }, [bounds, chartHeight]);

  const handleMouseMove = (event: React.MouseEvent<SVGSVGElement>) => {
    const rect = event.currentTarget.getBoundingClientRect();
    setMousePosition({
      x: event.clientX - rect.left,
      y: event.clientY - rect.top
    });
  };

  return (
    <div className="w-full h-full flex flex-col items-center justify-center p-4">
      <h3 className="text-xl font-semibold text-gray-800 mb-4">{title}</h3>

      <div className="relative">
        <svg
          width={width}
          height={height}
          className="border border-gray-200 rounded-lg"
          style={{ backgroundColor }}
          onMouseMove={handleMouseMove}
          onMouseLeave={() => setHoveredPoint(null)}
        >
          {/* Chart area */}
          <g transform={`translate(${margin.left}, ${margin.top})`}>
            {/* Grid lines */}
            {gridLines}

            {/* Main line */}
            {data.length > 1 && (
              <path
                d={pathData}
                fill="none"
                stroke={lineColor}
                strokeWidth={lineThickness}
                strokeLinecap="round"
                strokeLinejoin="round"
              />
            )}

            {/* Data points */}
            {showPoints && data.map((point, index) => (
              <circle
                key={index}
                cx={scaleX(point.x)}
                cy={scaleY(point.y)}
                r={pointRadius}
                fill={pointColor}
                stroke="#ffffff"
                strokeWidth={2}
                className="cursor-pointer hover:r-6 transition-all"
                onMouseEnter={() => setHoveredPoint(point)}
                onMouseLeave={() => setHoveredPoint(null)}
              />
            ))}

            {/* Axis labels */}
            {xAxisLabels}
            {yAxisLabels}
          </g>

          {/* Axis titles */}
          <text
            x={width / 2}
            y={height - 20}
            textAnchor="middle"
            className="text-sm font-medium fill-gray-700"
          >
            {xAxisLabel}
          </text>

          <text
            x={20}
            y={height / 2}
            textAnchor="middle"
            transform={`rotate(-90, 20, ${height / 2})`}
            className="text-sm font-medium fill-gray-700"
          >
            {yAxisLabel}
          </text>
        </svg>

        {/* Tooltip */}
        {hoveredPoint && (
          <div
            className="absolute bg-gray-800 text-white text-xs rounded px-2 py-1 pointer-events-none z-10"
            style={{
              left: mousePosition.x + 10,
              top: mousePosition.y - 30,
              transform: mousePosition.x > width - 100 ? 'translateX(-100%)' : 'none'
            }}
          >
            <div className="font-semibold">{hoveredPoint.label}</div>
            <div>X: {hoveredPoint.x.toFixed(2)}</div>
            <div>Y: {hoveredPoint.y.toFixed(2)}</div>
          </div>
        )}
      </div>
    </div>
  );
}
</file>

<file path="src/ui/components/lineGraph/lineGraph.types.ts">
export interface DataPoint {
  label: string;
  x: number;
  y: number;
}

export interface LineGraphProps {
  data: DataPoint[];
  width?: number;
  height?: number;
  title?: string;
  xAxisLabel?: string;
  yAxisLabel?: string;
  lineColor?: string;
  pointColor?: string;
  gridColor?: string;
  backgroundColor?: string;
  showGrid?: boolean;
  showPoints?: boolean;
  lineThickness?: number;
  pointRadius?: number;
}

export interface GraphBounds {
  minX: number;
  maxX: number;
  minY: number;
  maxY: number;
}
</file>

<file path="src/ui/components/pieChart/index.ts">
export { PieChart } from './PieChart';
export { PieChartWindow } from './PieChartWindow';
export type { DataPoint, PieChartProps, PieSlice } from './pieChart.types';
</file>

<file path="src/ui/components/pieChart/PieChart.tsx">
'use client';

import { useMemo, useState } from 'react';
import { DataPoint, PieChartProps, PieSlice } from './pieChart.types';

export function PieChart({
  data,
  width = 500,
  height = 400,
  title = 'Pie Chart',
  radius = 120,
  innerRadius = 0,
  colors = [
    '#3b82f6', '#ef4444', '#10b981', '#f59e0b', '#8b5cf6',
    '#06b6d4', '#84cc16', '#f97316', '#ec4899', '#6366f1'
  ],
  showLabels = true,
  showPercentages = true,
  showLegend = true,
  animationDuration = 300
}: PieChartProps) {
  const [hoveredSlice, setHoveredSlice] = useState<PieSlice | null>(null);
  const [mousePosition, setMousePosition] = useState({ x: 0, y: 0 });

  const centerX = width / 2;
  const centerY = height / 2 - 10; // Slightly offset for title

  const pieSlices = useMemo((): PieSlice[] => {
    const total = data.reduce((sum, item) => sum + Math.abs(item.y), 0);
    if (total === 0) return [];

    let currentAngle = -Math.PI / 2; // Start at top

    return data.map((item, index) => {
      const value = Math.abs(item.y);
      const percentage = (value / total) * 100;
      const sliceAngle = (value / total) * 2 * Math.PI;

      const slice: PieSlice = {
        label: item.label,
        value,
        percentage,
        startAngle: currentAngle,
        endAngle: currentAngle + sliceAngle,
        color: colors[index % colors.length]
      };

      currentAngle += sliceAngle;
      return slice;
    });
  }, [data, colors]);

  const createArcPath = (slice: PieSlice, outerRadius: number, innerRadius: number = 0) => {
    const { startAngle, endAngle } = slice;

    const x1 = centerX + Math.cos(startAngle) * outerRadius;
    const y1 = centerY + Math.sin(startAngle) * outerRadius;
    const x2 = centerX + Math.cos(endAngle) * outerRadius;
    const y2 = centerY + Math.sin(endAngle) * outerRadius;

    const largeArcFlag = endAngle - startAngle <= Math.PI ? 0 : 1;

    if (innerRadius === 0) {
      // Regular pie slice
      return `M ${centerX},${centerY} L ${x1},${y1} A ${outerRadius},${outerRadius} 0 ${largeArcFlag},1 ${x2},${y2} Z`;
    } else {
      // Donut slice
      const x3 = centerX + Math.cos(startAngle) * innerRadius;
      const y3 = centerY + Math.sin(startAngle) * innerRadius;
      const x4 = centerX + Math.cos(endAngle) * innerRadius;
      const y4 = centerY + Math.sin(endAngle) * innerRadius;

      return `M ${x1},${y1} A ${outerRadius},${outerRadius} 0 ${largeArcFlag},1 ${x2},${y2} L ${x4},${y4} A ${innerRadius},${innerRadius} 0 ${largeArcFlag},0 ${x3},${y3} Z`;
    }
  };

  const getLabelPosition = (slice: PieSlice) => {
    const midAngle = (slice.startAngle + slice.endAngle) / 2;
    const labelRadius = radius * 0.7;

    return {
      x: centerX + Math.cos(midAngle) * labelRadius,
      y: centerY + Math.sin(midAngle) * labelRadius
    };
  };

  const handleMouseMove = (event: React.MouseEvent<SVGSVGElement>) => {
    const rect = event.currentTarget.getBoundingClientRect();
    setMousePosition({
      x: event.clientX - rect.left,
      y: event.clientY - rect.top
    });
  };

  return (
    <div className="w-full h-full flex flex-col items-center justify-center p-4">
      <h3 className="text-xl font-semibold text-gray-800 mb-4">{title}</h3>

      <div className="flex items-start justify-center space-x-12">
        {/* Pie Chart */}
        <div className="relative flex-shrink-0">
          <svg
            width={width * 0.7}
            height={height}
            className="overflow-visible"
            onMouseMove={handleMouseMove}
            onMouseLeave={() => setHoveredSlice(null)}
          >
            {/* Pie slices */}
            {pieSlices.map((slice, index) => {
              const isHovered = hoveredSlice === slice;
              const sliceRadius = isHovered ? radius + 5 : radius;

              return (
                <g key={index}>
                  <path
                    d={createArcPath(slice, sliceRadius, innerRadius)}
                    fill={slice.color}
                    stroke="#ffffff"
                    strokeWidth={2}
                    className="cursor-pointer transition-all duration-200"
                    style={{
                      filter: isHovered ? 'brightness(1.1)' : 'none'
                    }}
                    onMouseEnter={() => setHoveredSlice(slice)}
                    onMouseLeave={() => setHoveredSlice(null)}
                  />

                  {/* Labels */}
                  {showLabels && slice.percentage > 5 && (
                    <text
                      x={getLabelPosition(slice).x}
                      y={getLabelPosition(slice).y}
                      textAnchor="middle"
                      dominantBaseline="middle"
                      className="text-xs font-medium fill-white"
                      style={{ pointerEvents: 'none' }}
                    >
                      {showPercentages ? `${slice.percentage.toFixed(1)}%` : slice.label}
                    </text>
                  )}
                </g>
              );
            })}

            {/* Center text for donut charts */}
            {innerRadius > 0 && (
              <text
                x={centerX}
                y={centerY}
                textAnchor="middle"
                dominantBaseline="middle"
                className="text-lg font-semibold fill-gray-700"
              >
                Total
              </text>
            )}
          </svg>

          {/* Tooltip */}
          {hoveredSlice && (
            <div
              className="absolute bg-gray-800 text-white text-xs rounded px-2 py-1 pointer-events-none z-10"
              style={{
                left: mousePosition.x + 10,
                top: mousePosition.y - 30,
                transform: mousePosition.x > width * 0.35 ? 'translateX(-100%)' : 'none'
              }}
            >
              <div className="font-semibold">{hoveredSlice.label}</div>
              <div>Value: {hoveredSlice.value.toFixed(2)}</div>
              <div>Percentage: {hoveredSlice.percentage.toFixed(1)}%</div>
            </div>
          )}
        </div>

        {/* Legend */}
        {showLegend && (
          <div className="flex flex-col space-y-2">
            <h4 className="text-sm font-semibold text-gray-700 mb-2">Legend</h4>
            {pieSlices.map((slice, index) => (
              <div
                key={index}
                className="flex items-center space-x-2 cursor-pointer hover:bg-gray-50 rounded px-2 py-1 transition-colors"
                onMouseEnter={() => setHoveredSlice(slice)}
                onMouseLeave={() => setHoveredSlice(null)}
              >
                <div
                  className="w-3 h-3 rounded-sm"
                  style={{ backgroundColor: slice.color }}
                />
                <div className="text-sm">
                  <div className="font-medium text-gray-800">{slice.label}</div>
                  <div className="text-xs text-gray-500">
                    {slice.value.toFixed(1)} ({slice.percentage.toFixed(1)}%)
                  </div>
                </div>
              </div>
            ))}
          </div>
        )}
      </div>
    </div>
  );
}
</file>

<file path="src/ui/components/pieChart/pieChart.types.ts">
export interface DataPoint {
  label: string;
  x: number; // Not used for pie charts but kept for consistency
  y: number; // This will be the value for the pie slice
}

export interface PieSlice {
  label: string;
  value: number;
  percentage: number;
  startAngle: number;
  endAngle: number;
  color: string;
}

export interface PieChartProps {
  data: DataPoint[];
  width?: number;
  height?: number;
  title?: string;
  radius?: number;
  innerRadius?: number; // For donut charts
  colors?: string[];
  showLabels?: boolean;
  showPercentages?: boolean;
  showLegend?: boolean;
  animationDuration?: number;
}
</file>

<file path="src/ui/components/pieChart/PieChartWindow.tsx">
'use client';

import { useState } from 'react';
import { PieChart } from './PieChart';
import { DataPoint } from './pieChart.types';

export function PieChartWindow() {
  const [data] = useState<DataPoint[]>([
    { label: 'Development', x: 0, y: 40 },
    { label: 'Design', x: 1, y: 25 },
    { label: 'Testing', x: 2, y: 20 },
    { label: 'Documentation', x: 3, y: 10 },
    { label: 'Deployment', x: 4, y: 5 }
  ]);

  const [title] = useState('Project Time Distribution');

  return (
    <div className="h-full w-full p-6">
      <PieChart
        data={data}
        title={title}
        width={600}
        height={450}
        showLabels={true}
        showPercentages={true}
        showLegend={true}
      />
    </div>
  );
}
</file>

<file path="src/ui/components/systemOutput/index.ts">
export { SystemOutput } from './SystemOutput';
export type { SystemOutputState, SystemOutputProps } from './systemOutput.types';
</file>

<file path="src/ui/components/systemOutput/SystemOutput.tsx">
'use client';

import { useState, useEffect, useRef } from 'react';
import { eventBus } from '@/lib/eventBus';
import { SystemOutputState, SystemOutputProps } from './systemOutput.types';

export function SystemOutput({
  placeholder = 'System messages will appear here...'
}: SystemOutputProps) {
  const [notes, setNotes] = useState<SystemOutputState>({
    content: '',
    lastModified: new Date()
  });
  const textareaRef = useRef<HTMLTextAreaElement>(null);

  useEffect(() => {
    const unsubscribers = [
      eventBus.on('input:input_processed', (data) => {
        addToNotes(`Input processed: ${JSON.stringify(data)}\n`);
      }),
      eventBus.on('ai:ai_response_generated', (data) => {
        addToNotes(`AI response: ${JSON.stringify(data)}\n`);
      }),
      eventBus.on('input:initialized', () => {
        addToNotes('Input manager initialized successfully\n');
      }),
      eventBus.on('ai:initialized', () => {
        addToNotes('AI manager initialized successfully\n');
      }),
      eventBus.on('ui:log', (data: { message: string }) => {
        addToNotes(`${data.message}\n`);
      }),
      eventBus.on('system:output', (data: { text: string }) => {
        addToNotes(data.text);
      })
    ];

    return () => {
      unsubscribers.forEach(unsub => unsub());
    };
  }, []);

  const addToNotes = (text: string) => {
    setNotes(prev => ({
      content: prev.content + text,
      lastModified: new Date()
    }));
  };

  const clearNotes = () => {
    setNotes({
      content: '',
      lastModified: new Date()
    });
  };

  return (
    <div className="h-full flex flex-col">
      {/* Header */}
      <div className="flex items-center justify-between p-4 border-b bg-white">
        <div className="flex items-center space-x-3">
          <div className="w-10 h-10 bg-gradient-to-br from-green-400 to-emerald-500 rounded-lg flex items-center justify-center shadow-md">
            <span className="text-white text-lg">ðŸ–¥ï¸</span>
          </div>
          <div>
            <h3 className="text-lg font-semibold text-gray-800">System Output</h3>
            <p className="text-xs text-gray-500">
              Last modified: {notes.lastModified.toLocaleTimeString()}
            </p>
          </div>
        </div>
      </div>

      {/* Notes Area */}
      <div className="flex-1 p-4">
        <textarea
          ref={textareaRef}
          value={notes.content}
          readOnly
          placeholder={placeholder}
          className="w-full h-full resize-none border-none outline-none bg-transparent text-gray-800 leading-relaxed text-sm cursor-default"
          style={{
            fontFamily: 'system-ui, -apple-system, sans-serif',
            lineHeight: '1.6'
          }}
        />
      </div>

      {/* Footer */}
      <div className="border-t bg-gray-50 px-4 py-2 text-xs text-gray-500 flex justify-between">
        <span>
          {notes.content.split(/\s+/).filter(word => word.length > 0).length} words
        </span>
        <span>
          {notes.content.length} characters
        </span>
      </div>
    </div>
  );
}
</file>

<file path="src/ui/components/systemOutput/systemOutput.types.ts">
export interface SystemOutputState {
  content: string;
  lastModified: Date;
}

export interface SystemOutputProps {
  placeholder?: string;
}
</file>

<file path="src/ui/components/userNotes/index.ts">
export { UserNotes } from './UserNotes';
export type { UserNotesState, UserNotesProps } from './userNotes.types';
</file>

<file path="src/ui/components/userNotes/UserNotes.tsx">
'use client';

import { useState, useRef } from 'react';
import { UserNotesState, UserNotesProps } from './userNotes.types';

export function UserNotes({
  placeholder = 'Start typing your personal notes here...'
}: UserNotesProps) {
  const [notes, setNotes] = useState<UserNotesState>({
    content: '',
    lastModified: new Date()
  });
  const textareaRef = useRef<HTMLTextAreaElement>(null);

  const handleContentChange = (e: React.ChangeEvent<HTMLTextAreaElement>) => {
    setNotes({
      content: e.target.value,
      lastModified: new Date()
    });
  };

  const clearNotes = () => {
    setNotes({
      content: '',
      lastModified: new Date()
    });
  };

  return (
    <div className="h-full flex flex-col">
      {/* Header */}
      <div className="flex items-center justify-between p-4 border-b bg-white">
        <div className="flex items-center space-x-3">
          <div className="w-10 h-10 bg-gradient-to-br from-blue-400 to-indigo-500 rounded-lg flex items-center justify-center shadow-md">
            <span className="text-white text-lg">âœï¸</span>
          </div>
          <div>
            <h3 className="text-lg font-semibold text-gray-800">Personal Notes</h3>
            <p className="text-xs text-gray-500">
              Last modified: {notes.lastModified.toLocaleTimeString()}
            </p>
          </div>
        </div>

        <button
          onClick={clearNotes}
          className="px-3 py-1 text-sm bg-gray-100 hover:bg-gray-200 text-gray-700 rounded transition-colors"
        >
          Clear All
        </button>
      </div>

      {/* Notes Area */}
      <div className="flex-1 p-4">
        <textarea
          ref={textareaRef}
          value={notes.content}
          onChange={handleContentChange}
          placeholder={placeholder}
          className="w-full h-full resize-none border-none outline-none bg-transparent text-gray-800 leading-relaxed text-sm"
          style={{
            fontFamily: 'system-ui, -apple-system, sans-serif',
            lineHeight: '1.6'
          }}
        />
      </div>

      {/* Footer */}
      <div className="border-t bg-gray-50 px-4 py-2 text-xs text-gray-500 flex justify-between">
        <span>
          {notes.content.split(/\s+/).filter(word => word.length > 0).length} words
        </span>
        <span>
          {notes.content.length} characters
        </span>
      </div>
    </div>
  );
}
</file>

<file path="src/ui/components/userNotes/userNotes.types.ts">
export interface UserNotesState {
  content: string;
  lastModified: Date;
}

export interface UserNotesProps {
  placeholder?: string;
}
</file>

<file path="src/ui/components/window/index.ts">
export { Window } from './Window';
export type { WindowProps, WindowState } from './window.types';
</file>

<file path="src/ui/components/windowManager/index.ts">
export { WindowManager } from './WindowManager';
export type { WindowManagerRef } from './WindowManager';
export type { WindowData, WindowManagerState } from './windowManager.types';
</file>

<file path="src/ui/components/README.md">
# UI Components

This directory contains UI component submodules. Each submodule should:

1. Communicate only through the global event bus
2. Be independently developable 
3. Follow the established patterns

## Structure

```
components/
â”œâ”€â”€ component1/
â”‚   â”œâ”€â”€ index.ts
â”‚   â”œâ”€â”€ Component1.tsx
â”‚   â””â”€â”€ component1.types.ts
â”œâ”€â”€ component2/
â”‚   â”œâ”€â”€ index.ts
â”‚   â”œâ”€â”€ Component2.tsx
â”‚   â””â”€â”€ component2.types.ts
â””â”€â”€ ...
```

## Event Bus Usage

Components should:
- Listen to relevant events using `eventBus.on()`
- Emit events using `eventBus.emit()`
- Clean up listeners in useEffect cleanup functions
</file>

<file path="src/ui/index.ts">
export { MainUI } from './MainUI';
</file>

<file path="add_gemini_search.js">
const fs = require('fs');

// Create Gemini client for web search
const geminiClientContent = `import { GoogleGenerativeAI } from '@google/generative-ai';

export interface SearchResult {
  title: string;
  url: string;
  snippet: string;
  content?: string;
}

export class GeminiSearchClient {
  private genAI: GoogleGenerativeAI;

  constructor(apiKey?: string) {
    const key = apiKey || process.env.GEMINI_API_KEY;
    if (!key) {
      throw new Error('Gemini API key is required');
    }
    this.genAI = new GoogleGenerativeAI(key);
  }

  async searchWithGrounding(query: string, resultCount: number = 5): Promise<SearchResult[]> {
    try {
      const model = this.genAI.getGenerativeModel({ 
        model: 'gemini-2.0-flash-exp',
        tools: [{
          googleSearchRetrieval: {
            dynamicRetrievalConfig: {
              mode: 'MODE_DYNAMIC',
              dynamicThreshold: 0.3
            }
          }
        }]
      });

      const prompt = \`Search for: "\${query}"
      
Please provide \${resultCount} relevant search results. For each result, include:
1. Title
2. URL/Source
3. Brief snippet/summary
4. If there's only 1 result, also include more detailed content

Format your response as JSON with this structure:
{
  "results": [
    {
      "title": "Result Title",
      "url": "https://example.com",
      "snippet": "Brief description...",
      "content": "Detailed content (only for single results)"
    }
  ],
  "totalResults": number,
  "searchQuery": "\${query}"
}\`;

      const result = await model.generateContent(prompt);
      const response = await result.response;
      const text = response.text();
      
      // Parse JSON response
      try {
        const data = JSON.parse(text);
        return data.results || [];
      } catch (parseError) {
        // Fallback: create a single result with the full text
        return [{
          title: \`Search Results for "\${query}"\`,
          url: 'https://google.com/search?q=' + encodeURIComponent(query),
          snippet: text.substring(0, 200) + '...',
          content: text
        }];
      }
    } catch (error) {
      console.error('Gemini search error:', error);
      throw new Error(\`Search failed: \${error instanceof Error ? error.message : String(error)}\`);
    }
  }
}
`;

fs.writeFileSync('src/ai/geminiSearchClient.ts', geminiClientContent);
console.log('âœ… Created Gemini search client');
</file>

<file path="debug_commands.js">
// Debug commands to test in browser console
// After opening the app, paste these into the browser console:

console.log("=== Testing AI Command Parsing ===");

// Test 1: Simple content
console.log("\n1. Testing: 'open a window saying cheese'");
aiTester.testCommand("open a window saying cheese");

// Test 2: Multiple windows
console.log("\n2. Testing: 'open 7 windows saying hello'");
aiTester.testCommand("open 7 windows saying hello");

// Test 3: Close window
console.log("\n3. Testing: 'close window'");
aiTester.testCommand("close window");

// Test 4: Close all windows
console.log("\n4. Testing: 'close all windows'");
aiTester.testCommand("close all windows");

// Test 5: Check if fallback parsing is being used
console.log("\n5. Manual fallback test:");
// This will test the TaskParser directly
</file>

<file path="eslint.config.mjs">
import { dirname } from "path";
import { fileURLToPath } from "url";
import { FlatCompat } from "@eslint/eslintrc";

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

const compat = new FlatCompat({
  baseDirectory: __dirname,
});

const eslintConfig = [
  ...compat.extends("next/core-web-vitals", "next/typescript"),
  {
    ignores: [
      "node_modules/**",
      ".next/**",
      "out/**",
      "build/**",
      "next-env.d.ts",
    ],
  },
];

export default eslintConfig;
</file>

<file path="GEMINI_SETUP.md">
# Add this to your .env.local file:
GEMINI_API_KEY=your_gemini_api_key_here
</file>

<file path="implement_web_search.js">
const fs = require('fs');

// 1. Add web_search tool to tools.ts
let toolsContent = fs.readFileSync('src/ai/tools.ts', 'utf8');

const newTool = `,
  {
    name: 'web_search',
    description: 'Performs web search using Gemini with grounding and displays results in a window. Use this when user wants to search for information online.',
    parameters: {
      type: 'object',
      properties: {
        query: {
          type: 'string',
          description: 'The search query to look up'
        },
        resultCount: {
          type: 'number',
          description: 'Number of results to return (1-10, default 5)'
        },
        displayMode: {
          type: 'string',
          description: 'How to display results: summary (single result with summary), links (multiple results with titles/links), full (single result with full content)',
          enum: ['summary', 'links', 'full', 'auto']
        }
      },
      required: ['query']
    }
  }`;

// Insert before the closing ];
toolsContent = toolsContent.replace('  }\n];', `  }${newTool}\n];`);

fs.writeFileSync('src/ai/tools.ts', toolsContent);
console.log('âœ… Added web_search tool to tools.ts');

// 2. Add types to types.ts
let typesContent = fs.readFileSync('src/ai/types.ts', 'utf8');

const newTypes = `
export interface WebSearchParams {
  query: string;
  resultCount?: number;
  displayMode?: 'summary' | 'links' | 'full' | 'auto';
}

export interface SearchResult {
  title: string;
  url: string;
  snippet: string;
  content?: string;
}
`;

// Insert before the last export
typesContent = typesContent.replace(
  'export interface AIProcessingResult {',
  `${newTypes}
export interface AIProcessingResult {`
);

fs.writeFileSync('src/ai/types.ts', typesContent);
console.log('âœ… Added WebSearchParams types to types.ts');
</file>

<file path="install_gemini_package.js">
const fs = require('fs');

// Add @google/generative-ai to package.json
let packageContent = fs.readFileSync('package.json', 'utf8');
let packageJson = JSON.parse(packageContent);

// Add the dependency
if (!packageJson.dependencies) {
  packageJson.dependencies = {};
}

packageJson.dependencies['@google/generative-ai'] = '^0.21.0';

fs.writeFileSync('package.json', JSON.stringify(packageJson, null, 2));
console.log('âœ… Added @google/generative-ai to package.json');
</file>

<file path="next.config.ts">
import type { NextConfig } from "next";

const nextConfig: NextConfig = {
  /* config options here */
};

export default nextConfig;
</file>

<file path="postcss.config.mjs">
const config = {
  plugins: ["@tailwindcss/postcss"],
};

export default config;
</file>

<file path="PROJECT_STRUCTURE.md">
# Jarvis - Event-Driven Architecture

Clean, minimal Next.js project with event-driven architecture using a global event bus.

## Architecture

The project is partitioned into three main components that communicate only through the global event bus:

- **Input** (`src/input/`) - Handles input processing with webworker
- **AI** (`src/ai/`) - Manages AI operations with webworker  
- **UI** (`src/ui/`) - React components and user interface

## Directory Structure

```
src/
â”œâ”€â”€ app/                    # Next.js app directory
â”‚   â”œâ”€â”€ page.tsx           # Main page (instantiates MainUI)
â”‚   â””â”€â”€ layout.tsx         # Root layout
â”œâ”€â”€ input/                 # Input component
â”‚   â”œâ”€â”€ InputManager.ts    # Main input manager class
â”‚   â”œâ”€â”€ inputWorker.ts     # Web worker for async processing
â”‚   â””â”€â”€ index.ts          # Public exports
â”œâ”€â”€ ai/                    # AI component  
â”‚   â”œâ”€â”€ AIManager.ts       # Main AI manager class
â”‚   â”œâ”€â”€ aiWorker.ts        # Web worker for async processing
â”‚   â””â”€â”€ index.ts          # Public exports
â”œâ”€â”€ ui/                    # UI component
â”‚   â”œâ”€â”€ MainUI.tsx         # Main UI component
â”‚   â”œâ”€â”€ components/        # UI submodules directory
â”‚   â”‚   â””â”€â”€ README.md      # Component development guide
â”‚   â””â”€â”€ index.ts          # Public exports
â””â”€â”€ lib/                   # Shared utilities
    â””â”€â”€ eventBus.ts        # Global event bus implementation
```

## Event Bus

The global event bus (`src/lib/eventBus.ts`) provides:

- `on(event, callback)` - Subscribe to events
- `off(event, callback)` - Unsubscribe from events  
- `emit(event, data)` - Emit events
- `once(event, callback)` - Subscribe once
- `clear()` - Clear all listeners

## Component Communication

All components communicate through events:

- Input events: `input:*` (e.g., `input:input_processed`)
- AI events: `ai:*` (e.g., `ai:response_generated`)
- UI events: `ui:*` (for future UI-specific events)

## Development

Each component can be developed independently:

1. **Input**: Add processing logic to `InputManager.ts` and `inputWorker.ts`
2. **AI**: Add AI logic to `AIManager.ts` and `aiWorker.ts`  
3. **UI**: Add components to `src/ui/components/` following the README guide

## Getting Started

```bash
npm install
npm run dev
```

The application will initialize both webworkers and demonstrate the event bus communication with test buttons.
</file>

<file path="test_debug.js">
// Test debug script - run in browser console after loading the app

console.log("=== Debug Test for Multiple Windows and Close All ===");

// Test multiple windows parsing
async function testMultipleWindows() {
  console.log("\n--- Testing Multiple Windows ---");
  console.log("Command: 'open 7 windows saying cheese'");
  
  try {
    await aiTester.testCommand("open 7 windows saying cheese");
  } catch (e) {
    console.error("Error:", e);
  }
}

// Test close all windows
async function testCloseAll() {
  console.log("\n--- Testing Close All Windows ---");
  console.log("Command: 'close all windows'");
  
  try {
    await aiTester.testCommand("close all windows");
  } catch (e) {
    console.error("Error:", e);
  }
}

// Test window registry
function testWindowRegistry() {
  console.log("\n--- Testing Window Registry ---");
  console.log("Current windows in registry:", windowRegistry.getAll());
  console.log("Registry count:", windowRegistry.getAll().length);
}

// Run tests
console.log("Running tests...");
setTimeout(testMultipleWindows, 1000);
setTimeout(testCloseAll, 3000);
setTimeout(testWindowRegistry, 5000);
</file>

<file path="tsconfig.json">
{
  "compilerOptions": {
    "target": "ES2017",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": ["./src/*"]
    }
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
  "exclude": ["node_modules"]
}
</file>

<file path="update_cerebras_prompt.js">
const fs = require('fs');

// Update Cerebras prompt to include web search examples
let content = fs.readFileSync('src/ai/cerebrasClient.ts', 'utf8');

const newExamples = '- User: "search for the top 5 health risks for cardiac disease" â†’ web_search { query: "top 5 health risks cardiac disease", resultCount: 5, displayMode: "auto" }\\n- User: "open a window and search for AI news" â†’ web_search { query: "AI news", resultCount: 5, displayMode: "auto" }\\n- User: "look up information about quantum computing" â†’ web_search { query: "quantum computing information", resultCount: 5, displayMode: "auto" }\\n';

content = content.replace(
  '- User: "close all windows" â†’ close_window { selector: "all" }',
  '- User: "close all windows" â†’ close_window { selector: "all" }\\n' + newExamples
);

// Add web search guidance
const webSearchGuidance = '\\n\\nFor web search operations:\\n- Use web_search tool when user wants to search, look up, or find information online\\n- Extract the search query from natural language\\n- Set appropriate resultCount if specified (default 5)\\n- Use displayMode "auto" unless specified otherwise';

content = content.replace(
  'IMPORTANT: When user asks to open multiple windows (e.g., "open 5 windows"), create multiple separate tool calls, one for each window.',
  'IMPORTANT: When user asks to open multiple windows (e.g., "open 5 windows"), create multiple separate tool calls, one for each window.' + webSearchGuidance
);

fs.writeFileSync('src/ai/cerebrasClient.ts', content);
console.log('âœ… Updated Cerebras prompt with web search examples');
</file>

<file path="update_task_parser.js">
const fs = require('fs');

// Add search detection to taskParser.ts
let content = fs.readFileSync('src/ai/taskParser.ts', 'utf8');

// Add search detection in fallbackParsing after the open/create commands
const searchDetection = `
    // Search commands
    if (lowerText.includes('search') || lowerText.includes('look up') || lowerText.includes('find information')) {
      let searchQuery = '';
      let resultCount = 5;
      let displayMode = 'auto';

      // Extract search query patterns
      const searchPatterns = [
        /search\\s+for\\s+(.+?)$/i,
        /look\\s+up\\s+(.+?)$/i,
        /find\\s+information\\s+(?:about|on)\\s+(.+?)$/i,
        /(?:search|look\\s+up|find)\\s+["']([^"']+)["']/i,
        /(?:search|google|bing)\\s*[:.]?\\s*(.+?)$/i
      ];

      for (const pattern of searchPatterns) {
        const match = text.match(pattern);
        if (match && match[1]) {
          searchQuery = match[1].trim();
          break;
        }
      }

      // Extract result count if specified
      const countMatch = text.match(/(\\d+)\\s+(?:results?|top|first)/i);
      if (countMatch) {
        const n = parseInt(countMatch[1], 10);
        if (!isNaN(n) && n > 0 && n <= 10) resultCount = n;
      }

      // If we extracted a search query, create a search task
      if (searchQuery) {
        tasks.push({
          id: this.generateTaskId(),
          tool: 'web_search',
          parameters: {
            query: searchQuery,
            resultCount: resultCount,
            displayMode: displayMode
          },
          description: \`Search for: \${searchQuery}\`
        });
      }
    }
`;

// Insert after the open/create window logic
content = content.replace(
  '    }\n    \n    return tasks;',
  '    }' + searchDetection + '\n    \n    return tasks;'
);

fs.writeFileSync('src/ai/taskParser.ts', content);
console.log('âœ… Added search detection to taskParser.ts');
</file>

<file path="update_tool_executor.js">
const fs = require('fs');

// Add web search execution to toolExecutor.ts
let content = fs.readFileSync('src/ai/toolExecutor.ts', 'utf8');

// Add import
content = content.replace(
  'import { windowRegistry } from \'./windowRegistry\';',
  'import { windowRegistry } from \'./windowRegistry\';\nimport { GeminiSearchClient } from \'./geminiSearchClient\';'
);

// Add to types import
content = content.replace(
  'import { Task, OpenWindowParams, CloseWindowParams } from \'./types\';',
  'import { Task, OpenWindowParams, CloseWindowParams, WebSearchParams } from \'./types\';'
);

// Add to constructor
content = content.replace(
  'export class ToolExecutor {',
  'export class ToolExecutor {\n  private geminiSearchClient: GeminiSearchClient;\n\n  constructor() {\n    try {\n      this.geminiSearchClient = new GeminiSearchClient();\n    } catch (error) {\n      console.warn(\'[ToolExecutor] Gemini search not available:\', error);\n    }\n  }'
);

// Add case for web_search
content = content.replace(
  'case \'close_window\':\n          result = await this.executeCloseWindow(task);\n          break;',
  'case \'close_window\':\n          result = await this.executeCloseWindow(task);\n          break;\n        \n        case \'web_search\':\n          result = await this.executeWebSearch(task);\n          break;'
);

// Add executeWebSearch method before generateWindowId
const webSearchMethod = `
  private async executeWebSearch(task: Task): Promise<ExecutionResult> {
    const params = task.parameters as WebSearchParams;
    eventBus.emit('ai:tool_call_started', { task, tool: 'web_search', params });

    try {
      if (!this.geminiSearchClient) {
        throw new Error('Gemini search client not available. Check GEMINI_API_KEY.');
      }

      // Validate parameters
      if (!params.query) {
        throw new Error('Missing required parameter: query');
      }

      const resultCount = params.resultCount || 5;
      const displayMode = params.displayMode || 'auto';

      // Perform search
      const searchResults = await this.geminiSearchClient.searchWithGrounding(
        params.query, 
        resultCount
      );

      if (searchResults.length === 0) {
        throw new Error('No search results found');
      }

      // Determine display mode
      let finalDisplayMode = displayMode;
      if (displayMode === 'auto') {
        finalDisplayMode = searchResults.length === 1 ? 'summary' : 'links';
      }

      // Generate window content based on display mode
      let windowContent = '';
      let windowTitle = \`Search: \${params.query}\`;

      if (finalDisplayMode === 'summary' && searchResults[0]) {
        const result = searchResults[0];
        windowContent = \`**\${result.title}**

\${result.content || result.snippet}

Source: \${result.url}\`;
      } else if (finalDisplayMode === 'full' && searchResults[0]) {
        const result = searchResults[0];
        windowContent = \`# \${result.title}

\${result.content || result.snippet}

---
**Source:** \${result.url}\`;
      } else {
        // Links mode - multiple results
        windowContent = \`**Search Results for "\${params.query}"**

\${searchResults.map((result, index) => 
  \`\${index + 1}. **\${result.title}**
   \${result.snippet}
   ðŸ”— \${result.url}
\`).join('\\n\\n')}

Found \${searchResults.length} result\${searchResults.length === 1 ? '' : 's'}\`;
      }

      // Generate a unique window ID
      const windowId = this.generateWindowId();

      // Create window data
      const windowData = {
        id: windowId,
        type: 'search-results',
        title: windowTitle,
        content: windowContent,
        position: { x: 150, y: 150 },
        size: { width: 600, height: 400 },
        context: {
          title: windowTitle,
          content: windowContent,
          type: 'search-results',
          metadata: {
            searchQuery: params.query,
            resultCount: searchResults.length,
            displayMode: finalDisplayMode,
            results: searchResults
          }
        },
        timestamp: Date.now()
      };

      // Emit to event bus for UI to handle
      eventBus.emit('ui:open_window', windowData);
      eventBus.emit('window:opened', windowData);

      // Forward to worker if needed
      try {
        if (typeof self !== 'undefined' && typeof (self as any).postMessage === 'function' && typeof (globalThis as any).window === 'undefined') {
          (self as any).postMessage({ type: 'UI_OPEN_WINDOW', data: windowData });
        }
      } catch (_) {
        // no-op
      }

      console.log(\`[ToolExecutor] Web search completed for: "\${params.query}"\`, windowData);

      const result = {
        taskId: task.id,
        success: true,
        result: {
          windowId: windowId,
          searchQuery: params.query,
          resultCount: searchResults.length,
          displayMode: finalDisplayMode,
          searchResults: searchResults
        },
        timestamp: Date.now()
      };

      eventBus.emit('ai:tool_call_completed', { task, tool: 'web_search', result });
      return result;

    } catch (error) {
      const errorMsg = error instanceof Error ? error.message : String(error);
      console.error('[ToolExecutor] Web search failed:', errorMsg);
      
      eventBus.emit('ai:tool_call_failed', { task, tool: 'web_search', error: errorMsg });
      
      return {
        taskId: task.id,
        success: false,
        error: errorMsg,
        timestamp: Date.now()
      };
    }
  }
`;

// Insert the method before generateWindowId
content = content.replace(
  '  private generateWindowId(): string {',
  webSearchMethod + '\n  private generateWindowId(): string {'
);

fs.writeFileSync('src/ai/toolExecutor.ts', content);
console.log('âœ… Added web search execution to toolExecutor.ts');
</file>

<file path="src/ai/README.md">
# Jarvis AI System

This is the AI component of the Jarvis project that converts natural language text commands into structured tasks and executes them using available tools.

## Architecture

```
Text Input â†’ TaskParser â†’ ToolExecutor â†’ Event Bus â†’ UI
             (Cerebras)    (Local)       (Events)
```

## Components

### 1. TaskParser (`taskParser.ts`)
- Converts natural language text to structured tasks using Cerebras API
- Includes fallback parsing for simple commands when Cerebras is unavailable
- Handles complex multi-command inputs

### 2. ToolExecutor (`toolExecutor.ts`)
- Executes parsed tasks using available tools
- Emits events to the UI via the event bus
- Manages tool parameter validation and error handling

### 3. CerebrasClient (`cerebrasClient.ts`)
- Handles communication with Cerebras API
- Manages API requests, authentication, and error handling
- Configurable model and parameters

### 4. Tools (`tools.ts`)
- Defines available tools (currently: open_window, close_window)
- Tool schema definitions for Cerebras function calling
- Tool discovery and validation utilities

### 5. AIManager (`AIManager.ts`)
- Main interface for the AI system
- Manages the AI worker thread
- Provides methods for processing text commands

### 6. AI Worker (`aiWorker.ts`)
- Web Worker for non-blocking AI processing
- Coordinates TaskParser and ToolExecutor
- Handles different message types and error scenarios

### 7. Tester (`tester.ts`)
- Comprehensive testing utilities for the AI system
- Predefined test commands and interactive testing
- Event monitoring and debugging tools

## Setup

### Prerequisites
1. Cerebras API key (set as `CEREBRAS_API_KEY` environment variable)
2. Node.js and npm/pnpm installed

### Configuration
Create a `.env.local` file in the project root:
```
CEREBRAS_API_KEY=your_cerebras_api_key_here
```

## Usage

### Basic Text Command Processing
```typescript
import { aiManager } from '@/ai';

// Initialize the AI manager
await aiManager.initialize();

// Process a text command
aiManager.processTextCommand("open a sticky note saying 'Hello World'");

// Listen for results
eventBus.on('ai:text_command_processed', (result) => {
  console.log('Command processed:', result);
});
```

### Using Individual Components
```typescript
import { TaskParser, ToolExecutor } from '@/ai';

const parser = new TaskParser();
const executor = new ToolExecutor();

// Parse text to tasks
const result = await parser.parseTextToTasks("create a notification window");

// Execute tasks
const executionResults = await executor.executeTasks(result.tasks);
```

### Testing
```typescript
import { aiTester } from '@/ai';

// Run all predefined tests
await aiTester.runTests();

// Test a specific command
await aiTester.testCommand("open a settings dialog");

// Interactive testing (also available in browser console as window.aiTester)
aiTester.interactive();
```

## Available Tools

### open_window
Opens a new popup window with specified type and context.

**Parameters:**
- `windowType`: string - Type of window (notification, dialog, settings, sticky-note, general)
- `context`: object - Window context information
  - `title`: string - Window title
  - `content`: string - Window content
  - `type`: string - Window type
  - `position`: {x, y} - Optional position
  - `size`: {width, height} - Optional size
  - `metadata`: object - Optional education-specific metadata (e.g., `lessonId`, `step`, `quizQuestions`)

**Examples:**
```
"open a sticky note saying 'Buy groceries'"
```

```
"start lesson 'Derivatives' step 1"
```

```
"open a quiz titled 'Chapter 3 Review'"
```

```
"give me a hint about 'Pythagorean theorem'"
```

```
"explain 'binary search' step by step"
```

### close_window
Closes an existing window by its ID.

**Parameters:**
- `windowId`: string - Unique identifier of the window to close

**Example:**
```
"close window window_123456"
```

## Event System

The AI system communicates with the UI through the event bus:

### Emitted Events
- `ai:text_command_processed` - When a text command is successfully processed
- `ai:error` - When an error occurs in AI processing
- `ui:open_window` - Instructs UI to open a window
- `ui:close_window` - Instructs UI to close a window
- `window:opened` - General window opened event
- `window:closed` - General window closed event

### Event Data Formats

**text_command_processed:**
```typescript
{
  id: string;
  success: boolean;
  originalText: string;
  tasks: Task[];
  executionResults: ExecutionResult[];
  processingTime: number;
  timestamp: number;
}
```

**ui:open_window:**
```typescript
{
  id: string;
  type: string;
  title: string;
  content: string;
  position: {x: number, y: number};
  size: {width: number, height: number};
  context: WindowContext;
  timestamp: number;
}
```

## Error Handling

The system includes comprehensive error handling:

1. **Cerebras API failures** - Falls back to rule-based parsing
2. **Invalid tool parameters** - Validates parameters before execution
3. **Network errors** - Graceful degradation with fallback parsing
4. **Worker errors** - Error propagation through event system

## Development

### Adding New Tools

1. Define the tool in `tools.ts`:
```typescript
{
  name: 'my_new_tool',
  description: 'Description of what the tool does',
  parameters: {
    type: 'object',
    properties: {
      param1: {
        type: 'string',
        description: 'Parameter description',
        required: true
      }
    },
    required: ['param1']
  }
}
```

2. Add execution logic in `toolExecutor.ts`:
```typescript
case 'my_new_tool':
  return await this.executeMyNewTool(task);
```

3. Update fallback parsing in `taskParser.ts` if needed

### Testing New Features

Use the comprehensive testing utilities:

```typescript
// Test individual commands
await aiTester.testCommand("your new command");

// Add to predefined tests in tester.ts
// Monitor events in real-time
aiTester.listenToEvents();
```

## Notes

- The AI system runs in a Web Worker to avoid blocking the main thread
- Cerebras API integration uses function calling for structured outputs
- Fallback parsing ensures the system works even without API access
- All components are modular and can be used independently
- Event-driven architecture allows for loose coupling with UI components
</file>

<file path="src/ai/tester.ts">
/* eslint-disable @typescript-eslint/no-explicit-any */
/**
 * AI System Tester
 * 
 * This is a basic testing utility for the Jarvis AI system.
 * It allows you to test text commands and see how they get parsed into tasks
 * and executed by the tool system.
 * 
 * Usage:
 * - Import this file and call runTests() to run predefined tests
 * - Use testCommand(text) to test individual commands
 * - Use listenToEvents() to see real-time AI processing events
 */

import { TaskParser } from './taskParser';
import { ToolExecutor } from './toolExecutor';
import { eventBus } from '@/lib/eventBus';

export class AITester {
  private taskParser: TaskParser;
  private toolExecutor: ToolExecutor;
  private eventListeners: (() => void)[] = [];
  private requestQueue: Promise<void> = Promise.resolve();

  constructor() {
    this.taskParser = new TaskParser();
    this.toolExecutor = new ToolExecutor();
  }

  /**
   * Test a single text command
   */
  async testCommand(text: string): Promise<void> {
    this.requestQueue = this.requestQueue.then(async () => {
      console.log(`\nðŸ§ª Testing command: "${text}"`);
      console.log('â”€'.repeat(50));

      try {
        // Parse the command (may use Cerebras; fallback handles offline/rate limits)
        console.log('ðŸ“ Parsing command...');
        const parseResult = await this.taskParser.parseTextToTasks(text);

        if (!parseResult.success) {
          console.error('âŒ Parsing failed:', parseResult.error);
          return;
        }

        console.log(`âœ… Parsed ${parseResult.tasks.length} task(s):`);
        parseResult.tasks.forEach((task, index) => {
          console.log(`   ${index + 1}. ${task.description}`);
          console.log(`      Tool: ${task.tool}`);
          console.log(`      Parameters:`, task.parameters);
        });

        // Execute the tasks
        console.log('\nâš¡ Executing tasks...');
        const executionResults = await this.toolExecutor.executeTasks(parseResult.tasks);

        executionResults.forEach((result, index) => {
          if (result.success) {
            console.log(`   âœ… Task ${index + 1} executed successfully`);
            if (result.result) {
              console.log(`      Result:`, result.result);
            }
          } else {
            console.log(`   âŒ Task ${index + 1} failed:`, result.error);
          }
        });

        console.log('â”€'.repeat(50));
        console.log('âœ¨ Test completed\n');

      } catch (error) {
        console.error('ðŸ’¥ Test failed with error:', error);
      }
    });

    return this.requestQueue;
  }

  /**
   * Run a suite of predefined tests
   */
  async runTests(): Promise<void> {
    console.log('ðŸš€ Starting AI System Tests');
    console.log('â•'.repeat(60));

    const testCommands = [
      // Simple window operations
      'open a window',
      'create a sticky note',
      'close window window_123',
      
      // Complex commands
      'open a sticky note that says "Remember to buy groceries"',
      'create a notification window titled "Meeting Alert"',
      'open a settings dialog and close window abc123',
      
      // Edge cases
      'show me a "Project Ideas" sticky note',
      'close all windows', // This should fail gracefully
      '', // Empty command
      
      // Natural language variations
      'I need a reminder note about the dentist appointment',
      'please open a window for the user settings',
      'dismiss window xyz789',

      // Education-focused commands
      'start lesson "Derivatives" step 1',
      'open a quiz titled "Chapter 3 Review"',
      'give me a hint about "Pythagorean theorem"',
      'explain "binary search" step by step'
    ];

    for (const command of testCommands) {
      await this.testCommand(command);
      // Small delay between tests for readability
      await new Promise(resolve => setTimeout(resolve, 500));
    }

    console.log('ðŸŽ‰ All tests completed!');
  }

  /**
   * Listen to AI events in real-time
   */
  listenToEvents(): void {
    console.log('ðŸ‘‚ Listening to AI events...');
    
    // Clear existing listeners
    this.clearEventListeners();

    const unsubscribers = [
      eventBus.on('ai:text_command_processed', (data: any) => {
        console.log('ðŸ¤– Text command processed:', data);
      }),
      
      eventBus.on('ai:error', (error: any) => {
        console.error('ðŸš¨ AI Error:', error);
      }),
      
      eventBus.on('ui:open_window', (data: any) => {
        console.log('ðŸªŸ Window opened:', data);
      }),
      
      eventBus.on('ui:close_window', (data: any) => {
        console.log('ðŸ”² Window closed:', data);
      }),
      
      eventBus.on('window:opened', (data: any) => {
        console.log('ðŸ“Š Window event - opened:', data);
      }),
      
      eventBus.on('window:closed', (data: any) => {
        console.log('ðŸ“Š Window event - closed:', data);
      })
    ];

    this.eventListeners = unsubscribers;
  }

  /**
   * Stop listening to events
   */
  clearEventListeners(): void {
    this.eventListeners.forEach(unsubscribe => unsubscribe());
    this.eventListeners = [];
  }

  /**
   * Test the Cerebras integration specifically
   */
  async testCerebrasIntegration(): Promise<void> {
    console.log('ðŸ§  Testing Cerebras Integration');
    console.log('â”€'.repeat(40));

    try {
      const testText = 'open a sticky note saying "test cerebras"';
      console.log(`Testing with: "${testText}"`);
      
      const result = await this.taskParser.parseTextToTasks(testText);
      
      if (result.success) {
        console.log('âœ… Cerebras integration working');
        console.log('Raw response available:', !!result.rawResponse);
        if (result.rawResponse) {
          console.log('Model used:', result.rawResponse.model);
          console.log('Token usage:', result.rawResponse.usage);
          console.log('Tasks created:', result.tasks.length);
        }
      } else {
        console.log('âš ï¸ Cerebras integration failed, using fallback parsing');
        console.log('Error:', result.error);
        console.log('Fallback tasks created:', result.tasks.length);
      }
    } catch (error) {
      console.error('âŒ Cerebras test failed:', error);
    }
  }

  /**
   * Quick test for model verification
   */
  async testModelOnly(): Promise<void> {
    console.log('ðŸ” Testing Model Access');
    console.log('â”€'.repeat(30));
    
    try {
      const simpleText = 'hello';
      const result = await this.taskParser.parseTextToTasks(simpleText);
      
      if (result.rawResponse) {
        console.log('âœ… Model accessible:', result.rawResponse.model);
      } else {
        console.log('âš ï¸ Using fallback parsing');
      }
    } catch (error) {
      console.error('âŒ Model test failed:', error);
    }
  }

  /**
   * Interactive testing - call this to test commands manually
   */
  async interactive(): Promise<void> {
    console.log('ðŸŽ® Interactive AI Testing Mode');
    console.log('Use aiTester.testCommand("your command") to test commands');
    console.log('Use aiTester.runTests() to run all predefined tests');
    console.log('Use aiTester.listenToEvents() to monitor events');
    
    // Start listening to events by default
    this.listenToEvents();
  }
}

// Create a global instance for easy testing
export const aiTester = new AITester();

// Auto-start interactive mode when this file is imported
if (typeof window !== 'undefined') {
  (window as any).aiTester = aiTester;
  // Expose the event bus for console-based inspection and custom listeners
  (window as any).eventBus = eventBus;
  console.log('ðŸ§ª AI Tester loaded! Use window.aiTester in browser console');
  console.log('ðŸ”Œ EventBus exposed as window.eventBus');
}
</file>

<file path="src/app/globals.css">
@import "tailwindcss";

:root {
  --background: #0a0a0a;
  --foreground: #ededed;
}

body {
  background: var(--background);
  color: var(--foreground);
  font-family: Arial, Helvetica, sans-serif;
}
</file>

<file path="src/input/speechService.ts">
/* eslint-disable @typescript-eslint/no-explicit-any */
import { eventBus } from '@/lib/eventBus';

export interface SpeechRecognitionEvent extends Event {
  results: SpeechRecognitionResultList;
  resultIndex: number;
}

export interface SpeechRecognition extends EventTarget {
  continuous: boolean;
  interimResults: boolean;
  lang: string;
  start(): void;
  stop(): void;
  abort(): void;
  onstart: ((this: SpeechRecognition, ev: Event) => any) | null;
  onend: ((this: SpeechRecognition, ev: Event) => any) | null;
  onresult: ((this: SpeechRecognition, ev: SpeechRecognitionEvent) => any) | null;
  onerror: ((this: SpeechRecognition, ev: Event) => any) | null;
}

declare global {
  interface Window {
    SpeechRecognition: new () => SpeechRecognition;
    webkitSpeechRecognition: new () => SpeechRecognition;
  }
}

export class SpeechTranscriptionService {
  private recognition: SpeechRecognition | null = null;
  private isListening = false;
  private isSupported = false;
  private isInitialized = false;
  private lastFinalCumulative = '';

  constructor() {
    // Don't check support in constructor - do it during initialization
  }

  private checkSupport(): void {
    if (typeof window === 'undefined') {
      this.isSupported = false;
      return;
    }

    this.isSupported = 'SpeechRecognition' in window || 'webkitSpeechRecognition' in window;

    if (!this.isSupported) {
      console.warn('Speech recognition not supported in this browser');
      eventBus.emit('speech:unsupported');
    }
  }

  initialize(): boolean {
    if (this.isInitialized) {
      return this.isSupported;
    }

    this.checkSupport();
    this.isInitialized = true;

    if (!this.isSupported) {
      return false;
    }

    try {
      const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
      this.recognition = new SpeechRecognition();

      this.recognition.continuous = true;
      this.recognition.interimResults = true;
      this.recognition.lang = 'en-US';

      // Maximize sensitivity and responsiveness
      if ('maxAlternatives' in this.recognition) {
        (this.recognition as any).maxAlternatives = 1;
      }
      if ('serviceURI' in this.recognition) {
        // Some browsers support additional config
      }

      this.setupEventHandlers();

      eventBus.emit('speech:initialized');
      return true;
    } catch (error) {
      console.error('Failed to initialize speech recognition:', error);
      eventBus.emit('speech:error', error);
      return false;
    }
  }

  private setupEventHandlers(): void {
    if (!this.recognition) return;

    this.recognition.onstart = () => {
      this.isListening = true;
      // Reset cumulative tracker at the start of each session
      this.lastFinalCumulative = '';
      eventBus.emit('speech:started');
    };

    this.recognition.onend = () => {
      // Mark as not listening; restart is coordinated by the hook
      this.isListening = false;
      eventBus.emit('speech:ended');
    };

    this.recognition.onresult = (event: SpeechRecognitionEvent) => {
      let fullTranscript = '';
      let lastInterim = '';

      // Get all results for continuous stream
      for (let i = 0; i < event.results.length; i++) {
        const transcript = event.results[i][0].transcript;

        if (event.results[i].isFinal) {
          fullTranscript += transcript;
        } else {
          lastInterim = transcript;
        }
      }

      // Compute delta of newly finalized portion relative to previous cumulative
      let finalDelta = '';
      if (fullTranscript.startsWith(this.lastFinalCumulative)) {
        finalDelta = fullTranscript.slice(this.lastFinalCumulative.length);
      } else {
        // Fallback: find common prefix length and take the suffix as delta
        const commonLength = this.getCommonPrefixLength(this.lastFinalCumulative, fullTranscript);
        finalDelta = fullTranscript.slice(commonLength);
      }

      // Update cumulative tracker
      this.lastFinalCumulative = fullTranscript;

      // Always emit the most recent interim result for continuous stream
      const currentText = (fullTranscript + lastInterim).trim();

      eventBus.emit('speech:transcript', {
        final: finalDelta,
        interim: lastInterim,
        fullText: currentText,
        timestamp: Date.now()
      });

      // Also emit individual words as they're detected
      if (lastInterim) {
        const words = lastInterim.trim().split(/\s+/);
        const lastWord = words[words.length - 1];
        if (lastWord && lastWord.length > 0) {
          eventBus.emit('speech:word', {
            word: lastWord,
            confidence: event.results[event.results.length - 1][0].confidence || 1,
            timestamp: Date.now()
          });
        }
      }
    };

    this.recognition.onerror = (event: any) => {
      console.error('Speech recognition error:', event.error);

      // Don't emit error for no-speech since we want continuous listening through silence
      if (event.error !== 'no-speech') {
        eventBus.emit('speech:error', event.error);
      }

      // Handle fatal errors by stopping completely
      if (event.error === 'not-allowed' || event.error === 'service-not-allowed') {
        this.isListening = false;
        return;
      }
    };
  }

  start(): boolean {
    if (!this.recognition || this.isListening) {
      return false;
    }

    try {
      this.recognition.start();
      return true;
    } catch (error) {
      console.error('Failed to start speech recognition:', error);
      eventBus.emit('speech:error', error);
      return false;
    }
  }

  stop(): void {
    if (!this.recognition || !this.isListening) {
      return;
    }

    this.isListening = false;
    this.recognition.stop();
  }

  abort(): void {
    if (!this.recognition) {
      return;
    }

    this.isListening = false;
    this.recognition.abort();
  }

  getIsListening(): boolean {
    return this.isListening;
  }

  getIsSupported(): boolean {
    if (!this.isInitialized && typeof window !== 'undefined') {
      this.checkSupport();
      this.isInitialized = true;
    }
    return this.isSupported;
  }

  private getCommonPrefixLength(a: string, b: string): number {
    const minLen = Math.min(a.length, b.length);
    let i = 0;
    while (i < minLen && a.charCodeAt(i) === b.charCodeAt(i)) {
      i++;
    }
    return i;
  }
}

export const speechService = new SpeechTranscriptionService();
</file>

<file path="src/input/useSpeechTranscription.ts">
'use client';

import { useEffect, useState, useCallback, useRef } from 'react';
import { speechService } from './speechService';
import { eventBus } from '@/lib/eventBus';

export interface TranscriptData {
  final: string;
  interim: string;
  fullText: string;
  timestamp: number;
}

export interface WordData {
  word: string;
  confidence: number;
  timestamp: number;
}

export interface UseSpeechTranscriptionOptions {
  autoStart?: boolean;
  continuous?: boolean;
  onTranscript?: (data: TranscriptData) => void;
  onWord?: (data: WordData) => void;
  onError?: (error: string) => void;
}

export interface UseSpeechTranscriptionReturn {
  isListening: boolean;
  isSupported: boolean;
  accumulatedTranscript: string;
  interimTranscript: string;
  fullText: string;
  start: () => boolean;
  stop: () => void;
  toggle: () => void;
  clear: () => void;
}

export function useSpeechTranscription(
  options: UseSpeechTranscriptionOptions = {}
): UseSpeechTranscriptionReturn {
  const {
    autoStart = false,
    continuous = true,
    onTranscript,
    onWord,
    onError
  } = options;

  const [isListening, setIsListening] = useState(false);
  const [isSupported, setIsSupported] = useState(true);
  const [accumulatedTranscript, setAccumulatedTranscript] = useState('');
  const [interimTranscript, setInterimTranscript] = useState('');
  const [fullText, setFullText] = useState('');

  const isInitialized = useRef(false);
  const shouldRestart = useRef(continuous);

  // Initialize speech service
  useEffect(() => {
    if (isInitialized.current) return;

    const initialized = speechService.initialize();
    setIsSupported(initialized);
    isInitialized.current = true;

    if (initialized && autoStart) {
      speechService.start();
    }
  }, [autoStart]);

  // Set up event listeners
  useEffect(() => {
    const unsubscribers = [
      eventBus.on('speech:transcript', (data: TranscriptData) => {
        if (data.final && data.final.trim()) {
          setAccumulatedTranscript(prev => {
            const newText = prev ? prev + ' ' + data.final.trim() : data.final.trim();
            const trimmed = newText.length > 10000 ? newText.slice(-10000) : newText;
            setFullText(trimmed + (data.interim ? ' ' + data.interim : ''));
            return trimmed;
          });
        } else {
          setAccumulatedTranscript(prev => {
            setFullText(prev + (data.interim ? ' ' + data.interim : ''));
            return prev;
          });
        }
        setInterimTranscript(data.interim);

        onTranscript?.(data);
      }),

      eventBus.on('speech:word', (data: WordData) => {
        onWord?.(data);
      }),

      eventBus.on('speech:started', () => {
        setIsListening(true);
      }),

      eventBus.on('speech:ended', () => {
        setIsListening(false);

        // Auto-restart if continuous mode is enabled
        if (shouldRestart.current && continuous) {
          setTimeout(() => {
            speechService.start();
          }, 100);
        }
      }),

      eventBus.on('speech:error', (error: string) => {
        console.error('Speech recognition error:', error);

        // Don't change listening state for no-speech errors since we want continuous listening
        if (error !== 'no-speech') {
          onError?.(error);
        }

        // Handle fatal errors by stopping restart
        if (error === 'not-allowed' || error === 'service-not-allowed') {
          shouldRestart.current = false;
          setIsListening(false);
          return;
        }

        // Auto-restart on certain errors if continuous
        if (continuous && shouldRestart.current) {
          if (error === 'no-speech') {
            // Faster restart for silence, don't change UI state
            setTimeout(() => {
              speechService.start();
            }, 100);
          } else if (error === 'audio-capture' || error === 'network') {
            setTimeout(() => {
              speechService.start();
            }, 1000);
          }
        }
      }),

      eventBus.on('speech:unsupported', () => {
        setIsSupported(false);
      })
    ];

    return () => {
      unsubscribers.forEach(unsub => unsub());
    };
  }, [continuous, onTranscript, onWord, onError]);

  // Cleanup on unmount
  useEffect(() => {
    return () => {
      shouldRestart.current = false;
      speechService.stop();
    };
  }, []);

  const start = useCallback((): boolean => {
    if (!isSupported) return false;

    shouldRestart.current = true;
    return speechService.start();
  }, [isSupported]);

  const stop = useCallback((): void => {
    shouldRestart.current = false;
    speechService.stop();
    setInterimTranscript('');
  }, []);

  const clear = useCallback((): void => {
    setAccumulatedTranscript('');
    setInterimTranscript('');
    setFullText('');
  }, []);

  const toggle = useCallback((): void => {
    if (isListening) {
      stop();
    } else {
      start();
    }
  }, [isListening, start, stop]);

  return {
    isListening,
    isSupported,
    accumulatedTranscript,
    interimTranscript,
    fullText,
    start,
    stop,
    toggle,
    clear
  };
}
</file>

<file path="src/input/VoiceTaskListener.tsx">
'use client';

import { useCallback, useEffect, useMemo, useRef, useState } from 'react';
import { eventBus } from '@/lib/eventBus';
import { useSpeechTranscription } from './useSpeechTranscription';

type Status = 'idle' | 'listening' | 'processing' | 'error';

interface CerebrasResult {
  tasks?: string[];
  remainder?: string;
}

export function VoiceTaskListener() {
  const [buffer, setBuffer] = useState('');
  const [status, setStatus] = useState<Status>('idle');
  const [lastError, setLastError] = useState('');
  const [apiCallTimestamps, setApiCallTimestamps] = useState<number[]>([]);
  const [nextCallAt, setNextCallAt] = useState<number | null>(null);
  const [isOnline, setIsOnline] = useState(
    typeof navigator !== 'undefined' ? navigator.onLine : true
  );

  const bufferRef = useRef(buffer);
  const apiCallTimestampsRef = useRef(apiCallTimestamps);
  const processingRef = useRef(false);
  const scheduledTimeoutRef = useRef<number | null>(null);
  const scheduledForRef = useRef<number | null>(null);
  const callStartBufferLengthRef = useRef(0);
  const lastBufferAppendAtRef = useRef<number>(0);

  const MIN_SPACING_MS = 3000; // ~20 calls/min evenly spaced
  const MIN_DEBOUNCE_MS = 300; // slight coalescing of bursts

  const cleanOld = useCallback((timestamps: number[]): number[] => {
    const cutoff = Date.now() - 60000;
    return timestamps.filter(t => t > cutoff);
  }, []);

  useEffect(() => { bufferRef.current = buffer; }, [buffer]);
  useEffect(() => { apiCallTimestampsRef.current = apiCallTimestamps; }, [apiCallTimestamps]);

  const { isListening, isSupported } = useSpeechTranscription({
    autoStart: true,
    continuous: true,
    onTranscript: (data) => {
      if (data.final && data.final.trim()) {
        setBuffer(prev => (prev ? prev + ' ' : '') + data.final.trim());
        lastBufferAppendAtRef.current = Date.now();
        scheduleProcessing();
      }
    },
    onError: (error) => {
      // Treat permission/network errors as errors; no-op for 'no-speech'
      if (error !== 'no-speech') {
        setStatus('error');
        setLastError(String(error));
      }
    }
  });

  // Compute and emit debug info whenever core state changes
  useEffect(() => {
    const recent = cleanOld(apiCallTimestampsRef.current);
    eventBus.emit('input:voice_debug', {
      status: !isSupported ? 'error' : processingRef.current ? 'processing' : isListening ? 'listening' : 'idle',
      bufferLength: bufferRef.current.length,
      apiCallsUsedLastMinute: recent.length,
      nextCallInMs: nextCallAt ? Math.max(0, nextCallAt - Date.now()) : null,
      lastError: lastError || null,
      isOnline,
      isSupported
    });
  }, [buffer, apiCallTimestamps, nextCallAt, lastError, isOnline, isListening, isSupported, cleanOld]);

  // Online/offline monitoring
  useEffect(() => {
    const handleOnline = () => {
      setIsOnline(true);
      setLastError('');
      if (bufferRef.current) scheduleProcessing();
    };
    const handleOffline = () => {
      setIsOnline(false);
      setStatus('error');
      setLastError('Network disconnected');
    };
    window.addEventListener('online', handleOnline);
    window.addEventListener('offline', handleOffline);
    return () => {
      window.removeEventListener('online', handleOnline);
      window.removeEventListener('offline', handleOffline);
    };
  }, []);

  // Track listening status for status display
  useEffect(() => {
    if (!isSupported) {
      setStatus('error');
      setLastError('Speech recognition not supported');
      return;
    }
    if (processingRef.current) return;
    setStatus(isListening ? 'listening' : 'idle');
  }, [isListening, isSupported]);

  const scheduleTimer = useCallback((delayMs: number) => {
    if (scheduledTimeoutRef.current !== null) {
      clearTimeout(scheduledTimeoutRef.current);
      scheduledTimeoutRef.current = null;
    }
    const runAt = Date.now() + delayMs;
    scheduledForRef.current = runAt;
    setNextCallAt(runAt);
    scheduledTimeoutRef.current = window.setTimeout(() => {
      scheduledTimeoutRef.current = null;
      scheduledForRef.current = null;
      setNextCallAt(null);
      attemptProcessing();
    }, delayMs);
  }, []);

  const scheduleProcessing = useCallback(() => {
    if (!isSupported || !isOnline) return;
    if (!bufferRef.current || processingRef.current) {
      // If processing, it will reschedule on completion if needed
      return;
    }

    const now = Date.now();
    const recent = cleanOld(apiCallTimestampsRef.current);
    const capWait = recent.length >= 20 ? (60000 - (now - recent[0])) : 0;
    const spacingWait = recent.length > 0 ? Math.max(0, (recent[recent.length - 1] + MIN_SPACING_MS) - now) : 0;
    let waitMs = Math.max(capWait, spacingWait, MIN_DEBOUNCE_MS);

    // If a timer exists but our new calculation is earlier, reschedule
    const desiredRunAt = now + waitMs;
    if (scheduledForRef.current == null || desiredRunAt < scheduledForRef.current) {
      scheduleTimer(waitMs);
    }
  }, [MIN_SPACING_MS, MIN_DEBOUNCE_MS, cleanOld, isOnline, isSupported, scheduleTimer]);

  const attemptProcessing = useCallback(() => {
    if (!isSupported || !isOnline) return;
    if (!bufferRef.current) return;
    if (processingRef.current) return;

    const now = Date.now();
    const recent = cleanOld(apiCallTimestampsRef.current);

    if (recent.length >= 20) {
      const wait = 60000 - (now - recent[0]);
      if (wait > 0) scheduleTimer(wait);
      return;
    }

    const spacingWait = recent.length > 0 ? Math.max(0, (recent[recent.length - 1] + MIN_SPACING_MS) - now) : 0;
    if (spacingWait > 0) {
      scheduleTimer(spacingWait);
      return;
    }

    processNow();
  }, [MIN_SPACING_MS, cleanOld, isOnline, isSupported, scheduleTimer]);

  const processNow = useCallback(() => {
    const currentBuffer = bufferRef.current;
    if (!currentBuffer) return;

    processingRef.current = true;
    setStatus('processing');
    setLastError('');

    // Count this call immediately for rate limiting
    setApiCallTimestamps(prev => {
      const next = cleanOld([...prev, Date.now()]);
      return next;
    });

    // Remember how much of the buffer we're sending
    callStartBufferLengthRef.current = currentBuffer.length;

    const MAX_PROMPT_CHARS = 2000;
    const baseText = currentBuffer.length > MAX_PROMPT_CHARS
      ? currentBuffer.slice(-MAX_PROMPT_CHARS)
      : currentBuffer;

    const now = Date.now();
    const lastAppend = lastBufferAppendAtRef.current || now;
    const silenceMs = Math.max(0, now - lastAppend);
    const textWithSilence = silenceMs > 500
      ? `${baseText} [silence for ${(silenceMs / 1000).toFixed(1)} seconds]`
      : baseText;

    const prompt = `Reasoning: none. Respond immediately.\n` +
      `Analyze the following transcribed speech and extract any specific, actionable tasks.\n` +
      `Guidelines:\n- Be cautious not to extract tasks from incomplete fragments.\n- If a simple, complete command is followed by a silence indicator, assume it's complete and extract it.\n\n` +
      `Return a JSON response with:\n` +
      `1. "tasks": array of specific actionable tasks found\n` +
      `2. "remainder": any text that might be part of an incomplete task\n\n` +
      `Text: "${textWithSilence}"\n\n` +
      `Respond ONLY with valid JSON.`;

    fetch('/api/cerebras-tasks', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ prompt })
    })
    .then(res => {
      if (!res.ok) throw new Error(`HTTP ${res.status}`);
      return res.json();
    })
    .then((data: unknown) => {
      // Hard validate: object with tasks (string[]) present and optional remainder (string)
      if (!data || typeof data !== 'object') {
        return; // discard
      }
      const obj = data as CerebrasResult;
      if (!('tasks' in obj) || !Array.isArray(obj.tasks) || !obj.tasks.every(t => typeof t === 'string')) {
        return; // discard
      }

      const tasks = (obj.tasks || []).map(t => t.trim()).filter(t => t.length > 0);
      const remainder = typeof obj.remainder === 'string' ? obj.remainder : '';

      if (tasks.length > 0) {
        const nowTs = Date.now();
        eventBus.emit('input:tasks', {
          tasks: tasks.map((text, index) => ({
            id: (globalThis.crypto && 'randomUUID' in globalThis.crypto) ? crypto.randomUUID() : Math.random().toString(36).slice(2),
            text,
            timestamp: nowTs + index,
            source: 'voice'
          }))
        });
      }

      // Update buffer: replace the part we sent with remainder, keep any new text that arrived after call started
      const suffix = bufferRef.current.slice(callStartBufferLengthRef.current);
      const newBuffer = [remainder || '', suffix || ''].filter(Boolean).join(' ').trim();
      setBuffer(newBuffer);
    })
    .catch((error) => {
      // Retry after 5 seconds; keep buffer untouched
      setStatus('error');
      setLastError('Cerebras API error - retrying...');
      window.setTimeout(() => {
        if (bufferRef.current) scheduleProcessing();
      }, 5000);
    })
    .finally(() => {
      processingRef.current = false;
      setStatus(isListening ? 'listening' : 'idle');
      // If more buffer exists, try to schedule next call
      if (bufferRef.current) scheduleProcessing();
    });
  }, [isListening, cleanOld, scheduleProcessing]);

  // Render nothing; this component orchestrates voice -> tasks
  return null;
}

export default VoiceTaskListener;
</file>

<file path="src/ui/components/background/AnimatedBackground.tsx">
'use client';

import { useEffect, useRef } from 'react';

interface Particle {
  x: number;
  y: number;
  vx: number;
  vy: number;
  size: number;
  opacity: number;
}

export function AnimatedBackground() {
  const canvasRef = useRef<HTMLCanvasElement>(null);
  const particlesRef = useRef<Particle[]>([]);
  const animationRef = useRef<number>(0);

  useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;

    const ctx = canvas.getContext('2d');
    if (!ctx) return;

    const resizeCanvas = () => {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    };

    const createParticles = () => {
      const particles: Particle[] = [];
      const particleCount = Math.floor((canvas.width * canvas.height) / 20000);

      for (let i = 0; i < particleCount; i++) {
        particles.push({
          x: Math.random() * canvas.width,
          y: Math.random() * canvas.height,
          vx: (Math.random() - 0.5) * 0.5,
          vy: (Math.random() - 0.5) * 0.5,
          size: Math.random() * 2 + 1,
          opacity: Math.random() * 0.5 + 0.1
        });
      }

      particlesRef.current = particles;
    };

    const animate = () => {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      const particles = particlesRef.current;

      particles.forEach((particle, i) => {
        // Update position
        particle.x += particle.vx;
        particle.y += particle.vy;

        // Bounce off edges
        if (particle.x < 0 || particle.x > canvas.width) particle.vx *= -1;
        if (particle.y < 0 || particle.y > canvas.height) particle.vy *= -1;

        // Keep particles in bounds
        particle.x = Math.max(0, Math.min(canvas.width, particle.x));
        particle.y = Math.max(0, Math.min(canvas.height, particle.y));

        // Draw particle
        ctx.beginPath();
        ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
        ctx.fillStyle = `rgba(255, 255, 255, ${particle.opacity})`;
        ctx.fill();

        // Draw connections
        particles.forEach((otherParticle, j) => {
          if (i === j) return;

          const dx = particle.x - otherParticle.x;
          const dy = particle.y - otherParticle.y;
          const distance = Math.sqrt(dx * dx + dy * dy);

          if (distance < 100) {
            ctx.beginPath();
            ctx.moveTo(particle.x, particle.y);
            ctx.lineTo(otherParticle.x, otherParticle.y);
            ctx.strokeStyle = `rgba(255, 255, 255, ${0.1 * (1 - distance / 100)})`;
            ctx.lineWidth = 1;
            ctx.stroke();
          }
        });
      });

      animationRef.current = requestAnimationFrame(animate);
    };

    resizeCanvas();
    createParticles();
    animate();

    const handleResize = () => {
      resizeCanvas();
      createParticles();
    };

    window.addEventListener('resize', handleResize);

    return () => {
      if (animationRef.current) {
        cancelAnimationFrame(animationRef.current);
      }
      window.removeEventListener('resize', handleResize);
    };
  }, []);

  return (
    <canvas
      ref={canvasRef}
      className="absolute inset-0 pointer-events-none"
      style={{ zIndex: 1 }}
    />
  );
}
</file>

<file path="src/ui/components/debugSidebar/DebugSidebar.tsx">
'use client';

import { useState, useEffect } from 'react';
import { eventBus } from '@/lib/eventBus';
import type { Task } from '@/ai/types';

type OpenSidebar = 'ui' | 'input' | 'ai' | null;

interface DebugSidebarProps {
  inputStatus: 'idle' | 'listening' | 'processing' | 'error';
  aiStatus: 'idle' | 'processing' | 'ready' | 'error';
  apiBudget: { used: number; nextMs: number | null };
  openInputWindow: () => void;
  openAIWindow: () => void;
  openUserNotesWindow: () => void;
  openSystemOutputWindow: () => void;
  openGraphWindow: () => void;
  openBarGraphWindow: () => void;
  openPieChartWindow: () => void;
  openPreloadedImageWindow: () => void;
}

export function DebugSidebar({ 
  inputStatus, 
  aiStatus, 
  apiBudget, 
  openInputWindow, 
  openAIWindow, 
  openUserNotesWindow, 
  openSystemOutputWindow, 
  openGraphWindow, 
  openBarGraphWindow, 
  openPieChartWindow, 
  openPreloadedImageWindow 
}: DebugSidebarProps) {
  const [openSidebar, setOpenSidebar] = useState<OpenSidebar>(null);
  const [taskQueue, setTaskQueue] = useState<Task[]>([]);
  const [currentTask, setCurrentTask] = useState<Task | null>(null);
  const [recentToolCalls, setRecentToolCalls] = useState<any[]>([]);

  useEffect(() => {
    const listeners = [
      eventBus.on('ai:task_queue_updated', (tasks: Task[]) => setTaskQueue(tasks)),
      eventBus.on('ai:task_started', ({ task }: { task: Task }) => {
        setCurrentTask(task);
        setTaskQueue(prev => prev.filter(t => t.id !== task.id));
      }),
      eventBus.on('ai:task_completed', () => {
        setCurrentTask(null);
      }),
      eventBus.on('ai:task_failed', () => {
        setCurrentTask(null);
      }),
      eventBus.on('ai:tool_call_started', (data: any) => {
        setRecentToolCalls(prev => [{ ...data, status: 'started', timestamp: Date.now() }, ...prev].slice(0, 5));
      }),
      eventBus.on('ai:tool_call_completed', (data: any) => {
        setRecentToolCalls(prev => 
          prev.map(call => call.task.id === data.task.id ? { ...call, status: 'completed', result: data.result } : call)
        );
      }),
    ];

    return () => {
      listeners.forEach(off => off());
    };
  }, []);

  const toggleSidebar = (sidebar: OpenSidebar) => {
    setOpenSidebar(openSidebar === sidebar ? null : sidebar);
  };

  return (
    <div className="fixed right-0 top-0 h-full bg-gray-800/80 backdrop-blur-sm text-white p-4 w-80 z-20 overflow-y-auto">
      <div className="flex flex-col space-y-2">
        <button onClick={() => toggleSidebar('ui')} className="bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded">
          UI
        </button>
        <button onClick={() => toggleSidebar('input')} className="bg-green-500 hover:bg-green-700 text-white font-bold py-2 px-4 rounded">
          Input
        </button>
        <button onClick={() => toggleSidebar('ai')} className="bg-purple-500 hover:bg-purple-700 text-white font-bold py-2 px-4 rounded">
          AI
        </button>
      </div>

      {openSidebar && <div className="mt-4 border-t border-gray-600 pt-4" />}

      {openSidebar === 'ui' && (
        <div>
          <h2 className="text-lg font-bold mb-2">UI Debug</h2>
          <div className="space-y-2">
            <button onClick={openInputWindow} className="w-full bg-gray-700 hover:bg-gray-600 text-white font-bold py-2 px-4 rounded">Open Input Window</button>
            <button onClick={openAIWindow} className="w-full bg-gray-700 hover:bg-gray-600 text-white font-bold py-2 px-4 rounded">Open AI Window</button>
            <button onClick={openUserNotesWindow} className="w-full bg-gray-700 hover:bg-gray-600 text-white font-bold py-2 px-4 rounded">Open Personal Notes</button>
            <button onClick={openSystemOutputWindow} className="w-full bg-gray-700 hover:bg-gray-600 text-white font-bold py-2 px-4 rounded">Open System Output</button>
            <button onClick={openGraphWindow} className="w-full bg-gray-700 hover:bg-gray-600 text-white font-bold py-2 px-4 rounded">Open Line Graph</button>
            <button onClick={openBarGraphWindow} className="w-full bg-gray-700 hover:bg-gray-600 text-white font-bold py-2 px-4 rounded">Open Bar Graph</button>
            <button onClick={openPieChartWindow} className="w-full bg-gray-700 hover:bg-gray-600 text-white font-bold py-2 px-4 rounded">Open Pie Chart</button>
            <button onClick={openPreloadedImageWindow} className="w-full bg-gray-700 hover:bg-gray-600 text-white font-bold py-2 px-4 rounded">Open Sample Image</button>
          </div>
        </div>
      )}

      {openSidebar === 'input' && (
        <div>
          <h2 className="text-lg font-bold">Input State</h2>
          <div className="mt-2 space-y-2 text-sm">
            <div className="flex justify-between"><span>Status:</span> <span className={`px-2 py-0.5 rounded ${inputStatus === 'listening' ? 'bg-red-500' : inputStatus === 'processing' ? 'bg-yellow-500' : inputStatus === 'error' ? 'bg-rose-600' : 'bg-gray-500'}`}>{inputStatus}</span></div>
            <div className="flex justify-between"><span>API Calls/min:</span> <span>{apiBudget.used}</span></div>
            {apiBudget.nextMs != null && <div className="flex justify-between"><span>Next Call In:</span> <span>{Math.max(0, Math.round(apiBudget.nextMs/1000))}s</span></div>}
          </div>
        </div>
      )}

      {openSidebar === 'ai' && (
        <div>
          <h2 className="text-lg font-bold">AI State</h2>
          <div className="mt-2 space-y-2 text-sm">
            <div className="flex justify-between"><span>Status:</span> <span className={`px-2 py-0.5 rounded ${aiStatus === 'processing' ? 'bg-yellow-500' : aiStatus === 'error' ? 'bg-rose-600' : 'bg-emerald-600'}`}>{aiStatus}</span></div>
          </div>

          <div className="mt-4">
            <h3 className="font-bold">Task Queue ({taskQueue.length})</h3>
            <ul className="mt-1 space-y-1 text-xs bg-gray-700/50 p-2 rounded">
              {taskQueue.map(task => (
                <li key={task.id} className="truncate">{task.tool}: {task.description}</li>
              ))}
              {taskQueue.length === 0 && <li className="text-gray-400">Empty</li>}
            </ul>
          </div>

          <div className="mt-4">
            <h3 className="font-bold">Current Task</h3>
            <div className="mt-1 text-xs bg-gray-700/50 p-2 rounded">
              {currentTask ? (
                <div>
                  <p><strong>ID:</strong> {currentTask.id}</p>
                  <p><strong>Tool:</strong> {currentTask.tool}</p>
                  <p><strong>Desc:</strong> {currentTask.description}</p>
                </div>
              ) : (
                <p className="text-gray-400">None</p>
              )}
            </div>
          </div>

          <div className="mt-4">
            <h3 className="font-bold">Recent Tool Calls</h3>
            <ul className="mt-1 space-y-2 text-xs">
              {recentToolCalls.map((call, i) => (
                <li key={i} className="bg-gray-700/50 p-2 rounded">
                  <p><strong>Tool:</strong> {call.tool} ({call.status})</p>
                  <p className="truncate"><strong>Params:</strong> {JSON.stringify(call.params)}</p>
                  {call.status === 'completed' && <p className="truncate"><strong>Result:</strong> {JSON.stringify(call.result)}</p>}
                </li>
              ))}
              {recentToolCalls.length === 0 && <li className="text-gray-400">None</li>}
            </ul>
          </div>
        </div>
      )}
    </div>
  );
}
</file>

<file path="src/ui/components/imageDropZone/ImageDropZone.tsx">
'use client';

import { useState, useRef } from 'react';

interface ImageDropZoneProps {
  onImageUpload: (imageUrl: string, imageName: string) => void;
}

export function ImageDropZone({ onImageUpload }: ImageDropZoneProps) {
  const [isDragOver, setIsDragOver] = useState(false);
  const [isUploading, setIsUploading] = useState(false);
  const fileInputRef = useRef<HTMLInputElement>(null);

  const handleDragOver = (e: React.DragEvent) => {
    e.preventDefault();
    setIsDragOver(true);
  };

  const handleDragLeave = (e: React.DragEvent) => {
    e.preventDefault();
    setIsDragOver(false);
  };

  const handleDrop = (e: React.DragEvent) => {
    e.preventDefault();
    setIsDragOver(false);
    
    const files = Array.from(e.dataTransfer.files);
    const imageFiles = files.filter(file => file.type.startsWith('image/'));
    
    if (imageFiles.length > 0) {
      handleImageFile(imageFiles[0]);
    }
  };

  const handleFileSelect = (e: React.ChangeEvent<HTMLInputElement>) => {
    const files = Array.from(e.target.files || []);
    if (files.length > 0) {
      handleImageFile(files[0]);
    }
  };

  const handleImageFile = (file: File) => {
    setIsUploading(true);
    
    const reader = new FileReader();
    reader.onload = (event) => {
      const imageUrl = event.target?.result as string;
      onImageUpload(imageUrl, file.name);
      setIsUploading(false);
    };
    reader.onerror = () => {
      setIsUploading(false);
    };
    reader.readAsDataURL(file);
  };

  const handleClick = () => {
    fileInputRef.current?.click();
  };

  return (
    <div
      className={`
        relative w-16 h-16 border-2 border-dashed rounded-full transition-all duration-300 cursor-pointer
        flex items-center justify-center
        ${isDragOver 
          ? 'border-blue-400 bg-blue-500/20 scale-105' 
          : 'border-white/30 hover:border-white/50 hover:bg-white/5'
        }
        ${isUploading ? 'opacity-50 pointer-events-none' : ''}
      `}
      onDragOver={handleDragOver}
      onDragLeave={handleDragLeave}
      onDrop={handleDrop}
      onClick={handleClick}
    >
      <input
        ref={fileInputRef}
        type="file"
        accept="image/*"
        onChange={handleFileSelect}
        className="hidden"
      />
      
      <div className="absolute inset-0 flex flex-col items-center justify-center p-2">
        {isUploading ? (
          <div className="w-8 h-8 border-4 border-white/30 border-t-white rounded-full animate-spin"></div>
        ) : (
          <svg 
            className="w-8 h-8 text-white/70" 
            fill="none" 
            stroke="currentColor" 
            viewBox="0 0 24 24"
          >
            <path 
              strokeLinecap="round" 
              strokeLinejoin="round" 
              strokeWidth={2} 
              d="M12 4v16m8-8H4" 
            />
          </svg>
        )}
      </div>
    </div>
  );
}
</file>

<file path="src/ui/components/textOutput/index.ts">
export { TextOutput } from './TextOutput';
export type { NotesState, TextOutputProps } from './textOutput.types';
</file>

<file path="src/ui/components/textOutput/TextOutput.tsx">
'use client';

import { useState, useEffect, useRef } from 'react';
import { eventBus } from '@/lib/eventBus';
import { NotesState, TextOutputProps } from './textOutput.types';

export function TextOutput({
  placeholder = 'Start typing your notes here...'
}: TextOutputProps) {
  const [notes, setNotes] = useState<NotesState>({
    content: '',
    lastModified: new Date()
  });
  const textareaRef = useRef<HTMLTextAreaElement>(null);

  useEffect(() => {
    const unsubscribers = [
      eventBus.on('input:input_processed', (data) => {
        addToNotes(`ðŸ“ Input processed: ${JSON.stringify(data)}\n`);
      }),
      eventBus.on('ai:ai_response_generated', (data) => {
        addToNotes(`ðŸ¤– AI response: ${JSON.stringify(data)}\n`);
      }),
      eventBus.on('input:initialized', () => {
        addToNotes('âœ… Input manager initialized\n');
      }),
      eventBus.on('ai:initialized', () => {
        addToNotes('âœ… AI manager initialized\n');
      }),
      eventBus.on('ui:log', (data: { message: string }) => {
        addToNotes(`ðŸ“‹ ${data.message}\n`);
      }),
      eventBus.on('notes:add', (data: { text: string }) => {
        addToNotes(data.text);
      })
    ];

    return () => {
      unsubscribers.forEach(unsub => unsub());
    };
  }, []);

  const addToNotes = (text: string) => {
    setNotes(prev => ({
      content: prev.content + text,
      lastModified: new Date()
    }));
  };

  const handleContentChange = (e: React.ChangeEvent<HTMLTextAreaElement>) => {
    setNotes({
      content: e.target.value,
      lastModified: new Date()
    });
  };

  const clearNotes = () => {
    setNotes({
      content: '',
      lastModified: new Date()
    });
  };

  return (
    <div className="h-full flex flex-col">
      {/* Header */}
      <div className="flex items-center justify-between p-4 border-b bg-white">
        <div className="flex items-center space-x-3">
          <div className="w-10 h-10 bg-gradient-to-br from-yellow-400 to-orange-500 rounded-lg flex items-center justify-center shadow-md">
            <span className="text-white text-lg">ðŸ“</span>
          </div>
          <div>
            <h3 className="text-lg font-semibold text-gray-800">Notes</h3>
            <p className="text-xs text-gray-500">
              Last modified: {notes.lastModified.toLocaleTimeString()}
            </p>
          </div>
        </div>

        <button
          onClick={clearNotes}
          className="px-3 py-1 text-sm bg-gray-100 hover:bg-gray-200 text-gray-700 rounded transition-colors"
        >
          Clear All
        </button>
      </div>

      {/* Notes Area */}
      <div className="flex-1 p-4">
        <textarea
          ref={textareaRef}
          value={notes.content}
          onChange={handleContentChange}
          placeholder={placeholder}
          className="w-full h-full resize-none border-none outline-none bg-transparent text-gray-800 leading-relaxed text-sm"
          style={{
            fontFamily: 'system-ui, -apple-system, sans-serif',
            lineHeight: '1.6'
          }}
        />
      </div>

      {/* Footer */}
      <div className="border-t bg-gray-50 px-4 py-2 text-xs text-gray-500 flex justify-between">
        <span>
          {notes.content.split(/\s+/).filter(word => word.length > 0).length} words
        </span>
        <span>
          {notes.content.length} characters
        </span>
      </div>
    </div>
  );
}
</file>

<file path="src/ui/components/textOutput/textOutput.types.ts">
export interface NotesState {
  content: string;
  lastModified: Date;
}

export interface TextOutputProps {
  placeholder?: string;
}
</file>

<file path="src/ui/components/window/window.types.ts">
export interface WindowProps {
  id: string;
  title: string;
  children: React.ReactNode;
  initialX?: number;
  initialY?: number;
  width?: number;
  height?: number;
  minWidth?: number;
  minHeight?: number;
  maxWidth?: number;
  maxHeight?: number;
  onClose?: () => void;
  isActive?: boolean;
  onFocus?: () => void;
  onResize?: (width: number, height: number) => void;
}

export interface WindowState {
  x: number;
  y: number;
  width: number;
  height: number;
  isMinimized: boolean;
  zIndex: number;
}
</file>

<file path=".gitignore">
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.*
.yarn/*
!.yarn/patches
!.yarn/plugins
!.yarn/releases
!.yarn/versions

# testing
/coverage

# next.js
/.next/
/out/

# production
/build

# misc
.DS_Store
*.pem

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*
.pnpm-debug.log*

# env files (can opt-in for committing if needed)
.env*

# vercel
.vercel

# typescript
*.tsbuildinfo
next-env.d.ts

# CLAUDE.md
CLAUDE.md
</file>

<file path="package.json">
{
  "name": "jarvis",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev --turbopack",
    "build": "next build --turbopack",
    "start": "next start",
    "lint": "eslint"
  },
  "dependencies": {
    "@google/generative-ai": "^0.21.0",
    "@mozilla/readability": "^0.6.0",
    "jsdom": "^27.0.0",
    "next": "15.5.3",
    "react": "19.1.0",
    "react-dom": "19.1.0"
  },
  "devDependencies": {
    "@eslint/eslintrc": "^3",
    "@tailwindcss/postcss": "^4",
    "@types/node": "^20",
    "@types/react": "^19",
    "@types/react-dom": "^19",
    "eslint": "^9",
    "eslint-config-next": "15.5.3",
    "tailwindcss": "^4",
    "typescript": "^5"
  }
}
</file>

<file path="src/ai/index.ts">
export { AIManager, aiManager } from './AIManager';
export { TaskParser } from './taskParser';
export { ToolExecutor, toolExecutor } from './toolExecutor';
export { CerebrasClient } from './cerebrasClient';
export { AITester, aiTester } from './tester';
export { AVAILABLE_TOOLS, getToolByName, getAllToolNames } from './tools';
export { windowRegistry } from './windowRegistry';
export type { 
  Tool, 
  CerebrasTool,
  Task, 
  WindowContext, 
  OpenWindowParams, 
  CloseWindowParams,
  CerebrasRequest,
  CerebrasResponse,
  AIProcessingResult
} from './types';
</file>

<file path="src/input/index.ts">
export { InputManager, inputManager } from './InputManager';
export { SpeechTranscriptionService, speechService } from './speechService';
export { useSpeechTranscription } from './useSpeechTranscription';
export { SpeechTranscriptionProvider, useSpeechTranscriptionContext, SpeechIndicator } from './SpeechTranscriptionProvider';
export type { SpeechRecognition, SpeechRecognitionEvent } from './speechService';
export type { TranscriptData, WordData, UseSpeechTranscriptionOptions, UseSpeechTranscriptionReturn } from './useSpeechTranscription';
export { VoiceTaskListener } from './VoiceTaskListener';
</file>

<file path="README.md">
# Jarvis
</file>

<file path="src/ai/tools.ts">
import { Tool } from './types';

export const AVAILABLE_TOOLS: Tool[] = [
  {
    name: 'open_window',
    description: 'Opens a new popup window with specified type and context. Use this for creating, opening, showing, or displaying a window. Education types supported: lesson, quiz, hint, explainer.',
    parameters: {
      type: 'object',
      properties: {
        windowType: {
          type: 'string',
          description: 'The type of window to open (e.g., notification, dialog, settings, sticky-note, general, lesson, quiz, hint, explainer)'
        },
        context: {
          type: 'object',
          description: 'Context information for the window',
          properties: {
            title: {
              type: 'string',
              description: 'Window title to display'
            },
            content: {
              type: 'string',
              description: 'Primary text/content of the window'
            },
            type: {
              type: 'string',
              description: 'Repeat of window type for UI context (notification, dialog, settings, sticky-note, general, lesson, quiz, hint, explainer)'
            },
            position: {
              type: 'object',
              description: 'Optional x/y position of the window',
              properties: {
                x: { type: 'number', description: 'X coordinate in pixels' },
                y: { type: 'number', description: 'Y coordinate in pixels' }
              }
            },
            size: {
              type: 'object',
              description: 'Optional width/height of the window',
              properties: {
                width: { type: 'number', description: 'Window width in pixels' },
                height: { type: 'number', description: 'Window height in pixels' }
              }
            },
            metadata: {
              type: 'object',
              description: 'Optional metadata for education windows (e.g., lessonId, step, quizQuestions)',
              properties: {}
            }
          }
        }
      },
      required: ['windowType', 'context']
    }
  },
  {
    name: 'edit_window',
    description: 'Edits an existing window: rename title, set/append/prepend/clear content.',
    parameters: {
      type: 'object',
      properties: {
        windowId: { type: 'string', description: 'Target window id (optional if selector used)' },
        selector: { type: 'string', description: 'newest | active | oldest' },
        title: { type: 'string', description: 'New title (omit to keep current)' },
        content: { type: 'string', description: 'Text to set/append/prepend' },
        mode: { type: 'string', description: 'set | append | prepend | clear', enum: ['set','append','prepend','clear'] }
      },
      required: []
    }
  },
  {
    name: 'close_window',
    description: 'Closes an existing window by its ID. Use this when the user wants to close, dismiss, or hide a specific window.',
    parameters: {
      type: 'object',
      properties: {
        windowId: {
          type: 'string',
          description: 'The unique identifier of the window to close'
        },
        selector: {
          type: 'string',
          description: 'Semantic selector when ID is unknown (newest/latest/oldest/active/all)'
        }
      },
      required: []
    }
  },
  {
    name: 'web_search',
    description: 'Performs web search using Gemini with grounding and displays results in a window. Use this when user wants to search for information online.',
    parameters: {
      type: 'object',
      properties: {
        query: {
          type: 'string',
          description: 'The search query to look up'
        },
        resultCount: {
          type: 'number',
          description: 'Number of results to return (1-10, default 5)'
        },
        displayMode: {
          type: 'string',
          description: 'How to display results: summary (single result with summary), links (multiple results with titles/links), full (single result with full content)',
          enum: ['summary', 'links', 'full', 'auto']
        }
      },
      required: ['query']
    }
  },
  {
    name: 'create_group',
    description: 'Creates a new window group with a name and color for organizing windows',
    parameters: {
      type: 'object',
      properties: {
        name: {
          type: 'string',
          description: 'Name of the group (e.g., Research, Work, Personal)'
        },
        color: {
          type: 'string',
          description: 'Color for the group banner (e.g., purple, blue, red, green, orange)'
        }
      },
      required: ['name', 'color']
    }
  },
  {
    name: 'assign_group',
    description: 'Assigns a window to a group or moves the current/newest window to a group',
    parameters: {
      type: 'object',
      properties: {
        windowId: {
          type: 'string',
          description: 'ID of the window to assign (optional, defaults to newest)'
        },
        groupName: {
          type: 'string',
          description: 'Name of the group to assign the window to'
        },
        selector: {
          type: 'string',
          description: 'Window selector if ID not provided (newest, active, all)'
        }
      },
      required: ['groupName']
    }
  },
  {
    name: 'open_webview',
    description: 'Opens a sandboxed webview (iframe) to display a URL inside a window.',
    parameters: {
      type: 'object',
      properties: {
        url: { type: 'string', description: 'URL to load in the webview' },
        title: { type: 'string', description: 'Optional window title' },
        width: { type: 'number', description: 'Optional window width in px' },
        height: { type: 'number', description: 'Optional window height in px' }
      },
      required: ['url']
    }
  },
  {
    name: 'open_search_result',
    description: 'Opens one of the last shown search results in a webview (supports "first/second/N").',
    parameters: {
      type: 'object',
      properties: {
        index: { type: 'number', description: '1-based index of the result to open (default 1)' },
        url: { type: 'string', description: 'Direct URL to open (overrides index lookup)' },
        title: { type: 'string', description: 'Optional window title' }
      },
      required: []
    }
  },
  {
    name: 'summarize_article',
    description: 'Reads the given URL server-side and generates a concise bullet summary and notes.',
    parameters: {
      type: 'object',
      properties: {
        url: { type: 'string', description: 'Article URL to read (will use reader mode)' },
        windowId: { type: 'string', description: 'Optional target window id for notes; default opens new' },
        maxBullets: { type: 'number', description: 'Max bullets in summary (default 8)' }
      },
      required: ['url']
    }
  }
];

export function getToolByName(name: string): Tool | undefined {
  return AVAILABLE_TOOLS.find(tool => tool.name === name);
}

export function getAllToolNames(): string[] {
  return AVAILABLE_TOOLS.map(tool => tool.name);
}
</file>

<file path="src/ai/types.ts">
type JSONSchema = {
  type: string;
  description?: string;
  properties?: Record<string, JSONSchema>;
  items?: JSONSchema;
  enum?: Array<string | number | boolean>;
  required?: string[];
};

export interface Tool {
  name: string;
  description: string;
  parameters: JSONSchema & { type: 'object'; properties: Record<string, JSONSchema>; required: string[] };
}

export interface CerebrasTool {
  type: 'function';
  function: {
    name: string;
    description: string;
    parameters: JSONSchema & { type: 'object'; properties: Record<string, JSONSchema>; required: string[] };
  };
}

export interface Task {
  id: string;
  tool: string;
  parameters: Record<string, any>;
  description: string;
}

export interface WindowContext {
  title?: string;
  content?: string;
  type?: 'notification' | 'dialog' | 'settings' | 'sticky-note' | 'general' | 'lesson' | 'quiz' | 'hint' | 'explainer';
  position?: { x: number; y: number };
  size?: { width: number; height: number };
  metadata?: Record<string, any>;
}

export interface OpenWindowParams {
  windowType: string;
  context: WindowContext;
}

export interface OpenWebviewParams {
  url: string;
  title?: string;
  width?: number;
  height?: number;
}

export interface CloseWindowParams {
  windowId?: string; // direct id when known
  selector?: 'newest' | 'latest' | 'oldest' | 'active' | 'all'; // semantic selector
}

export interface EditWindowParams {
  windowId?: string;
  selector?: 'newest' | 'active' | 'oldest';
  title?: string;
  content?: string;
  mode?: 'set' | 'append' | 'prepend' | 'clear';
}

export interface CerebrasRequest {
  model: string;
  messages: Array<{
    role: 'system' | 'user' | 'assistant';
    content: string;
  }>;
  temperature?: number;
  max_tokens?: number;
  tools?: CerebrasTool[];
  tool_choice?: string;
  response_format?: { type: 'text' | 'json_object' | 'json_schema'; json_schema?: unknown };
}

export interface CerebrasResponse {
  id: string;
  object: string;
  created: number;
  model: string;
  choices: Array<{
    index: number;
    message: {
      role: string;
      content: string;
      tool_calls?: Array<{
        id: string;
        type: 'function';
        function: {
          name: string;
          arguments: string;
        };
      }>;
    };
    finish_reason: string;
  }>;
  usage: {
    prompt_tokens: number;
    completion_tokens: number;
    total_tokens: number;
  };
}



export interface CreateGroupParams {
  name: string;
  color: string;
}

export interface AssignGroupParams {
  windowId?: string;
  groupName: string;
  selector?: 'newest' | 'active' | 'all';
}

export interface WebSearchParams {
  query: string;
  resultCount?: number;
  displayMode?: 'summary' | 'links' | 'full' | 'auto';
}

export interface SummarizeArticleParams {
  url: string;
  windowId?: string;
  maxBullets?: number;
}

export interface SearchResult {
  title: string;
  url: string;
  snippet: string;
  content?: string;
}

export interface AIProcessingResult {
  success: boolean;
  tasks: Task[];
  rawResponse?: CerebrasResponse;
  error?: string;
  timestamp: number;
}
</file>

<file path="src/app/api/cerebras-tasks/route.ts">
import { NextRequest } from 'next/server';

export async function POST(request: NextRequest) {
  try {
    console.log('[API] /api/cerebras-tasks POST hit');
    const body = await request.json().catch(() => ({}));
    let cerebrasRequest = body?.cerebrasRequest;

    if (!process.env.CEREBRAS_API_KEY) {
      return new Response(JSON.stringify({ error: 'Missing CEREBRAS_API_KEY' }), { status: 500 });
    }

    // Backward compatibility: accept { prompt } and wrap it into a minimal request
    if (!cerebrasRequest && typeof body?.prompt === 'string' && body.prompt.trim().length > 0) {
      cerebrasRequest = {
        model: 'llama3.1-8b',
        messages: [{ role: 'user', content: body.prompt }],
        temperature: 0.2,
        max_tokens: 512
      };
      // We'll try to unwrap this shaped response below if needed
      const proxied = await fetch('https://api.cerebras.ai/v1/chat/completions', {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${process.env.CEREBRAS_API_KEY}`,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(cerebrasRequest)
      });

      if (!proxied.ok) {
        const text = await proxied.text();
        return new Response(JSON.stringify({ error: `Upstream error ${proxied.status}`, detail: text }), { status: 502 });
      }

      const data = await proxied.json();
      const content: unknown = data?.choices?.[0]?.message?.content;
      if (typeof content === 'string') {
        try {
          const parsed = JSON.parse(content);
          return Response.json(parsed);
        } catch {
          // Not JSON; return a safe default
          return Response.json({ tasks: [], remainder: content });
        }
      }
      return Response.json({ tasks: [], remainder: '' });
    }

    if (!cerebrasRequest) {
      return new Response(JSON.stringify({ error: 'Missing cerebrasRequest in body' }), { status: 400 });
    }

    const response = await fetch('https://api.cerebras.ai/v1/chat/completions', {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${process.env.CEREBRAS_API_KEY}`,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify(cerebrasRequest)
    });

    if (!response.ok) {
      const text = await response.text();
      return new Response(JSON.stringify({ error: `Upstream error ${response.status}`, detail: text }), { status: 502 });
    }

    const data = await response.json();
    console.log('[API] /api/cerebras-tasks success');
    return Response.json(data);
  } catch (error) {
    console.error('[API] /api/cerebras-tasks error', error);
    return new Response(JSON.stringify({ error: (error instanceof Error ? error.message : String(error)) }), { status: 500 });
  }
}
</file>

<file path="src/ui/components/windowManager/windowManager.types.ts">
export interface WindowGroup {
  name: string;
  color: string;
}

export interface WindowData {
  id: string;
  title: string;
  component: React.ComponentType;
  content?: string;
  hideTitleBar?: boolean;
  group?: WindowGroup;
  isOpen: boolean;
  isMinimized: boolean;
  x: number;
  y: number;
  width: number;
  height: number;
  zIndex: number;
}

export interface WindowManagerState {
  windows: WindowData[];
  activeWindowId: string | null;
  nextZIndex: number;
}
</file>

<file path="src/ai/aiWorker.ts">
/* eslint-disable @typescript-eslint/no-explicit-any */
import { TaskParser } from './taskParser';
import { ToolExecutor } from './toolExecutor';

const taskParser = new TaskParser();
const toolExecutor = new ToolExecutor();

// Startup diagnostics
try {
  const isWorkerScope = typeof self !== 'undefined' && (self as unknown as { importScripts?: unknown }).importScripts !== undefined;
  // location is undefined in dedicated workers in some environments; guard accesses
  const href = (typeof location !== 'undefined' && location?.href) ? location.href : 'n/a';
  const origin = (typeof location !== 'undefined' && (location as any)?.origin) ? (location as any).origin : 'n/a';
  console.log('[AI Worker] Startup', { isWorkerScope, href, origin });
} catch {
  // ignore
}

self.addEventListener('message', (event) => {
  const { type, data } = event.data;
  
  switch (type) {
    case 'PROCESS_AI_REQUEST':
      processAIRequest(data);
      break;
    
    case 'PROCESS_TEXT_COMMAND':
      processTextCommand(data);
      break;
    
    case 'GENERATE_RESPONSE':
      generateResponse(data);
      break;
    
    case 'ANALYZE_DATA':
      analyzeData(data);
      break;
    
    default:
      console.warn(`Unknown AI worker message type: ${type}`);
  }
});

async function processTextCommand(data: any) {
  try {
    // Accept both object payloads ({ text, uiContext }) and raw string payloads
    const normalized = ((): { text: string; uiContext: any } => {
      if (typeof data === 'string') {
        return { text: data, uiContext: {} };
      }
      if (data && typeof data === 'object') {
        return { text: typeof data.text === 'string' ? data.text : '', uiContext: data.uiContext || {} };
      }
      return { text: '', uiContext: {} };
    })();

    const text = normalized.text;
    const uiContext = normalized.uiContext;
    
    if (!text) {
      throw new Error('No text input provided');
    }
    
    console.log(`[AI Worker] Processing text command: "${text}"`, {
      uiContextSummary: {
        windowsCount: Array.isArray(uiContext?.windows) ? uiContext.windows.length : 0
      }
    });
    
    // Parse text to tasks using Cerebras
    const parseResult = await taskParser.parseTextToTasks(text, uiContext);
    
    if (!parseResult.success) {
      throw new Error(parseResult.error || 'Failed to parse text to tasks');
    }
    
    console.log(`[AI Worker] Parsed ${parseResult.tasks.length} tasks:`, parseResult.tasks);
    
    // Execute the tasks
    const executionResults = await toolExecutor.executeTasks(parseResult.tasks);
    
    const response = {
      id: generateId(),
      success: true,
      originalText: text,
      tasks: parseResult.tasks,
      executionResults: executionResults,
      processingTime: parseResult.timestamp,
      timestamp: Date.now()
    };
    
    self.postMessage({
      type: 'TEXT_COMMAND_PROCESSED',
      data: response
    });
    
  } catch (error) {
    console.error('[AI Worker] Error processing text command:', error);
    
    self.postMessage({
      type: 'AI_ERROR',
      data: { 
        error: error instanceof Error ? error.message : String(error), 
        textInput: (typeof data?.text === 'string') ? data.text : undefined,
        type: 'text_command_error'
      }
    });
  }
}

async function processAIRequest(request: any) {
  try {
    // If pre-parsed tasks are provided, execute them directly
    if (Array.isArray(request?.tasks)) {
      const executionResults = await toolExecutor.executeTasks(request.tasks);
      self.postMessage({
        type: 'AI_TASKS_EXECUTED',
        data: {
          id: request.id || generateId(),
          success: true,
          tasks: request.tasks,
          executionResults,
          timestamp: Date.now()
        }
      });
      return;
    }

    // Legacy support for existing AI request format
    // Try to extract text from various possible fields
    const text = request.text || request.command || request.input || request.prompt?.text;
    
    if (text) {
      // Delegate to the new text command processor
      await processTextCommand(text);
      return;
    }
    
    // Fallback to old behavior for non-text requests
    await new Promise(resolve => setTimeout(resolve, 1000));
    
    const response = {
      id: request.id || generateId(),
      processed: true,
      timestamp: Date.now(),
      request
    };
    
    self.postMessage({
      type: 'AI_REQUEST_PROCESSED',
      data: response
    });
  } catch (error) {
    self.postMessage({
      type: 'AI_ERROR',
      data: { error: error instanceof Error ? error.message : String(error), request }
    });
  }
}

async function generateResponse(prompt: any) {
  try {
    // Check if this is a text command that should be processed differently
    const text = prompt.text || prompt.command || prompt.prompt;
    
    if (text && (typeof text === 'string')) {
      // Delegate to text command processor
      await processTextCommand(text);
      return;
    }
    
    // Fallback to simple response generation
    await new Promise(resolve => setTimeout(resolve, 1500));
    
    const response = {
      id: generateId(),
      response: `AI response to: ${JSON.stringify(prompt)}`,
      timestamp: Date.now(),
      prompt
    };
    
    self.postMessage({
      type: 'AI_RESPONSE_GENERATED',
      data: response
    });
  } catch (error) {
    self.postMessage({
      type: 'AI_ERROR',
      data: { error: error instanceof Error ? error.message : String(error), prompt }
    });
  }
}

async function analyzeData(data: any) {
  try {
    await new Promise(resolve => setTimeout(resolve, 800));
    
    const analysis = {
      id: generateId(),
      analysis: `Analysis of data: ${JSON.stringify(data)}`,
      confidence: Math.random(),
      timestamp: Date.now(),
      data
    };
    
    self.postMessage({
      type: 'AI_ANALYSIS_COMPLETE',
      data: analysis
    });
  } catch (error) {
    self.postMessage({
      type: 'AI_ERROR',
      data: { error: error instanceof Error ? error.message : String(error), data }
    });
  }
}

function generateId(): string {
  return Math.random().toString(36).substr(2, 9);
}

export {};
</file>

<file path="src/ai/taskParser.ts">
/* eslint-disable @typescript-eslint/no-explicit-any */
import { CerebrasClient } from './cerebrasClient';
import { AVAILABLE_TOOLS } from './tools';
import { Task, AIProcessingResult } from './types';

export class TaskParser {
  private cerebrasClient: CerebrasClient;

  constructor(apiKey?: string) {
    this.cerebrasClient = new CerebrasClient(apiKey);
  }

  async parseTextToTasks(text: string, uiContext: any = {}): Promise<AIProcessingResult> {
    console.log(`[TaskParser] Processing: ${text}`);
    try {
      const startTime = Date.now();
      console.log('[TaskParser] parseTextToTasks called', {
        textPreview: typeof text === 'string' ? text.slice(0, 80) : typeof text,
        uiWindows: Array.isArray(uiContext?.windows) ? uiContext.windows.length : 0
      });
      
      // Early handling: if the command is clearly a close/dismiss intent,
      // short-circuit Cerebras and return a direct close task to avoid
      // the model turning it into a note.
      const earlyClose = this.detectCloseCommand(text);
      if (earlyClose.length > 0) {
        return {
          success: true,
          tasks: earlyClose,
          timestamp: Date.now() - startTime
        };
      }

      // Use Cerebras to process the natural language input
      const response = await this.cerebrasClient.processTextToTasks(text, AVAILABLE_TOOLS, uiContext);
      console.log('[TaskParser] Cerebras response received', {
        hasChoices: Boolean((response as any)?.choices?.length),
        toolCalls: ((response as any)?.choices?.[0]?.message?.tool_calls || []).length
      });
      
      let tasks: Task[] = [];
      
      // Extract tool calls from the response
      if (response.choices && response.choices.length > 0) {
        const choice = response.choices[0];
        
        if (choice.message.tool_calls) {
          for (const toolCall of choice.message.tool_calls) {
            if (toolCall.type === 'function') {
              try {
                const parameters = JSON.parse(toolCall.function.arguments);
                
                let task: Task = {
                  id: this.generateTaskId(),
                  tool: toolCall.function.name,
                  parameters: parameters,
                  description: this.generateTaskDescription(toolCall.function.name, parameters)
                };
                // Normalize education intents for consistency (e.g., explain -> explainer)
                task = this.normalizeEducationIntent(text, task);
                tasks.push(task);
              } catch (parseError) {
                console.error('Failed to parse tool call arguments:', parseError);
              }
            }
          }
        }
      }
      // Final normalization pass
      tasks = tasks.map(t => this.normalizeEducationIntent(text, t));

      // Guardrail: only allow web_search if the user explicitly asked to search
      const hasSearchKeyword = /\b(search|look up|find information|google|bing)\b/i.test(text);
      tasks = tasks.filter(t => t.tool !== 'web_search' || hasSearchKeyword);

      // Force-correct: if the user asked to open a result but the model returned a generic window,
      // replace/augment with open_search_result so UI opens the article.
      const openResultIndex = this.detectOpenResultIndex(text);
      if (openResultIndex != null) {
        // Drop any generic First Link windows the model may have created
        tasks = tasks.filter(t => !(t.tool === 'open_window' && /first\s+link/i.test(String((t as any)?.parameters?.context?.title || ''))));
        // Only add if not already present
        if (!tasks.some(t => t.tool === 'open_search_result')) {
          tasks.unshift({
            id: this.generateTaskId(),
            tool: 'open_search_result',
            parameters: { index: openResultIndex },
            description: `Open search result #${openResultIndex}`
          });
        }
      }

      // If no tool calls were generated, try to handle simple cases with fallback parsing
      if (tasks.length === 0) {
        const fallbackTasks = this.fallbackParsing(text);
        tasks.push(...fallbackTasks);
      }
      
      return {
        success: true,
        tasks: tasks,
        rawResponse: response,
        timestamp: Date.now() - startTime
      };
      
    } catch (error) {
      console.error('Error parsing text to tasks:', error);
      try {
        console.log('[TaskParser] Falling back to local parsing for input');
      } catch {}
      
      // Fallback to simple parsing if Cerebras fails
      const fallbackTasks = this.fallbackParsing(text);
      
      return {
        success: fallbackTasks.length > 0,
        tasks: fallbackTasks,
        error: error instanceof Error ? error.message : String(error),
        timestamp: Date.now()
      };
    }
  }

  private detectOpenResultIndex(text: string): number | null {
    const lower = text.toLowerCase();
    // quick patterns: first/second/third/fourth/fifth
    const wordToIndex: Record<string, number> = { first: 1, second: 2, third: 3, fourth: 4, fifth: 5 };
    const word = lower.match(/\b(first|second|third|fourth|fifth)\b/);
    if (word) return wordToIndex[word[1]];
    const num = lower.match(/result\s*(\d+)/);
    if (num) return Math.max(1, parseInt(num[1], 10));
    if (/\b(open|read|show|load|click)\b\s+(it|this|that)/i.test(lower)) return 1; // default
    return null;
  }

  private detectCloseCommand(text: string): Task[] {
    try {
      const lower = text.toLowerCase();
      const hasCloseVerb = /(close|dismiss|hide|remove|exit|quit|shut|shutdown|shut\s*down)/i.test(lower);
      const mentionsWindow = /(window|popup|dialog|note|all\s+windows|windows)/i.test(lower);
      const pronounTarget = /(\bthis\b|\bcurrent\b|\bfocused\b|\bit\b|\bthat\b)/i.test(lower);
      if (!hasCloseVerb) return [];
      
      // Must have close verb AND (window mention OR pronoun target)
      if (!mentionsWindow && !pronounTarget) return [];

      // Selector-based phrases
      let selector: 'newest' | 'latest' | 'oldest' | 'active' | 'all' | undefined;
      if (/\b(newest|latest)\b/i.test(text)) selector = 'newest';
      else if (/\boldest\b/i.test(text)) selector = 'oldest';
      else if (pronounTarget || /\bcurrent\b|\bfocused\b/i.test(text)) selector = 'active';
      else if (/\b(all\s+windows|close\s+all|close\s+everything|dismiss\s+all)\b/i.test(lower)) selector = 'all';

      // Direct ID patterns (e.g., "close window abc123")
      // Capture an identifier following the window keyword or at the end
      let windowId: string | undefined;
      const idPatterns: RegExp[] = [
        /(?:close|dismiss|hide|shut(?:\s*down)?)\s+(?:the\s+)?(?:window|popup|dialog|note)\s+([A-Za-z0-9_-]+)/i,
        /(?:window|popup|dialog|note)\s+([A-Za-z0-9_-]+)\s*(?:please)?\s*(?:close|dismiss|hide|shut(?:\s*down)?)?/i,
      ];
      for (const p of idPatterns) {
        const m = text.match(p);
        if (m && m[1]) {
          windowId = m[1].trim();
          break;
        }
      }

      // If we only have a close intent with no id/selector, default to newest
      if (!windowId && !selector && hasCloseVerb) selector = 'newest';

      if (!windowId && !selector) return [];

      const params: any = {};
      if (windowId) params.windowId = windowId;
      if (selector) params.selector = selector;

      return [
        {
          id: this.generateTaskId(),
          tool: 'close_window',
          parameters: params,
          description: this.generateTaskDescription('close_window', params)
        }
      ];
    } catch {
      return [];
    }
  }

  private fallbackParsing(text: string): Task[] {
    console.log(`[TaskParser] Fallback parsing: ${text}`);
    const tasks: Task[] = [];
    const lowerText = text.toLowerCase();
    
    // Search commands (handle first to avoid creating a generic open window)
    if (lowerText.includes('search') || lowerText.includes('look up') || lowerText.includes('find information') || /article/i.test(lowerText)) {
      let searchQuery = '';
      let resultCount = 5;
      let displayMode = 'auto';

      const searchPatterns = [
        /search\s+for\s+(.+?)$/i,
        /look\s+up\s+(.+?)$/i,
        /find\s+information\s+(?:about|on)\s+(.+?)$/i,
        /(?:search|look\s+up|find)\s+["']([^"']+)["']/i,
        /(?:search|google|bing)\s*[:.]?\s*(.+?)$/i
      ];

      for (const pattern of searchPatterns) {
        const match = text.match(pattern);
        if (match && match[1]) {
          searchQuery = match[1].trim();
          break;
        }
      }

      const countMatch = text.match(/(\d+)\s+(?:results?|top|first)/i);
      if (countMatch) {
        const n = parseInt(countMatch[1], 10);
        if (!isNaN(n) && n > 0 && n <= 10) resultCount = n;
      }

      if (searchQuery) {
        tasks.push({
          id: this.generateTaskId(),
          tool: 'web_search',
          parameters: {
            query: searchQuery,
            resultCount: resultCount,
            displayMode: displayMode
          },
          description: `Search for: ${searchQuery}`
        });

        // Fallback: if no tasks and it mentions search/article, force a search task
        if (tasks.length === 0 && (/\b(search|look up|find information|article)\b/i.test(text))) {
          console.log(`[TaskParser] Forcing search for: ${text}`);
          tasks.push({
            id: this.generateTaskId(),
            tool: 'web_search',
            parameters: { query: text, resultCount: 5, displayMode: 'links' },
            description: `Search for: ${text}`
          });
        }

        return tasks; // Do not create a generic open window
      }
    }

    // Open specific result commands
    if (/\b(open|read|show|load|click)\b\s+(it|this|that|first|second|third|fourth|fifth|result\s*\d+|the\s+first\s+(link|result))/i.test(lowerText)) {
      let index = 1;
      const indexMap: Record<string, number> = { first: 1, second: 2, third: 3, fourth: 4, fifth: 5 };
      const idxWord = (lowerText.match(/(first|second|third|fourth|fifth)/)?.[1]);
      if (idxWord) index = indexMap[idxWord] || 1;
      const idxNum = (lowerText.match(/result\s*(\d+)/)?.[1]);
      if (idxNum) index = Math.max(1, parseInt(idxNum, 10));
      // Pragmatic default for "open it/this/that"
      if (/(\bit\b|\bthis\b|\bthat\b)/i.test(lowerText) && !idxWord && !idxNum) index = 1;

      tasks.push({
        id: this.generateTaskId(),
        tool: 'open_search_result',
        parameters: { index },
        description: `Open search result #${index}`
      });
      return tasks;
    }

    // Open/create commands
    if (lowerText.includes('open') || lowerText.includes('create') || lowerText.includes('show') || lowerText.includes('start')) {
      let windowType = 'general';
      let content = '';
      let metadata: Record<string, any> | undefined = undefined;
      let count = 1;
      
      if (lowerText.includes('sticky note') || lowerText.includes('note')) {
        windowType = 'sticky-note';
        // Extract content after "note" or similar keywords
        const noteMatch = text.match(/(?:sticky note|note|reminder)(?:\s+(?:saying|with|that says|about))?\s*["']?([^"']+)["']?/i);
        content = noteMatch ? noteMatch[1].trim() : 'New sticky note';
      } else if (lowerText.includes('lesson')) {
        windowType = 'lesson';
        const title = this.extractTitle(text) || 'New Lesson';
        const stepMatch = text.match(/step\s*(\d+)/i);
        const lessonIdMatch = text.match(/lesson\s*(id\s*)?(\w+)/i);
        metadata = {
          lessonId: lessonIdMatch ? lessonIdMatch[2] : undefined,
          step: stepMatch ? Number(stepMatch[1]) : undefined
        };
        content = content || 'Lesson content';
      } else if (lowerText.includes('quiz')) {
        windowType = 'quiz';
        const title = this.extractTitle(text) || 'Quiz';
        metadata = { title };
        content = content || 'Quiz content';
      } else if (lowerText.includes('hint')) {
        windowType = 'hint';
        const hintMatch = text.match(/hint(?:\s+(?:about|for))?\s*["']?([^"']+)["']?/i);
        content = hintMatch ? hintMatch[1].trim() : 'Hint';
      } else if (lowerText.includes('explain') || lowerText.includes('explainer')) {
        windowType = 'explainer';
        const topicMatch = text.match(/explain(?:\s+(?:about|the|how to))?\s*["']?([^"']+)["']?/i);
        content = topicMatch ? topicMatch[1].trim() : 'Explanation';
      } else if (lowerText.includes('notification')) {
        windowType = 'notification';
        content = 'Notification';
      } else if (lowerText.includes('dialog')) {
        windowType = 'dialog';
        content = 'Dialog window';
      } else if (lowerText.includes('settings')) {
        windowType = 'settings';
        content = 'Settings';
      }

      // Parse counts: e.g., "open 7 windows saying cheese", "open seven windows" (basic digits only here)
      const countMatch = text.match(/open\s+(\d{1,2})\s+(?:window|windows)/i);
      if (countMatch) {
        const n = parseInt(countMatch[1], 10);
        if (!Number.isNaN(n) && n > 1 && n <= 20) count = n;
      }
      
      // Generic content extraction for phrases like: say "...", with content "...", display "..."
      if (!content) {
        const sayPattern = /(?:say|that\s+says|saying|with\s+(?:content|text)|message|display|show\s+text)\s*["']([^"']+)["']/i;
        const sayMatch = text.match(sayPattern);
        if (sayMatch) {
          content = sayMatch[1].trim();
        }
      }

      // Unquoted say/saying patterns: capture text after say/saying until end
      if (!content) {
        const sayPlainPattern = /(?:say|saying|that\s+says)\s+(.+?)$/i;
        const sayPlainMatch = text.match(sayPlainPattern);
        if (sayPlainMatch) {
          content = sayPlainMatch[1].trim();
        }
      }

      // Fallback: if still no content, use first quoted string in the command as content
      if (!content) {
        const anyQuoteMatch = text.match(/"([^\"]+)"|'([^']+)'/);
        if (anyQuoteMatch) {
          content = (anyQuoteMatch[1] || anyQuoteMatch[2] || '').trim();
        }
      }

      for (let i = 0; i < count; i++) {
        tasks.push({
          id: this.generateTaskId(),
          tool: 'open_window',
          parameters: {
            windowType: windowType,
            context: {
              title: this.extractTitle(text) || this.capitalizeFirst(windowType),
              content: content || 'Window content',
              type: windowType,
              metadata
            }
          },
          description: `Open ${windowType} window`
        });
      }
    }

    // Edit window intents: rename/set/append/prepend/clear content
    if (/(rename|retitle|change\s+title)/i.test(lowerText)) {
      const m = text.match(/(?:to|as)\s+"([^"]+)"|(?:to|as)\s+'([^']+)'|(?:to|as)\s+(.+)$/i);
      const newTitle = m ? (m[1] || m[2] || m[3] || '').trim() : '';
      if (newTitle) {
        tasks.push({
          id: this.generateTaskId(),
          tool: 'edit_window',
          parameters: { selector: 'active', title: newTitle },
          description: `Rename active window to ${newTitle}`
        });
        return tasks;
      }
    }

    if (/(append|add\s+to|add\s+into)/i.test(lowerText)) {
      const m = text.match(/(?:append|add(?:\s+to|\s+into)?)\s+"([^"]+)"|(?:append|add(?:\s+to|\s+into)?)\s+'([^']+)'|(?:append|add(?:\s+to|\s+into)?)\s+(.+)$/i);
      const txt = m ? (m[1] || m[2] || m[3] || '').trim() : '';
      if (txt) {
        tasks.push({
          id: this.generateTaskId(),
          tool: 'edit_window',
          parameters: { selector: 'active', content: txt, mode: 'append' },
          description: `Append to active window`
        });
        return tasks;
      }
    }

    if (/(set|replace)\s+(content|text)/i.test(lowerText)) {
      const m = text.match(/(?:set|replace)\s+(?:content|text)\s+to\s+"([^"]+)"|(?:set|replace)\s+(?:content|text)\s+to\s+'([^']+)'|(?:set|replace)\s+(?:content|text)\s+to\s+(.+)$/i);
      const txt = m ? (m[1] || m[2] || m[3] || '').trim() : '';
      if (txt) {
        tasks.push({
          id: this.generateTaskId(),
          tool: 'edit_window',
          parameters: { selector: 'active', content: txt, mode: 'set' },
          description: `Set content of active window`
        });
        return tasks;
      }
    }

    if (/(prepend)/i.test(lowerText)) {
      const m = text.match(/prepend\s+"([^"]+)"|prepend\s+'([^']+)'|prepend\s+(.+)$/i);
      const txt = m ? (m[1] || m[2] || m[3] || '').trim() : '';
      if (txt) {
        tasks.push({
          id: this.generateTaskId(),
          tool: 'edit_window',
          parameters: { selector: 'active', content: txt, mode: 'prepend' },
          description: `Prepend to active window`
        });
        return tasks;
      }
    }

    if (/(clear|empty|wipe)\s+(window|content|text)/i.test(lowerText)) {
      tasks.push({
        id: this.generateTaskId(),
        tool: 'edit_window',
        parameters: { selector: 'active', mode: 'clear' },
        description: `Clear active window`
      });
      return tasks;
    }

    // Group management commands
    if (/(create|make|new)\s+group/i.test(lowerText)) {
      const groupMatch = text.match(/(?:create|make|new)\s+group\s+(?:called\s+)?["']?([^"']+?)["']?(?:\s*(?:,|and)?\s*(?:make\s+it\s+)?(?:the\s+)?(?:color|with\s+color)\s+([a-zA-Z#]+))?/i);
      if (groupMatch) {
        const name = groupMatch[1].trim();
        const color = groupMatch[2] || 'blue';
        tasks.push({
          id: this.generateTaskId(),
          tool: 'create_group',
          parameters: { name, color },
          description: `Create group: ${name} (${color})`
        });
      }
    }

    if (lowerText.includes('move') && (lowerText.includes('to group') || lowerText.includes('group'))) {
      const moveMatch = text.match(/move\s+(?:(?:this|the|current)\s+)?(?:window\s+)?(?:to\s+)?group\s+["']?([^"']+?)["']?/i);
      if (moveMatch) {
        const groupName = moveMatch[1].trim();
        tasks.push({
          id: this.generateTaskId(),
          tool: 'assign_group',
          parameters: { groupName, selector: 'newest' },
          description: `Move window to group: ${groupName}`
        });
      }
    }
    
    return tasks;
  }

  private extractTitle(text: string): string | null {
    // Extract title ONLY when explicitly specified with keywords like 'titled', 'called', 'named'
    // Do NOT extract quotes as titles - let content extraction handle those
    const titlePatterns = [
      /titled\s+["']?([^"']+?)["']?(?:\s+window|$)/i,
      /called\s+["']?([^"']+?)["']?(?:\s+window|$)/i,
      /named\s+["']?([^"']+?)["']?(?:\s+window|$)/i,
      /title\s+["']?([^"']+?)["']?(?:\s+window|$)/i,
      /with\s+title\s+["']?([^"']+?)["']?(?:\s+window|$)/i
    ];
    
    for (const pattern of titlePatterns) {
      const match = text.match(pattern);
      if (match) {
        return match[1].trim();
      }
    }
    
    return null;
  }

  private normalizeEducationIntent(text: string, task: Task): Task {
    try {
      const lowerText = text.toLowerCase();
      if (task.tool !== 'open_window') return task;
      const params = task.parameters as any;
      if (!params || !params.context) return task;
      const currentType = (params.windowType || params.context.type || '').toLowerCase();

      // Map explain intents to explainer type if model returned general
      if ((lowerText.includes('explain') || lowerText.includes('explainer') || lowerText.includes('step by step')) && (currentType === 'general' || currentType === '')) {
        params.windowType = 'explainer';
        params.context.type = 'explainer';
        if (!params.context.title) {
          const topicMatch = text.match(/explain(?:\s+(?:about|the|how to))?\s*["']?([^"']+)["']?/i);
          params.context.title = topicMatch ? this.capitalizeFirst(topicMatch[1].trim()) : 'Explainer';
        }
        if (!params.context.content) {
          params.context.content = 'Explanation';
        }
        task.description = this.generateTaskDescription('open_window', params);
      }

      // Map lesson intent
      if (lowerText.includes('lesson') && (currentType === 'general' || currentType === '')) {
        params.windowType = params.windowType || 'lesson';
        params.context.type = params.context.type || 'lesson';
      }

      // Map quiz intent
      if (lowerText.includes('quiz') && (currentType === 'general' || currentType === '')) {
        params.windowType = params.windowType || 'quiz';
        params.context.type = params.context.type || 'quiz';
      }

      // Map hint intent
      if (lowerText.includes('hint') && (currentType === 'general' || currentType === '')) {
        params.windowType = params.windowType || 'hint';
        params.context.type = params.context.type || 'hint';
      }

      return task;
    } catch {
      return task;
    }
  }

  private generateTaskDescription(toolName: string, parameters: any): string {
    switch (toolName) {
      case 'open_window':
        return `Open ${parameters.windowType || 'window'}: ${parameters.context?.title || 'Untitled'}`;
      case 'close_window':
        return `Close window: ${parameters.windowId}`;
      default:
        return `Execute ${toolName}`;
    }
  }

  private generateTaskId(): string {
    return `task_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }

  private capitalizeFirst(str: string): string {
    return str.charAt(0).toUpperCase() + str.slice(1);
  }
}
</file>

<file path="src/ui/components/windowManager/WindowManager.tsx">
'use client';

import { useEffect, useState, forwardRef, useImperativeHandle } from 'react';
import { Window } from '../window';
import { WindowData, WindowManagerState, WindowGroup } from './windowManager.types';
import { eventBus } from '@/lib/eventBus';

interface WindowManagerProps {
  children: React.ReactNode;
  onWindowsChange?: (windows: WindowData[]) => void;
}

export interface WindowManagerRef {
  createGroup: (name: string, color: string) => void;
  assignWindowToGroup: (windowId: string, groupName: string) => void;
  openWindow: (windowData: Omit<WindowData, 'isOpen' | 'isMinimized' | 'zIndex'>) => void;
  closeWindow: (windowId: string) => void;
  minimizeWindow: (windowId: string) => void;
  getWindows: () => WindowData[];
}

export const WindowManager = forwardRef<WindowManagerRef, WindowManagerProps>((props, ref) => {
  const { children, onWindowsChange } = props;
  const [groups, setGroups] = useState<Record<string, WindowGroup>>({});
  const [state, setState] = useState<WindowManagerState>({
    windows: [],
    activeWindowId: null,
    nextZIndex: 10
  });

  const openWindow = (windowData: Omit<WindowData, 'isOpen' | 'isMinimized' | 'zIndex'>) => {
    setState(prev => ({
      ...prev,
      windows: [
        ...prev.windows.filter(w => w.id !== windowData.id),
        {
          ...windowData,
          isOpen: true,
          isMinimized: false,
          zIndex: prev.nextZIndex
        }
      ],
      activeWindowId: windowData.id,
      nextZIndex: prev.nextZIndex + 1
    }));
    // Do not re-emit a simplified 'window:opened' here; the AI layer already emits
    // a full detail event before this, and re-emitting can overwrite metadata.
  };

  const closeWindow = (windowId: string) => {
    setState(prev => ({
      ...prev,
      windows: prev.windows.filter(w => w.id !== windowId),
      activeWindowId: prev.activeWindowId === windowId ? null : prev.activeWindowId
    }));
    // Sync with global registry
    try {
      eventBus.emit('window:closed', { windowId });
    } catch {}
  };

  const minimizeWindow = (windowId: string) => {
    setState(prev => ({
      ...prev,
      windows: prev.windows.map(w =>
        w.id === windowId
          ? { ...w, isMinimized: true }
          : w
      ),
      activeWindowId: null
    }));
  };

  const focusWindow = (windowId: string) => {
    setState(prev => ({
      ...prev,
      activeWindowId: windowId,
      windows: prev.windows.map(w =>
        w.id === windowId
          ? { ...w, zIndex: prev.nextZIndex }
          : w
      ),
      nextZIndex: prev.nextZIndex + 1
    }));
    try {
      eventBus.emit('window:focused', { windowId });
    } catch {}
  };

  
  const createGroup = (name: string, color: string) => {
    setGroups(prev => ({
      ...prev,
      [name.toLowerCase()]: { name, color }
    }));
  };

  const assignWindowToGroup = (windowId: string, groupName: string) => {
    const group = groups[groupName.toLowerCase()];
    if (!group) return;
    
    setState(prev => ({
      ...prev,
      windows: prev.windows.map(w =>
        w.id === windowId ? { ...w, group } : w
      )
    }));
  };

  useImperativeHandle(ref, () => ({
    createGroup,
    assignWindowToGroup,
    openWindow,
    closeWindow,
    minimizeWindow,
    getWindows: () => state.windows
  }));

  useEffect(() => {
    if (onWindowsChange) {
      onWindowsChange(state.windows);
    }
  }, [state.windows, onWindowsChange]);

  // Listen for AI/UI events to open/close windows
  useEffect(() => {
    const unsubs = [
      eventBus.on('window:create_group', (data: any) => {
        if (data?.name && data?.color) {
          createGroup(data.name, data.color);
        }
      }),
      eventBus.on('window:assign_group', (data: any) => {
        if (data?.windowId && data?.groupName) {
          assignWindowToGroup(data.windowId, data.groupName);
        }
      }),
      eventBus.on('ui:open_window', (data: any) => {
  console.log(`[WindowManager] ui:open_window:`, data);
        const id = data?.id || `win_${Date.now()}`;
        const inferTitle = (): string => {
          const provided = String(data?.title || '');
          const current = provided || 'General';
          const ctxType = String(data?.type || data?.context?.type || '').toLowerCase();
          const contentText = String(data?.content || data?.context?.content || '');
          const meta = (data?.context && (data.context as any).metadata) || {};
          const isGeneric = !provided || /untitled/i.test(provided) || provided === 'General';
          if (!isGeneric) return current;
          if (ctxType === 'search-results' && typeof meta.searchQuery === 'string' && meta.searchQuery.length > 0) {
            return `Search: ${meta.searchQuery}`;
          }
          const sum = contentText.match(/Summary of:\s*([^\n]+)/i);
          if (ctxType === 'notes' || sum) {
            if (sum && sum[1]) return `Summary: ${sum[1].trim().slice(0, 60)}`;
            return 'Summary';
          }
          if (/(theorem|lemma|proof|integral|derivative|matrix|vector|algebra|calculus|trigonometry)\b/i.test(contentText) || /[=+\-*/^]/.test(contentText)) {
            return 'Math';
          }
          return current;
        };
        const title = inferTitle();
        const urlForWebview = data?.context?.metadata?.url || data?.url;
        openWindow({
          id,
          title,
          component: (props?: any) => {
            if (urlForWebview && urlForWebview !== 'null' && urlForWebview !== 'undefined') {
              const { useEffect, useState } = require('react');
              const [reader, setReader] = useState<any | null>(null);
              const [loadError, setLoadError] = useState<string | null>(null);
              const [iframeBlocked, setIframeBlocked] = useState(false);
              const [iframeLoaded, setIframeLoaded] = useState(false);
              const [useProxy, setUseProxy] = useState(false);
              const [proxyUrl, setProxyUrl] = useState<string | null>(null);
              const [preflightDone, setPreflightDone] = useState(false);

              const fetchReader = async () => {
                try {
                  console.log(`[WindowManager] Fetching reader for: ${urlForWebview}`);
                  const resp = await fetch('/api/fetch-article', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ url: String(urlForWebview) })
                  });
                  if (!resp.ok) throw new Error(`Reader HTTP ${resp.status}`);
                  const data = await resp.json();
                  setReader(data);
                } catch (e) {
                  const msg = e instanceof Error ? e.message : String(e);
                  console.error(`[WindowManager] Reader fetch failed:`, msg);
                  setLoadError(msg);
                }
              };

              const testProxy = async () => {
                try {
                  const testUrl = `/api/proxy-page?url=${encodeURIComponent(String(urlForWebview))}`;
                  console.log(`[WindowManager] Testing proxy for: ${urlForWebview}`);
                  const resp = await fetch(testUrl, { method: 'GET' });
                  if (resp.ok) {
                    setProxyUrl(testUrl);
                    setUseProxy(true);
                  } else {
                    console.warn(`[WindowManager] Proxy returned HTTP ${resp.status}, falling back to reader`);
                    fetchReader();
                  }
                } catch (e) {
                  console.warn(`[WindowManager] Proxy test failed, falling back to reader`);
                  fetchReader();
                }
              };

              const preflight = async () => {
                try {
                  const resp = await fetch('/api/fetch-article', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ url: String(urlForWebview), mode: 'head' })
                  });
                  if (resp.ok) {
                    const head = await resp.json();
                    if (head?.embeddingBlocked) {
                      console.log(`[WindowManager] Preflight indicates iframe blocked for: ${urlForWebview}`);
                      setIframeBlocked(true);
                      testProxy();
                    }
                  }
                } catch {}
                setPreflightDone(true);
              };

              useEffect(() => {
                preflight();
              }, []);

              useEffect(() => {
                // Auto-fallback after 3s: try proxy first, then reader
                const timer = setTimeout(() => {
                  if (!reader && !loadError && !iframeBlocked && !iframeLoaded) {
                    console.log(`[WindowManager] Auto-fallback: trying proxy for ${urlForWebview}`);
                    setIframeBlocked(true);
                    testProxy();
                  }
                }, 3000);
                return () => clearTimeout(timer);
              }, [reader, loadError, iframeBlocked, iframeLoaded]);

              useEffect(() => {
                if (reader && reader.textContent) {
                  try { 
                    eventBus.emit('window:content_ready', { windowId: id, url: String(urlForWebview), title: reader.title, text: reader.textContent }); 
                    // Update window header title to the article's title when reader loads
                    if (reader.title && typeof reader.title === 'string' && reader.title.length > 0) {
                      eventBus.emit('ui:update_window', { windowId: id, title: reader.title });
                    }
                  } catch {}
                }
              }, [reader]);

              if (!preflightDone) {
                return (
                  <div className="w-full h-full flex items-center justify-center text-xs text-gray-600">
                    Loading...
                  </div>
                );
              } else if (reader) {
                return (
                  <div className="w-full h-full overflow-auto p-4 text-sm text-gray-800">
                    <div className="mb-2 text-xs text-gray-500">Reader view</div>
                    <div className="text-lg font-semibold">{reader.title || title}</div>
                    {reader.byline ? <div className="text-xs text-gray-500 mb-3">{reader.byline}</div> : null}
                    <div className="whitespace-pre-wrap">{reader.textContent || ''}</div>
                    <div className="mt-4 pt-2 border-t border-gray-200">
                      <a href={String(urlForWebview)} target="_blank" rel="noopener noreferrer" 
                         className="text-blue-600 hover:text-blue-800 text-xs">
                        Open in new tab â†’
                      </a>
                    </div>
                  </div>
                );
              } else if (useProxy && proxyUrl) {
                return (
                  <iframe
                    src={proxyUrl}
                    className="w-full h-full border-0"
                    sandbox="allow-scripts allow-same-origin allow-forms allow-popups"
                    referrerPolicy="no-referrer"
                    allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
                    loading="lazy"
                    onLoad={() => { console.log(`[WindowManager] Proxy webview loaded: ${proxyUrl}`); setIframeLoaded(true); }}
                    onError={() => { 
                      console.error(`[WindowManager] Proxy webview error for ${proxyUrl}`); 
                      setUseProxy(false);
                      fetchReader();
                    }}
                  />
                );
              } else if (iframeBlocked || loadError) {
                return (
                  <div className="w-full h-full flex items-center justify-center p-4">
                    <div className="text-center text-gray-600">
                      <div className="mb-2">
                        {loadError ? `Reader error: ${loadError}` : 'Website blocked iframe embedding'}
                      </div>
                      <a href={String(urlForWebview)} target="_blank" rel="noopener noreferrer" 
                         className="text-blue-600 hover:text-blue-800">
                        Open in new tab â†’
                      </a>
                    </div>
                  </div>
                );
              } else {
                return (
                  <iframe
                    src={String(urlForWebview)}
                    className="w-full h-full border-0"
                    sandbox="allow-scripts allow-same-origin allow-forms allow-popups"
                    referrerPolicy="no-referrer"
                    allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
                    loading="lazy"
                    onLoad={() => { console.log(`[WindowManager] Webview loaded: ${urlForWebview}`); setIframeLoaded(true); }}
                    onError={() => { 
                      console.error(`[WindowManager] Webview error for ${urlForWebview}`); 
                      setIframeBlocked(true);
                      testProxy();
                    }}
                  />
                );
              }
            } else {
              const content = typeof props?.content === 'string' ? props.content : String(data?.content || '');
              return (
                <div className="p-4 text-gray-800 text-sm whitespace-pre-wrap">{content}</div>
              );
            }
          },
          content: String(data?.content || ''),
          group: data?.group && typeof data.group === 'object' ? { name: String(data.group.name || ''), color: String(data.group.color || '#6b7280') } as WindowGroup : undefined,
          x: data?.position?.x ?? 120,
          y: data?.position?.y ?? 120,
          width: data?.size?.width ?? 360,
          height: data?.size?.height ?? 240
        });
      }),
      eventBus.on('ui:update_window', (data: any) => {
        const { windowId, title, contentUpdate } = data || {};
        if (!windowId) return;
        setState(prev => ({
          ...prev,
          windows: prev.windows.map(w => {
            if (w.id !== windowId) return w;
            let newContent = String(w.content || '');
            if (contentUpdate) {
              const mode = String(contentUpdate.mode || 'set');
              const text = String(contentUpdate.text || '');
              if (mode === 'set') newContent = text;
              else if (mode === 'append') newContent = (newContent ? newContent + '\n' : '') + text;
              else if (mode === 'prepend') newContent = text + (newContent ? '\n' + newContent : '');
              else if (mode === 'clear') newContent = '';
            }
            return { ...w, title: typeof title === 'string' && title.length > 0 ? title : w.title, content: newContent };
          })
        }));
      }),
      eventBus.on('ui:close_window', (data: any) => {
        if (data?.windowId) {
          closeWindow(data.windowId);
        }
      })
    ];
    return () => { unsubs.forEach((u) => u()); };
  }, []);

  return (
    <div className="relative w-full h-full">
      {/* Desktop Background */}
      <div className="absolute inset-0 bg-gradient-to-br from-indigo-600 via-purple-600 to-pink-600">
        <div className="absolute inset-0 bg-gradient-to-tr from-blue-500/20 via-transparent to-cyan-300/20"></div>
        <div className="absolute inset-0 bg-[radial-gradient(circle_at_30%_20%,rgba(120,119,198,0.3),transparent_50%)]"></div>
        <div className="absolute inset-0 bg-[radial-gradient(circle_at_70%_80%,rgba(255,119,198,0.2),transparent_50%)]"></div>
        {children}
      </div>

      {/* Render Windows */}
      {state.windows.map(window => {
        const WindowComponent = window.component;
        return (
          <Window
            key={window.id}
            id={window.id}
            title={window.title}
            initialX={window.x}
            initialY={window.y}
            width={window.width}
            height={window.height}
            isActive={state.activeWindowId === window.id}
            onClose={() => closeWindow(window.id)}
            onMinimize={() => minimizeWindow(window.id)}
            onFocus={() => focusWindow(window.id)}
          >
            <WindowComponent />
          </Window>
        );
      })}
    </div>
  );
});
</file>

<file path="src/ai/toolExecutor.ts">
/* eslint-disable @typescript-eslint/no-explicit-any */
import { Task, OpenWindowParams, CloseWindowParams, WebSearchParams, CreateGroupParams, AssignGroupParams, SummarizeArticleParams, EditWindowParams } from './types';
import { eventBus } from '@/lib/eventBus';
import { windowRegistry } from './windowRegistry';

export interface ExecutionResult {
  taskId: string;
  success: boolean;
  result?: any;
  error?: string;
  timestamp: number;
}

export class ToolExecutor {
  // Note: all web search now routes through server API; no client Gemini usage
  constructor() {}
  async executeTasks(tasks: Task[]): Promise<ExecutionResult[]> {
    eventBus.emit('ai:task_queue_updated', tasks);
    const results: ExecutionResult[] = [];
    
    for (const task of tasks) {
      try {
        const result = await this.executeTask(task);
        results.push(result);
      } catch (error) {
        const errorResult = {
          taskId: task.id,
          success: false,
          error: error instanceof Error ? error.message : String(error),
          timestamp: Date.now()
        };
        results.push(errorResult);
        eventBus.emit('ai:task_failed', { task, error: errorResult.error });
      }
    }
    
    return results;
  }

  private async executeTask(task: Task): Promise<ExecutionResult> {
    eventBus.emit('ai:task_started', { task });
    const startTime = Date.now();
    
    try {
      let result: ExecutionResult;
      switch (task.tool) {
        case 'open_window':
          result = await this.executeOpenWindow(task);
          break;
        
        case 'close_window':
          result = await this.executeCloseWindow(task);
          break;
        
        case 'web_search':
          result = await this.executeWebSearch(task);
          break;
        
        case 'open_webview':
          result = await this.executeOpenWebView(task);
          break;
        
        case 'create_group':
          result = await this.executeCreateGroup(task);
          break;
        
        case 'assign_group':
          result = await this.executeAssignGroup(task);
          break;
        case 'edit_window':
          result = await this.executeEditWindow(task);
          break;

        case 'open_search_result':
          result = await this.executeOpenSearchResult(task);
          break;
        case 'summarize_article':
          result = await this.executeSummarizeArticle(task);
          break;
        
        default:
          throw new Error(`Unknown tool: ${task.tool}`);
      }
      
      eventBus.emit('ai:task_completed', { task, result });
      return result;
    } catch (error) {
      const errorMsg = error instanceof Error ? error.message : String(error);
      eventBus.emit('ai:task_failed', { task, error: errorMsg });
      return {
        taskId: task.id,
        success: false,
        error: errorMsg,
        timestamp: Date.now() - startTime
      };
    }
  }

  private async executeOpenWindow(task: Task): Promise<ExecutionResult> {
    const params = task.parameters as OpenWindowParams;
    eventBus.emit('ai:tool_call_started', { task, tool: 'open_window', params });
    
    // Validate parameters
    if (!params.windowType || !params.context) {
      throw new Error('Missing required parameters for open_window: windowType and context are required');
    }
    
    // Generate a unique window ID
    const windowId = this.generateWindowId();
    
    // Emit event to UI for window creation
    const windowData = {
      id: windowId,
      type: params.windowType,
      title: params.context.title || 'Untitled Window',
      content: params.context.content || '',
      position: params.context.position || { x: 100, y: 100 },
      size: params.context.size || { width: 300, height: 200 },
      context: params.context,
      timestamp: Date.now()
    };
    
    // Emit to event bus for UI to handle
    eventBus.emit('ui:open_window', windowData);
    
    // Also emit a general window event
    eventBus.emit('window:opened', windowData);

    // If running inside a Web Worker, forward to the main thread
    // so the UI (which listens on the main thread) can react.
    try {
      // In a worker, globalThis/self has postMessage and window is undefined
      if (typeof self !== 'undefined' && typeof (self as any).postMessage === 'function' && typeof (globalThis as any).window === 'undefined') {
        (self as any).postMessage({ type: 'UI_OPEN_WINDOW', data: windowData });
      }
    } catch (_) {
      // no-op if environment detection fails
    }
    
    console.log(`[ToolExecutor] Opening ${params.windowType} window:`, windowData);
    
    const result = {
      taskId: task.id,
      success: true,
      result: {
        windowId: windowId,
        windowType: params.windowType,
        context: params.context
      },
      timestamp: Date.now()
    };
    eventBus.emit('ai:tool_call_completed', { task, tool: 'open_window', result });
    return result;
  }

  private async executeCloseWindow(task: Task): Promise<ExecutionResult> {
    const params = task.parameters as CloseWindowParams;
    eventBus.emit('ai:tool_call_started', { task, tool: 'close_window', params });

    // Resolve selector to actual window ID if needed
    let targetWindowId = params.windowId;
    if (!targetWindowId && params.selector) {
      if (params.selector === 'newest' || params.selector === 'latest') {
        targetWindowId = windowRegistry.getNewest()?.id;
      } else if (params.selector === 'oldest') {
        targetWindowId = windowRegistry.getOldest()?.id;
      } else if (params.selector === 'active') {
        const reg: any = windowRegistry as any;
        targetWindowId = reg.getActive ? reg.getActive()?.id : undefined;
      } else if (params.selector === 'all') {
        // Broadcast close for each known window
        const reg: any = windowRegistry as any;
        const all: Array<{ id: string }> = (reg.getAll ? reg.getAll() : []) || [];
        all.forEach(w => {
          const closeData = { windowId: w.id, timestamp: Date.now() };
          eventBus.emit('ui:close_window', closeData);
          eventBus.emit('window:closed', closeData);
          
          // Forward to worker if needed
          try {
            if (typeof self !== 'undefined' && typeof (self as any).postMessage === 'function' && typeof (globalThis as any).window === 'undefined') {
              (self as any).postMessage({ type: 'UI_CLOSE_WINDOW', data: closeData });
            }
          } catch (_) {
            // no-op
          }
        });
        console.log(`[ToolExecutor] Closing all windows (${all.length})`);
        const result = {
          taskId: task.id,
          success: true,
          result: { closedAll: true, count: all.length },
          timestamp: Date.now()
        };
        eventBus.emit('ai:tool_call_completed', { task, tool: 'close_window', result });
        return result;
      }
    }

    // Validate parameters
    if (!targetWindowId) {
      throw new Error('No target window found to close');
    }

    // Emit event to UI for window closure
    const closeData = {
      windowId: targetWindowId,
      timestamp: Date.now()
    };

    // Emit to event bus for UI to handle
    eventBus.emit('ui:close_window', closeData);

    // Also emit a general window event
    eventBus.emit('window:closed', closeData);

    // If running inside a Web Worker, forward to the main thread
    try {
      if (typeof self !== 'undefined' && typeof (self as any).postMessage === 'function' && typeof (globalThis as any).window === 'undefined') {
        (self as any).postMessage({ type: 'UI_CLOSE_WINDOW', data: closeData });
      }
    } catch (_) {
      // no-op
    }

    console.log(`[ToolExecutor] Closing window:`, closeData);

    const result = {
      taskId: task.id,
      success: true,
      result: {
        windowId: targetWindowId,
        closed: true
      },
      timestamp: Date.now()
    };
    eventBus.emit('ai:tool_call_completed', { task, tool: 'close_window', result });
    return result;
  }


  private async executeWebSearch(task: Task): Promise<ExecutionResult> {
    const params = task.parameters as WebSearchParams;
    eventBus.emit('ai:tool_call_started', { task, tool: 'web_search', params });

    try {
      // Validate parameters
      if (!params.query) {
        throw new Error('Missing required parameter: query');
      }

      const resultCount = params.resultCount || 5;
      const displayMode = params.displayMode || 'auto';

      // Build absolute URL in worker contexts
      let targetUrl = '/api/web-search';
      try {
        const isWorker = typeof self !== 'undefined' && typeof (self as any).postMessage === 'function' && typeof (globalThis as any).window === 'undefined';
        if (isWorker) {
          let origin = 'http://localhost:3000';
          try {
            if (typeof location !== 'undefined' && (location as any)?.origin) {
              origin = (location as any).origin;
            } else if (typeof location !== 'undefined' && (location as any)?.href) {
              origin = new URL((location as any).href).origin;
            }
          } catch {}
          targetUrl = `${origin}/api/web-search`;
        }
      } catch {}

      // Call server route to perform web search (Gemini or fallback)
      const resp = await fetch(targetUrl, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ query: params.query, resultCount })
      });
      if (!resp.ok) throw new Error(`Search HTTP ${resp.status}`);
      const data = await resp.json();
      const searchResults = Array.isArray(data?.results) ? data.results : [];
  console.log(`[ToolExecutor] Web search returned ${searchResults.length} results:`, searchResults);

      if (searchResults.length === 0) {
        throw new Error('No search results found');
      }

      // Determine display mode
      let finalDisplayMode = displayMode;
      if (displayMode === 'auto') {
        finalDisplayMode = searchResults.length === 1 ? 'summary' : 'links';
      }

      // Revert: do not auto-open the first result. Always show summary/links first.

      // Generate window content based on display mode
      let windowContent = '';
      let windowTitle = `Search: ${params.query}`;

      if (finalDisplayMode === 'summary' && searchResults[0]) {
        const result = searchResults[0];
        windowContent = `**${result.title}**\n\n${result.content || result.snippet}\n\nðŸ”— ${result.url}`;
      } else if (finalDisplayMode === 'full' && searchResults[0]) {
        const result = searchResults[0];
        windowContent = `# ${result.title}\n\n${result.content || result.snippet}\n\n---\nðŸ”— ${result.url}`;
      } else {
        // Links mode - multiple results
        windowContent = `**Search Results for "${params.query}"**

${searchResults.map((result: { title: string; url: string; snippet: string }, index: number) => 
  `${index + 1}. **${result.title}**
   ${result.snippet}\n   ðŸ”— ${result.url}
`).join('\n\n')}

Found ${searchResults.length} result${searchResults.length === 1 ? '' : 's'}`;
      }

      // Generate a unique window ID
      const windowId = this.generateWindowId();

      // Create window data
      const windowData = {
        id: windowId,
        type: 'search-results',
        title: windowTitle,
        content: windowContent,
        position: { x: 150, y: 150 },
        size: { width: 600, height: 400 },
        context: {
          title: windowTitle,
          content: windowContent,
          type: 'search-results',
          metadata: {
            searchQuery: params.query,
            resultCount: searchResults.length,
            displayMode: finalDisplayMode,
            results: searchResults
          }
        },
        timestamp: Date.now()
      };

      // Emit to event bus for UI to handle
      eventBus.emit('ui:open_window', windowData);
      eventBus.emit('window:opened', windowData);

      // Forward to worker if needed
      try {
        if (typeof self !== 'undefined' && typeof (self as any).postMessage === 'function' && typeof (globalThis as any).window === 'undefined') {
          (self as any).postMessage({ type: 'UI_OPEN_WINDOW', data: windowData });
        }
      } catch (_) {
        // no-op
      }

      console.log(`[ToolExecutor] Web search completed for: "${params.query}"`, windowData);

      const result = {
        taskId: task.id,
        success: true,
        result: {
          windowId: windowId,
          searchQuery: params.query,
          resultCount: searchResults.length,
          displayMode: finalDisplayMode,
          searchResults: searchResults
        },
        timestamp: Date.now()
      };

      eventBus.emit('ai:tool_call_completed', { task, tool: 'web_search', result });
      return result;

    } catch (error) {
      const errorMsg = error instanceof Error ? error.message : String(error);
      console.error('[ToolExecutor] Web search failed:', errorMsg);
      
      // Open an error window so the user sees feedback
      try {
        const windowId = this.generateWindowId();
        const windowData = {
          id: windowId,
          type: 'search-results',
          title: `Search Error`,
          content: `Search failed for "${params.query}": ${errorMsg}`,
          position: { x: 180, y: 180 },
          size: { width: 540, height: 300 },
          context: { title: 'Search Error', content: errorMsg, type: 'search-results' },
          timestamp: Date.now()
        };
        eventBus.emit('ui:open_window', windowData);
        eventBus.emit('window:opened', windowData);
      } catch {}

      eventBus.emit('ai:tool_call_failed', { task, tool: 'web_search', error: errorMsg });
      
      return {
        taskId: task.id,
        success: false,
        error: errorMsg,
        timestamp: Date.now()
      };
    }
  }

  private async executeOpenWebView(task: Task): Promise<ExecutionResult> {
    const params = task.parameters as { url: string; title?: string; width?: number; height?: number };
    eventBus.emit('ai:tool_call_started', { task, tool: 'open_webview', params });

    if (!params.url || typeof params.url !== 'string') {
      throw new Error('open_webview requires a valid url');
    }

    const windowId = this.generateWindowId();
    const windowData = {
      id: windowId,
      type: 'webview',
      title: params.title || params.url,
      content: '',
      position: { x: 160, y: 160 },
      size: { width: params.width || 900, height: params.height || 600 },
      context: {
        title: params.title || params.url,
        content: '',
        type: 'webview',
        metadata: { url: params.url }
      },
      timestamp: Date.now()
    };

    eventBus.emit('ui:open_window', windowData);
    eventBus.emit('window:opened', windowData);

    // Forward to worker if needed
    try {
      if (typeof self !== 'undefined' && typeof (self as any).postMessage === 'function' && typeof (globalThis as any).window === 'undefined') {
        (self as any).postMessage({ type: 'UI_OPEN_WINDOW', data: windowData });
      }
    } catch {}

    const result = {
      taskId: task.id,
      success: true,
      result: { windowId, url: params.url },
      timestamp: Date.now()
    };
    eventBus.emit('ai:tool_call_completed', { task, tool: 'open_webview', result });
    return result;
  }

  private async executeSummarizeArticle(task: Task): Promise<ExecutionResult> {
    const params = task.parameters as SummarizeArticleParams;
    eventBus.emit('ai:tool_call_started', { task, tool: 'summarize_article', params });

    if (!params.url) throw new Error('summarize_article requires url');

    // Fetch reader content from server
    const resp = await fetch('/api/fetch-article', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ url: params.url })
    });
    if (!resp.ok) throw new Error(`Reader HTTP ${resp.status}`);
    const article = await resp.json();

    const maxBullets = Math.max(3, Math.min(20, params.maxBullets || 8));

    // Simple summarization heuristic (client-side) if Gemini not desired here: first N sentences
    const sentences = String(article.textContent || '').split(/(?<=[.!?])\s+/).filter(Boolean);
    const bullets = sentences.slice(0, maxBullets).map(s => `- ${s}`);

    const content = `Summary of: ${article.title || params.url}\n\n${bullets.join('\n')}\n\nSource: ${params.url}`;

    const windowId = this.generateWindowId();
    const windowData = {
      id: windowId,
      type: 'notes',
      title: article.title ? `${article.title} â€” Notes` : 'Article Notes',
      content,
      position: { x: 180, y: 180 },
      size: { width: 500, height: 400 },
      context: { title: article.title || 'Notes', content, type: 'notes' },
      timestamp: Date.now()
    };
    eventBus.emit('ui:open_window', windowData);
    eventBus.emit('window:opened', windowData);

    const result = { taskId: task.id, success: true, result: { windowId, url: params.url }, timestamp: Date.now() };
    eventBus.emit('ai:tool_call_completed', { task, tool: 'summarize_article', result });
    return result;
  }

  private async executeOpenSearchResult(task: Task): Promise<ExecutionResult> {
    const params = task.parameters as { index?: number; url?: string; title?: string };
    eventBus.emit('ai:tool_call_started', { task, tool: 'open_search_result', params });

    const decodeDdg = (u: string) => {
      const m = u.match(/uddg=([^&]+)/);
      if (m) {
        try { return decodeURIComponent(m[1]); } catch {}
      }
      return u;
    };

    const openUrl = params.url ? decodeDdg(params.url) : undefined;
    if (openUrl && typeof openUrl === 'string') {
      return this.executeOpenWebView({
        ...task,
        tool: 'open_webview',
        parameters: { url: openUrl, title: params.title }
      });
    }

    // If no URL given, try to open from the last search-results window's stored metadata first,
    // falling back to parsing links from content if needed.
    try {
      const reg: any = windowRegistry as any;
      const all = reg.getAll ? reg.getAll() : [];
      const lastSearch = [...all].reverse().find((w: any) => w?.type === 'search-results');
      if (!lastSearch) throw new Error('No recent search results found');

      const idx = Math.max(1, params.index || 1) - 1;
      // Prefer structured results stored in window context metadata
      const structured: any[] = lastSearch?.meta?.context?.metadata?.results || [];
      let url: string | undefined;
      if (Array.isArray(structured) && structured[idx] && typeof structured[idx].url === 'string') {
        url = decodeDdg(structured[idx].url);
      }
      // Fallback: parse from rendered content
      if (!url) {
        const content: string = (lastSearch?.content || (lastSearch?.meta?.content || '')) as string;
        const urls = Array.from(content.matchAll(/https?:\/\/[^\s\)]+/g)).map(m => decodeDdg(m[0]));
        url = urls[idx];
      }
      if (!url) throw new Error('Requested result not found');

      return this.executeOpenWebView({
        ...task,
        tool: 'open_webview',
        parameters: { url, title: params.title }
      });
    } catch (e) {
      const errorMsg = e instanceof Error ? e.message : String(e);
      eventBus.emit('ai:tool_call_failed', { task, tool: 'open_search_result', error: errorMsg });
      return { taskId: task.id, success: false, error: errorMsg, timestamp: Date.now() };
    }
  }


  private async executeCreateGroup(task: Task): Promise<ExecutionResult> {
    const params = task.parameters as CreateGroupParams;
    eventBus.emit('ai:tool_call_started', { task, tool: 'create_group', params });

    try {
      if (!params.name || !params.color) {
        throw new Error('Missing required parameters: name and color');
      }

      // Emit event to create group
      eventBus.emit('window:create_group', {
        name: params.name,
        color: params.color
      });

      console.log(`[ToolExecutor] Created group "${params.name}" with color ${params.color}`);

      const result = {
        taskId: task.id,
        success: true,
        result: {
          groupName: params.name,
          groupColor: params.color
        },
        timestamp: Date.now()
      };

      eventBus.emit('ai:tool_call_completed', { task, tool: 'create_group', result });
      return result;

    } catch (error) {
      const errorMsg = error instanceof Error ? error.message : String(error);
      eventBus.emit('ai:tool_call_failed', { task, tool: 'create_group', error: errorMsg });
      
      return {
        taskId: task.id,
        success: false,
        error: errorMsg,
        timestamp: Date.now()
      };
    }
  }

  private async executeAssignGroup(task: Task): Promise<ExecutionResult> {
    const params = task.parameters as AssignGroupParams;
    eventBus.emit('ai:tool_call_started', { task, tool: 'assign_group', params });

    try {
      if (!params.groupName) {
        throw new Error('Missing required parameter: groupName');
      }

      let targetWindowId = params.windowId;
      if (!targetWindowId && params.selector) {
        if (params.selector === 'newest') {
          targetWindowId = windowRegistry.getNewest()?.id;
        } else if (params.selector === 'active') {
          const reg: any = windowRegistry as any;
          targetWindowId = reg.getActive ? reg.getActive()?.id : undefined;
        } else if (params.selector === 'all') {
          // Assign all windows to group
          const reg: any = windowRegistry as any;
          const all: Array<{ id: string }> = (reg.getAll ? reg.getAll() : []) || [];
          all.forEach(w => {
            eventBus.emit('window:assign_group', {
              windowId: w.id,
              groupName: params.groupName
            });
          });
          
          console.log(`[ToolExecutor] Assigned ${all.length} windows to group "${params.groupName}"`);
          
          const result = {
            taskId: task.id,
            success: true,
            result: { 
              groupName: params.groupName,
              assignedCount: all.length
            },
            timestamp: Date.now()
          };

          eventBus.emit('ai:tool_call_completed', { task, tool: 'assign_group', result });
          return result;
        }
      }

      // Default to newest if no selector
      if (!targetWindowId) {
        targetWindowId = windowRegistry.getNewest()?.id;
      }

      if (!targetWindowId) {
        throw new Error('No window found to assign to group');
      }

      // Emit event to assign window to group
      eventBus.emit('window:assign_group', {
        windowId: targetWindowId,
        groupName: params.groupName
      });

      console.log(`[ToolExecutor] Assigned window ${targetWindowId} to group "${params.groupName}"`);

      const result = {
        taskId: task.id,
        success: true,
        result: {
          windowId: targetWindowId,
          groupName: params.groupName
        },
        timestamp: Date.now()
      };

      eventBus.emit('ai:tool_call_completed', { task, tool: 'assign_group', result });
      return result;

    } catch (error) {
      const errorMsg = error instanceof Error ? error.message : String(error);
      eventBus.emit('ai:tool_call_failed', { task, tool: 'assign_group', error: errorMsg });
      
      return {
        taskId: task.id,
        success: false,
        error: errorMsg,
        timestamp: Date.now()
      };
    }
  }

  private generateWindowId(): string {
    return `window_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }

  private async executeEditWindow(task: Task): Promise<ExecutionResult> {
    const params = task.parameters as EditWindowParams;
    eventBus.emit('ai:tool_call_started', { task, tool: 'edit_window', params });

    let targetWindowId = params.windowId;
    if (!targetWindowId && params.selector) {
      if (params.selector === 'newest') targetWindowId = windowRegistry.getNewest()?.id;
      else if (params.selector === 'active') {
        const reg: any = windowRegistry as any;
        targetWindowId = reg.getActive ? reg.getActive()?.id : undefined;
      } else if (params.selector === 'oldest') targetWindowId = windowRegistry.getOldest()?.id;
    }
    if (!targetWindowId) throw new Error('No window found to edit');

    const mode = params.mode || 'set';
    eventBus.emit('ui:update_window', {
      windowId: targetWindowId,
      title: typeof params.title === 'string' ? params.title : undefined,
      contentUpdate: typeof params.content === 'string' || mode === 'clear' ? { mode, text: params.content || '' } : undefined
    });

    const result = { taskId: task.id, success: true, result: { windowId: targetWindowId }, timestamp: Date.now() };
    eventBus.emit('ai:tool_call_completed', { task, tool: 'edit_window', result });
    return result;
  }
}

export const toolExecutor = new ToolExecutor();
</file>

<file path="src/ui/components/window/Window.tsx">
'use client';

import { useEffect, useRef, useState } from 'react';

interface WindowProps {
	children: React.ReactNode;
	id: string;
	title: string;
	initialX: number;
	initialY: number;
	width: number;
	height: number;
	isActive: boolean;
	onClose: () => void;
	onMinimize?: () => void;
	onFocus: () => void;
	hideTitleBar?: boolean;
	group?: { name: string; color: string };
}

export function Window({
	children,
	id,
	title,
	initialX,
	initialY,
	width,
	height,
	isActive,
	onClose,
	onMinimize,
	onFocus,
	hideTitleBar = false,
	group
}: WindowProps) {
	const windowRef = useRef<HTMLDivElement>(null);
	const [position, setPosition] = useState({ x: initialX, y: initialY });
	const [size, setSize] = useState({ width, height });
	const [isMinimized, setIsMinimized] = useState(false);
	const isDraggingRef = useRef(false);
	const dragOffsetRef = useRef({ x: 0, y: 0 });

	useEffect(() => {
		setPosition({ x: initialX, y: initialY });
	}, [initialX, initialY]);

	useEffect(() => {
		setSize({ width, height });
	}, [width, height]);

	const handleMinimize = () => {
		setIsMinimized(true);
		onMinimize?.();
	};

	const handleClose = () => {
		onClose();
	};

	const handleRestore = () => {
		setIsMinimized(false);
		onFocus();
	};

	const onMouseDown = (e: React.MouseEvent) => {
		onFocus();
		isDraggingRef.current = true;
		dragOffsetRef.current = {
			x: e.clientX - position.x,
			y: e.clientY - position.y
		};
		document.addEventListener('mousemove', onMouseMove);
		document.addEventListener('mouseup', onMouseUp);
	};

	const onMouseMove = (e: MouseEvent) => {
		if (!isDraggingRef.current) return;
		setPosition({
			x: e.clientX - dragOffsetRef.current.x,
			y: e.clientY - dragOffsetRef.current.y
		});
	};

	const onMouseUp = () => {
		isDraggingRef.current = false;
		document.removeEventListener('mousemove', onMouseMove);
		document.removeEventListener('mouseup', onMouseUp);
	};

	return (
		<div
			ref={windowRef}
			data-window-id={id}
			className="absolute bg-white rounded-xl shadow-2xl overflow-hidden border border-black/5"
			style={{ left: position.x, top: position.y, width: size.width, height: size.height }}
			onMouseDown={() => onFocus()}
		>
			{!hideTitleBar && (
				<div
					className={`flex items-center justify-between px-3 py-2 select-none ${isMinimized ? 'cursor-pointer' : 'cursor-move'} ${isActive ? 'bg-gray-100' : 'bg-gray-50'}`}
					onMouseDown={isMinimized ? handleRestore : onMouseDown}
					title={isMinimized ? 'Click to restore' : 'Drag to move'}
				>
					<div className="flex items-center space-x-2">
						<button
							onClick={handleClose}
							className="w-3 h-3 rounded-full bg-red-400 hover:bg-red-500 flex items-center justify-center"
							title="Close window"
						>
							<span className="text-white text-xs">Ã—</span>
						</button>
						<button
							onClick={handleMinimize}
							className="w-3 h-3 rounded-full bg-yellow-400 hover:bg-yellow-500 flex items-center justify-center"
							title="Minimize window"
						>
							<span className="text-white text-xs">âˆ’</span>
						</button>
						<span className="w-3 h-3 rounded-full bg-green-400"></span>
						<span className="ml-2 text-sm font-medium text-gray-800">{title}</span>
					</div>
				</div>
			)}
			{group && (
				<div 
					className="px-3 py-1 text-white text-xs font-medium"
					style={{ backgroundColor: group.color }}
				>
					ðŸ“ {group.name}
				</div>
			)}
			<div className={`w-full bg-white ${isMinimized ? 'h-8 overflow-hidden' : (group ? 'h-[calc(100%-64px)]' : 'h-[calc(100%-36px)]')}`}>
				{!isMinimized && children}
				{isMinimized && (
					<div className="flex items-center justify-center h-full text-gray-500 text-xs">
						Minimized
					</div>
				)}
			</div>
		</div>
	);
}

export default Window;
</file>

<file path="src/ai/AIManager.ts">
import { eventBus } from '@/lib/eventBus';
import type { Task } from './types';

export class AIManager {
  private worker: Worker | null = null;
  private isInitialized = false;
  private uiContext: any = {};

  // Only send data that can be structured-cloned to the worker
  private getSerializableUIContext(): any {
    try {
      const context = this.uiContext || {};
      const serializable: any = {};

      if (Array.isArray(context.windows)) {
        serializable.windows = context.windows.map((w: any) => ({
          id: w?.id,
          title: w?.title,
          // omit component/functions; include only plain data
          isOpen: Boolean(w?.isOpen),
          isMinimized: Boolean(w?.isMinimized),
          x: typeof w?.x === 'number' ? w.x : undefined,
          y: typeof w?.y === 'number' ? w.y : undefined,
          width: typeof w?.width === 'number' ? w.width : undefined,
          height: typeof w?.height === 'number' ? w.height : undefined,
          zIndex: typeof w?.zIndex === 'number' ? w.zIndex : undefined
        }));
      }

      return serializable;
    } catch {
      return {};
    }
  }

  async initialize(): Promise<void> {
    if (this.isInitialized) return;

    try {
      this.worker = new Worker(new URL('./aiWorker.ts', import.meta.url));
      
      this.worker.onmessage = (event) => {
        const { type, data } = event.data;
        // Normalize error channel
        if (type === 'AI_ERROR') {
          eventBus.emit('ai:error', data);
          return;
        }
        // Bridge UI_* messages to UI event bus
        if (type === 'UI_OPEN_WINDOW') {
          eventBus.emit('ui:open_window', data);
          return;
        }
        if (type === 'UI_CLOSE_WINDOW') {
          eventBus.emit('ui:close_window', data);
          return;
        }
        eventBus.emit(`ai:${type.toLowerCase()}`, data);
      };

      this.worker.onerror = (error) => {
        console.error('AI worker error:', error);
        eventBus.emit('ai:error', error);
      };

      this.isInitialized = true;
      eventBus.emit('ai:initialized');

      // Bridge: when input emits parsed task strings, forward each to worker for parsing & execution
      eventBus.on('input:tasks', (data: { tasks: Array<{ id: string; text: string }> }) => {
        try {
          const items = Array.isArray(data?.tasks) ? data.tasks : [];
          if (items.length === 0) return;
          eventBus.emit('ai:processing', { count: items.length });
          for (const item of items) {
            const text = item?.text ?? '';
            if (typeof text === 'string' && text.trim().length > 0) {
              this.worker?.postMessage({
                type: 'PROCESS_TEXT_COMMAND',
                data: { text, uiContext: this.getSerializableUIContext() }
              });
            }
          }
        } catch (e) {
          eventBus.emit('ai:error', e);
        }
      });
    } catch (error) {
      console.error('Failed to initialize AI worker:', error);
      eventBus.emit('ai:error', error);
    }
  }

  setUIContext(context: any): void {
    this.uiContext = context;
  }

  processRequest(request: any): void {
    if (!this.worker) {
      console.warn('AI worker not initialized');
      return;
    }

    this.worker.postMessage({
      type: 'PROCESS_AI_REQUEST',
      data: { ...request, uiContext: this.getSerializableUIContext() }
    });
  }

  processTextCommand(text: string): void {
    if (!this.worker) {
      console.warn('AI worker not initialized');
      return;
    }

    this.worker.postMessage({
      type: 'PROCESS_TEXT_COMMAND',
      data: { text, uiContext: this.getSerializableUIContext() }
    });
  }

  generateResponse(prompt: any): void {
    if (!this.worker) {
      console.warn('AI worker not initialized');
      return;
    }

    this.worker.postMessage({
      type: 'GENERATE_RESPONSE',
      data: prompt
    });
  }

  analyzeData(data: any): void {
    if (!this.worker) {
      console.warn('AI worker not initialized');
      return;
    }

    this.worker.postMessage({
      type: 'ANALYZE_DATA',
      data: data
    });
  }

  destroy(): void {
    if (this.worker) {
      this.worker.terminate();
      this.worker = null;
    }
    this.isInitialized = false;
    eventBus.emit('ai:destroyed');
  }
}

export const aiManager = new AIManager();
</file>

<file path="src/ai/cerebrasClient.ts">
/* eslint-disable @typescript-eslint/no-explicit-any */
import { CerebrasRequest, CerebrasResponse, Tool, CerebrasTool } from './types';

export class CerebrasClient {
  // Client no longer holds API key; all calls go through server route
  constructor(_apiKey?: string) {}

  async createChatCompletion(request: CerebrasRequest): Promise<CerebrasResponse> {
    // Always call our internal API route which adds auth server-side
    let targetUrl = '/api/cerebras-tasks';

    try {
      // Debug: log environment context from worker/main thread
      const isWorkerScope = typeof self !== 'undefined' && (self as unknown as { importScripts?: unknown }).importScripts !== undefined;

      // In worker context, construct absolute URL using worker's location
      if (isWorkerScope) {
        let workerOrigin = 'http://localhost:3000'; // fallback

        try {
          // Try to get the actual origin from the worker's location
          if (typeof location !== 'undefined' && (location as any)?.origin) {
            workerOrigin = (location as any).origin;
          } else if (typeof location !== 'undefined' && location?.href) {
            // Fallback: extract origin from href
            const url = new URL(location.href);
            workerOrigin = url.origin;
          }
        } catch (error) {
          console.warn('[CerebrasClient] Failed to determine worker origin:', error);
        }

        targetUrl = `${workerOrigin}/api/cerebras-tasks`;
      }

      // Avoid leaking secrets; only log safe runtime details
      console.log('[CerebrasClient] createChatCompletion', {
        targetUrl,
        isWorkerScope,
        locationHref: (typeof location !== 'undefined' && location?.href) ? location.href : 'n/a',
        baseHref: (typeof document !== 'undefined' && (document as any)?.baseURI) ? (document as any).baseURI : 'n/a'
      });
    } catch {
      // ignore logging errors
    }

    const response = await fetch(targetUrl, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ cerebrasRequest: request })
    });

    if (!response.ok) {
      const errorText = await response.text();
      throw new Error(`Internal API error (${response.status}): ${errorText}`);
    }

    return await response.json() as CerebrasResponse;
  }

  async processTextToTasks(text: string, tools: Tool[], uiContext: any = {}): Promise<CerebrasResponse> {
    const uiState = uiContext.windows && uiContext.windows.length > 0
      ? `Current open windows:\n${uiContext.windows.map((w: any) => `- id: ${w.id}, title: ${w.title}, content: ${w.content ? `"${w.content.substring(0,100).replace(/\n/g, ' ').replace(/"/g, '\\"')}"${w.content.length > 100 ? '...' : ''}` : 'none'}`).join('\n')}`
      : 'No windows are currently open.';

    const systemPrompt = `You are Jarvis, an AI assistant that converts natural language commands into structured tool calls.

${uiState}

Available tools:
${tools.map(tool => `- ${tool.name}: ${tool.description}`).join('\n')}

Your job is to:
1. Analyze the user's text input and the current UI state.
2. Identify what actions they want to perform.
3. Convert those actions into appropriate tool calls.
4. When closing a window, use the ID from the list of open windows.
5. Handle complex multi-command requests by breaking them into multiple tool calls.

For window operations:
- When opening windows, infer appropriate window types (sticky-note, notification, dialog, settings, general, lesson, quiz, hint, explainer)
- Extract relevant context like titles, content, and any positioning hints
- For sticky notes, use windowType "sticky-note" and include the note content in context.content
- For education intents:
  * "lesson" or "start lesson" â†’ windowType "lesson"; set context.title and optional context.metadata.step
  * "quiz" â†’ windowType "quiz"; set context.title from the prompt
  * "hint" â†’ windowType "hint"; set context.title to the topic and context.content to the short hint text if provided
  * "explain" / "step by step" â†’ windowType "explainer"; set context.title to the topic and include brief explanatory content if available

Few-shot guidance (intent â†’ tool call shape):
- User: "start lesson \"Derivatives\" step 1" â†’ open_window { windowType: "lesson", context: { title: "Derivatives", type: "lesson", metadata: { step: 1 } } }
- User: "open a quiz titled \"Chapter 3 Review\"" â†’ open_window { windowType: "quiz", context: { title: "Chapter 3 Review", type: "quiz" } }
- User: "give me a hint about \"Pythagorean theorem\"" â†’ open_window { windowType: "hint", context: { title: "Pythagorean theorem", content: "a^2 + b^2 = c^2", type: "hint" } }
- User: "explain \"binary search\" step by step" â†’ open_window { windowType: "explainer", context: { title: "Binary search", type: "explainer" } }
- User: "open 5 windows saying hello" â†’ [create 5 separate open_window calls with same content "hello"]
- User: "close all windows" â†’ close_window { selector: "all" }\n- User: "search for the top 5 health risks for cardiac disease" â†’ web_search { query: "top 5 health risks cardiac disease", resultCount: 5, displayMode: "auto" }\n- User: "open a window and search for AI news" â†’ web_search { query: "AI news", resultCount: 5, displayMode: "auto" }\n- User: "look up information about quantum computing" â†’ web_search { query: "quantum computing information", resultCount: 5, displayMode: "auto" }\n

IMPORTANT: When user asks to open multiple windows (e.g., "open 5 windows"), create multiple separate tool calls, one for each window.\n\nFor web search operations:\n- Use web_search tool when user wants to search, look up, or find information online\n- Extract the search query from natural language\n- Set appropriate resultCount if specified (default 5)\n- Use displayMode "auto" unless specified otherwise

Always respond using the available tools. If the request is unclear, make reasonable assumptions.`;

    // Convert our tool format to Cerebras expected format
    const cerebrasTools: CerebrasTool[] = tools.map(tool => ({
      type: 'function',
      function: {
        name: tool.name,
        description: tool.description,
        parameters: tool.parameters
      }
    }));

    const request: CerebrasRequest = {
      model: 'llama3.1-8b',
      messages: [
        {
          role: 'system',
          content: systemPrompt
        },
        {
          role: 'user',
          content: text
        }
      ],
      tools: cerebrasTools,
      tool_choice: 'auto',
      temperature: 0.1,
      max_tokens: 1000
    };

    return await this.createChatCompletion(request);
  }
}
</file>

<file path="src/ui/MainUI.tsx">
'use client';

import { useEffect, useRef, useState } from 'react';
import { aiManager } from '@/ai';
import { inputManager, VoiceTaskListener } from '@/input';
import { eventBus } from '@/lib/eventBus';
import { WindowManager, WindowManagerRef } from './components/windowManager';
import { InputWindow } from './components/inputWindow';
import { AIWindow } from './components/aiWindow';
import { UserNotes } from './components/userNotes';
import { SystemOutput } from './components/systemOutput';
import { GraphWindow } from './components/graphWindow';
import { BarGraphWindow } from './components/barGraphWindow';
import { PieChartWindow } from './components/pieChart';
import { AnimatedBackground } from './components/background';
import { ImageDropZone } from './components/imageDropZone';
import { ImageViewer } from './components/imageViewer';
import { DebugSidebar } from './components/debugSidebar';

export function MainUI() {
  const windowManagerRef = useRef<WindowManagerRef>(null);
  const [inputStatus, setInputStatus] = useState<'idle' | 'listening' | 'processing' | 'error'>('idle');
  const [aiStatus, setAiStatus] = useState<'idle' | 'processing' | 'ready' | 'error'>('idle');
  const [apiBudget, setApiBudget] = useState<{ used: number; nextMs: number | null }>({ used: 0, nextMs: null });

  useEffect(() => {
    aiManager.initialize();
    inputManager.initialize();

    const unsubs = [
      eventBus.on('input:initialized', () => setInputStatus('idle')),
      eventBus.on('speech:started', () => setInputStatus('listening')),
      eventBus.on('speech:ended', () => setInputStatus('idle')),
      eventBus.on('input:voice_debug', (d: any) => {
        setInputStatus((d?.status as any) || 'idle');
        setApiBudget({ used: d?.apiCallsUsedLastMinute ?? 0, nextMs: d?.nextCallInMs ?? null });
      }),
      eventBus.on('ai:initialized', () => setAiStatus('ready')),
      eventBus.on('ai:processing', () => setAiStatus('processing')),
      eventBus.on('ai:ai_tasks_executed', () => setAiStatus('ready')),
      eventBus.on('ai:text_command_processed', () => setAiStatus('ready')),
      eventBus.on('ai:ai_response_generated', () => setAiStatus('ready')),
      eventBus.on('ai:error', () => setAiStatus('error'))
    ];
    return () => { unsubs.forEach(u => u()); };
  }, []);

  const handleOpenInputWindow = () => {
    windowManagerRef.current?.openWindow({
      id: 'input-window',
      title: 'Input Manager',
      component: InputWindow,
      x: 100,
      y: 100,
      width: 400,
      height: 300
    });
  };

  const handleOpenAIWindow = () => {
    windowManagerRef.current?.openWindow({
      id: 'ai-window',
      title: 'AI Manager',
      component: AIWindow,
      x: 200,
      y: 150,
      width: 400,
      height: 300
    });
  };

  const handleOpenUserNotesWindow = () => {
    windowManagerRef.current?.openWindow({
      id: 'user-notes-window',
      title: 'Personal Notes',
      component: UserNotes,
      x: 300,
      y: 200,
      width: 500,
      height: 400
    });
  };

  const handleOpenSystemOutputWindow = () => {
    windowManagerRef.current?.openWindow({
      id: 'system-output-window',
      title: 'System Output',
      component: SystemOutput,
      x: 350,
      y: 250,
      width: 600,
      height: 450
    });
  };

  const openImageViewerWindow = (imageUrl: string, imageName: string) => {
    const windowId = `image-viewer-${Date.now()}`;
    windowManagerRef.current?.openWindow({
      id: windowId,
      title: `Image: ${imageName}`,
      component: () => <ImageViewer imageUrl={imageUrl} imageName={imageName} />,
      x: 400,
      y: 300,
      width: 700,
      height: 500
    });
  };

  const handleImageUpload = (imageUrl: string, imageName: string) => {
    openImageViewerWindow(imageUrl, imageName);
  };

  const handleOpenGraphWindow = () => {
    windowManagerRef.current?.openWindow({
      id: 'graph-window',
      title: 'Line Graph',
      component: GraphWindow,
      x: 400,
      y: 100,
      width: 750,
      height: 550
    });
  };

  const handleOpenBarGraphWindow = () => {
    windowManagerRef.current?.openWindow({
      id: 'bar-graph-window',
      title: 'Bar Graph',
      component: BarGraphWindow,
      x: 450,
      y: 150,
      width: 750,
      height: 550
    });
  };

  const handleOpenPieChartWindow = () => {
    windowManagerRef.current?.openWindow({
      id: 'pie-chart-window',
      title: 'Pie Chart',
      component: PieChartWindow,
      x: 500,
      y: 200,
      width: 800,
      height: 600
    });
  };

  const handleOpenPreloadedImageWindow = () => {
    const preloadedImageUrl = 'https://picsum.photos/600/400?random=1';
    const imageName = 'Sample Image';
    openImageViewerWindow(preloadedImageUrl, imageName);
  };

  return (
    <div className="min-h-screen">
      <WindowManager
        ref={windowManagerRef}
        onWindowsChange={(windows) => {
          aiManager.setUIContext({ windows });
        }}
      >
        <AnimatedBackground />
        <VoiceTaskListener />
        <DebugSidebar
          inputStatus={inputStatus}
          aiStatus={aiStatus}
          apiBudget={apiBudget}
          openInputWindow={handleOpenInputWindow}
          openAIWindow={handleOpenAIWindow}
          openUserNotesWindow={handleOpenUserNotesWindow}
          openSystemOutputWindow={handleOpenSystemOutputWindow}
          openGraphWindow={handleOpenGraphWindow}
          openBarGraphWindow={handleOpenBarGraphWindow}
          openPieChartWindow={handleOpenPieChartWindow}
          openPreloadedImageWindow={handleOpenPreloadedImageWindow}
        />
        <div className="absolute bottom-6 right-6 z-10">
          <ImageDropZone onImageUpload={handleImageUpload} />
        </div>
      </WindowManager>
    </div>
  );
}
</file>

</files>
